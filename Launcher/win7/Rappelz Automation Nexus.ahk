#Requires AutoHotkey v1
#InstallKeybdHook
#NoEnv
#SingleInstance Force
SendMode Input
SetWorkingDir %A_ScriptDir%
#include findtext2.ahk
SetBatchLines -1
CoordMode, ToolTip, Screen
CoordMode, Mouse, Screen
;SetKeyDelay, %KeyDelayPress%, %KeyDelayDuration%
; DetectHiddenWindows, off

; Set proper file encoding to prevent INI corruption
FileEncoding, UTF-8
; Request admin privileges
; if not A_IsAdmin
; {
;     Run *RunAs "%A_ScriptFullPath%"
;     ExitApp
; }
; ------------------------------------
; Helper to ensure our target game window is active
; ActivateGameWindow() {
;     global win1
;     if (TargetGameWindow) {
;         WinActivate, ahk_id %win1%
;         Sleep, 30
;     }
; }
; ------------------------------------
; Death detection patterns
global iniFile := A_ScriptDir "\CapturedText.ini"
global CapturedTextINI := A_ScriptDir "\CapturedText.ini"
Global WaypointGUIs := {} ; Map of waypoint indices to GUI names
Global WaypointSize := 15
Global PlacingWaypointMode := false
Global ShowWaypoints := true ; Show/hide waypoints
Global CreatingGUI := false ; Flag to prevent update conflicts during GUI creation
Global WaypointBeingDragged := false ; Track if a waypoint is being dragged
Global DraggedWaypointIndex := 0 ; Track which waypoint is being dragged

global RandomKeyDelayMin := 75
global RandomKeyDelayMax := 100
global RandomKeyPressDurationMin := 65
global RandomKeyPressDurationMax := 90
global CurrentKeyDelay := 0
global CurrentPressDuration := 0

; Set initial random KeyDelay
Global WasWindowActive := true
Global LastStuckCheckTime := 0
Global LastStuckCheckX := 0
Global LastStuckCheckY := 0
Global StuckMoveAttempts := 0
Global IsExecutingCommand := false
;SetRandomKeyDelay()
global usegodmotherbottle := "|<>*106$151.0000000000000000000000000000000000000000000000000000X00DU3361800T1003k4Y00000lU0AE1Vb0Y0080001A2K00000MrSA3rkvjvnr4DLZsazzS0000ASNa3CMLwdD+3kenUSnhtU0006DznDbA/SIbx13p/s9tqzk00U36y1Vna4j+HkUX+b74QvS00Dz0nb0Mtn27Z9sEFZFVWSIj407s0TSy7rj11Sorc8ScbVtvSy03w0200000000000000E0000001zs000000000000000M000000Tzzzzzzzzzzzzzzzzzzzzzzzzzzk"
usegodmotherbottle .= "|<>*120$151.0000000000000000000000000000000000000000000000000000008k03s0UlUG007kE00w19000004M0340MNk/0020000H0YU00002BrX0xwCvzwzl3ztS9jzLU00037aNUna5z+nnUwDgs7gdCM0001Xzwntn2rZNzkEzmz2SIjw0000FbUMQtV/mgwM8ntll7+HU00008Vk6CQkVtKSA4NwMMXZ9k00007rj1xvsErhBu27e9sSSqj3zy00U00000000000004000011"

; Resurrection settings
global ResurrectionEnabled := false
global MaxResurrections := 8
global CurrentResurrections := 0
global DeathCheckActive := false
; ========= AutoOracle Variables =========
global HealthPattern := "|<>##000000$0/0/00AA90,1/0/00AA90"
HealthPattern .= "|<>##000000$0/0/42D019"
healthpattern.= "|<>##0.90$0/0/51CA2F,0/1/48C723,0/2/42D019,0/3/25A800,0/4/259F00"

global BoundingBoxes := []
global PlayerCoords := []
global PetCoords := []

; Portrait patterns
global playerinparty:= "|<magus>F9FEFA-0.90$18.1zsMDy0Ty3zzC1zE0z04T0AD0MD1kD3UB3UB3U91U930E40U810E00U"
playerinparty.= "|<Corruptor>502668-0.86$18.U010000003zlTaMxkQ3Dz1zz1xb0vr0wP1NX3rp6Ds7/k5705WV7q3U"
playerinparty.= "|<Templar>**50$16.DDssyaTeqsOxbyszzrGRnAbBuTJjjSS/X8ANVX6qQOn028"
playerinparty.= "|<voidmage>000002-0.79$18.00000003s0Dw0zw1zo3zo27k63k73k47k47kA3kRbsz7wzzy7zzU"
playerinparty.= "|<deadeye>655593-0.81$18.U0Vy76wDXkzTVyS3ywvpwxfxx3tyLvufnkmG/Ya3qYH78KTE4y0jySU"
playerinparty.= "|<beastmaster>040108-0.90$16.0000000060kTD1zwTzuTzoDksS7kkznDzzzzzzzzU"
playerinparty.= "|<slayer>41444B-0.74$17.0000005U4308VEM3zV5z0bx/7wQ7sy7ky7VyDXyDbyDDy8"
playerinparty.= "|<berserker>DAEEEF-0.70$16.0Q01r06w0Tk1y07l0T43skTz3zETs7zczt3s8D1UU"
playerinparty.= "|<overlord>604160-0.90$16.7zky333gCDkzzXzy7z2Tm8zU1TY68k4P0880U00VU"
playerinparty.= "|<Marksman>*58$18.0D00T00z01y03y06y00w61wDXjznDzb1ya7wASMQwMvkVz06U"
playerinparty.= "|<masterbreeder>A7640B-0.90$16.3U0w43kEM9VUq77wTzkvt3yM7s08s0FI022"
; Portrait patterns
global magus := "|<>F9FEFA-0.90$18.1zsMDy0Ty3zzC1zE0z04T0AD0MD1kD3UB3UB3U91U930E40U810E00U"
global Corruptor := "|<>502668-0.86$18.U010000003zlTaMxkQ3Dz1zz1xb0vr0wP1NX3rp6Ds7/k5705WV7q3U"
global Templar :="|<>**50$16.DDssyaTeqsOxbyszzrGRnAbBuTJjjSS/X8ANVX6qQOn028"
global voidmage:="|<>000002-0.79$18.00000003s0Dw0zw1zo3zo27k63k73k47k47kA3kRbsz7wzzy7zzU"
global deadeye:="|<>655593-0.81$18.U0Vy76wDXkzTVyS3ywvpwxfxx3tyLvufnkmG/Ya3qYH78KTE4y0jySU"
global beastmaster:="|<>040108-0.90$16.0000000060kTD1zwTzuTzoDksS7kkznDzzzzzzzzU"
global slayer:="|<>41444B-0.74$17.0000005U4308VEM3zV5z0bx/7wQ7sy7ky7VyDXyDbyDDy8"
global berserker:="|<>DAEEEF-0.70$16.0Q01r06w0Tk1y07l0T43skTz3zETs7zczt3s8D1UU"
global overlord:="|<>604160-0.90$16.7zky333gCDkzzXzy7z2Tm8zU1TY68k4P0880U00VU"
global masterbreeder:="|<>A7640B-0.90$16.3U0w43kEM9VUq77wTzkvt3yM7s08s0FI022"
global Marksman := "|<>*58$18.0D00T00z01y03y06y00w61wDXjznDzb1ya7wASMQwMvkVz06U"

global petsinparty := "|<windpixie>AEAD43-0.69$18.0400A00A00A0UA0sS0sS0kQ1xR1vTHNz7VTDlRDsQTwATsAMwANU"
petsinparty.= "|<gnoll>887868-0.74$17.uXZk7bE2L0SR1IwBVtHnakj1lT6rsr3lpL/pT+kz5LyHLzITk"
petsinparty.= "|<etherealpixie>CA4EB0-0.73$18.0400400A00800800+00S00Q04Q12TH0z7UTDUQDsATwATsAMwAMU"

global windpixie := "|<>AEAD43-0.69$18.0400A00A00A0UA0sS0sS0kQ1xR1vTHNz7VTDlRDsQTwATsAMwANU"
global gnoll := "|<>887868-0.74$17.uXZk7bE2L0SR1IwBVtHnakj1lT6rsr3lpL/pT+kz5LyHLzITk"
global etherealpixie := "|<>CA4EB0-0.73$18.0400400A00800800+00S00Q04Q12TH0z7UTDUQDsATwATsAMwAMU"
global partywindow := "|<>*142$15.Tzszy80azus0yzvqvSuvrjSuvqvTTrxxymPjjjzzzzw"
partywindow .= "|<>FFFFFF-0.90$13.E17z40GF954V2FF94W0UUVBZ11U"
global partywindowlogo := "|<>*137$16.TzwTz208rzLU3xzrqvTRRxvrrLTPhyzjxxzNBvvvU"

; Global variables for patterns

global patterns := {} ; Store all loaded patterns in this object
global patternKeys := {} ; Store key assignments for each pattern
global patternNames := {} ; Store custom names for each pattern
global patternCounter := 1 ; Counter for automatic pattern naming
global HealerStatusText := ""
global healControlCounter := 1 ; Counter for heal control naming
global TargetGameWindow := "" ; Store target game window ID
global TargetGameTitle := "" ; Store target game window title
global TargetGamePID := "" ; Store target game window PID
global CriticalModeEnabled := false ; Track Critical mode state
global healPriorities := [] ; Array to store heal skill priority order
global healCheckInterval := 30 ; Heal check interval in milliseconds
global healThresholdPercent := 95 ; Percentage of health to trigger healing (95% = heal when health < 95%)
global healanddps := false
global dpstargetedhealing := false
; Heal ground targeting variables
global healGroundTargetSkills := {} ; Store which heal skills are ground-targeted
global healGroundTargetCoords := {} ; Store ground target click coordinates for each heal skill
; Heal pre-cast key variables
global healPressKeyBeforeCast := {} ; Store whether to press key before casting heal
global healPreCastKeys := {} ; Store the key to press before casting heal
; Manual healing variables
global PlayerCount := 0
global PetCount := 0
global ManualPlayerCoords := []
global ManualPetCoords := []
global isManualHealingActive := false
; DPS targeted healing variables
global DPSTargetedPlayerCoords := []
global DPSTargetedPetCoords := []
; ========= DPS Variables =========
global dpsPatterns := {} ; Store all DPS patterns
global dpsPatternKeys := {} ; Store key assignments for DPS patterns
global dpsPatternNames := {} ; Store custom names for DPS patterns
global dpsGroundTargetSkills := {} ; Store which skills are ground-targeted
global dpsGroundTargetCoords := {} ; Store ground target click coordinates for each skill
global dpsPressKeyBeforeCast := {} ; Store whether to press key before casting
global dpsPreCastKeys := {} ; Store the key to press before casting
global dpsCounter := 1 ; Counter for automatic DPS pattern naming
global dpsPriorities := [] ; Array to store skill priority order
global isDpsRunning := false ; Flag for DPS monitoring
global isSystemBusy := false ; Flag to coordinate between healing/DPS/keypresser
; Melee attack variables
global meleeAttackEnabled := false ; Flag for melee attack after skill cast
global refreshscrollEnabled := false ; Flag for refresh scroll
global meleeAttackKey := "" ; Key to press for melee attack
global refreshkey := "" ; Key to press for refresh scroll
global ccPatterns := {} ; Store all CC patterns
global ccPatternKeys := {} ; Store key assignments for CC patterns
global ccPatternNames := {} ; Store custom names for CC patterns
global ccStunDurations := {} ; Store stun durations for CC patterns
global ccCounter := 1 ; Counter for automatic CC pattern naming
global ccPriorities := [] ; Array to store skill priority order
global isccRunning := false ; Flag for CC monitoring
; QWERTY to QWERTZ conversion
global qwertzModeEnabled := false ; Flag for QWERTY to QWERTZ key conversion
; Define healing skill patterns
global healing := "|<>**50$13.txUTU30CA0A3I68EQ8C6N37Vckk8E"
global restoration := "|<>**50$13.03U000402010DUQEMcSQC2C064XME"
global rapidhealing := "|<>**50$13.Y5C6wCC5i3t38UMEM9d1U000Q1e+E"
global masshealing := "|<>**50$13.R4/07Z3m01CA4C65X2rV5EzsFw83k"
;other globals
global TemplarTargetCount := 1
global TemplarTargetCoords := []
global HolygroundHotkey := ""
global TemplarTargetCountEdit := ""
global HolygroundHotkeyEdit := ""
global RandomXVariation := 5
global RandomYVariation := 5
global MinDelay := 80
global MaxDelay := 150
global activeMonitors := 0
global maxMonitors := 8
global gnollbuff := false
global dtbuff := false
global destroypotions := false
; Pet buff pattern arrays
global gnollPatterns := []
global deathTyrantPatterns := []
; Pet buff timer intervals (in milliseconds)
global gnollBuffInterval := 1800000 ; 30 minutes default
global dtBuffInterval := 3600000 ; 60 minutes default

; Pet buff image patterns for detection
global gnollBuffImagePattern := "" ; Reflecting Shield image pattern
global dtBuffImagePattern := "" ; Monarch image pattern
global customSummonPattern := "" ; Custom summon pattern
global summonKeybind := "+=" ; Default: Shift+= (can be customized)

; Navigation pause state for pet buff execution
global PetBuffExecuting := false
global NavigationPausedForBuff := false
; Rotate Toggles variables
global RotateToggle1Key := ""
global RotateToggle2Key := ""
global RotateToggleRunning := false
global RotateToggleCurrentKey := 1
global RotateToggleTimer := 35000 ; 35 seconds in milliseconds
; Image Clicker variables
global imageClickerPattern := ""
global imageClickerRunning := false
; Image Clicker variables
global imageClickerPatterns := []
global imageClickerRunning := false

global destroyessences := false
global invclosed := false
; Auto-Dura variables
global autoDuraEnabled := false
global autoDuraInterval := 30 ; 30 minutes default
global repairPattern := "|<>**23$14.007ztzyFWYqdMeQ6aX9pOKvYvNzyTzU02"
global DPSHoldHotkey := "" ; saved hotkey string (e.g. F1)
global DPSHotkeyTimerInterval := 200 ; ms
global DPSToggleHotkey := "Insert" ; Default hotkey for start/stop DPS
global autofollowhotkeydefault := "F10"
global autofollowhotkey:= autofollowhotkeydefault 
global selectedKey := "F9" ; Default selection  
hotkey, %autofollowhotkey%, autofollowaction, on
; Set up DPS toggle hotkey
if (DPSToggleHotkey != "")
    hotkey, %DPSToggleHotkey%, ToggleDPSAction, on
global PylonPos1X := ""
global PylonPos1Y := ""
global PylonPos2X := ""
global PylonPos2Y := ""
global PylonSetupActive := false
global PylonClickCount := 0
; Default autofollow hotkey
;global autofollowhotkeydefault := "q"   
; Profile system variables
global CurrentProfileName := "Default"
global BuffProfiles := {}
global ProfileSettingsFile := "buff_profiles.ini"

; ========= Navigation Variables =========
global NavText := "|<0>*95$5.W1nbCQtoTzz"
NavText .= "|<1>*87$5.zzyEtnbCQUz"
NavText .= "|<2>*95$5.zA7jQvivkTz"
NavText .= "|<3>*95$5.zy8DSnXri1z"
NavText .= "|<4>*95$6.zzztldNN0tttzU"
NavText .= "|<5>*95$5.z01nVtvr0zz"
NavText .= "|<6>*95$6.zzlVDT1RQQBVzU"
NavText .= "|<7>*95$4.zk3gqPBry"
NavText .= "|<8>*95$7.lmPhq31i7/g6"
NavText .= "|<9>*95$5.0tnUGxkDzzz"

;============================================

Global win2 := ""
Global win2PID := ""
Global Waypoints := []
Global CurrentWaypoint := 0
Global CameraRadius := 900
Global PixelsPerGameUnitX := 100 / 89
Global PixelsPerGameUnitY := 100 / 43
Global CameraAngle := 0
Global SelectedRouteFile := ""
Global CameraFile := ""
Global IsTraveling := false
Global RouteStatus
global NavTargetGameWindow := ""
global NavTargetGamePID := ""
global NavWaypoints := []
global NavCurrentWaypoint := 0
global NavCameraRadius := 900
global NavPixelsPerGameUnitX := 100 / 89
global NavPixelsPerGameUnitY := 100 / 43
global NavCameraAngle := 0
global NavSelectedRouteFile := ""
global NavCameraFile := ""
global NavIsTraveling := false
global NavWaypointCount := 0
global NavCameraLocked := false
; DPS Navigation variables
global dpsNavEnabled := false
global dpsNavTargetX := ""
global dpsNavTargetY := ""
global dpsNavRadius := 50
; Pylon positioning variables
global pylonPos1X := ""
global pylonPos1Y := ""
global pylonPos2X := ""
global pylonPos2Y := ""
; Coordinate variables for checkweight and snapshot (shared coordinates)
global checkweightX1 := 880
global checkweightY1 := 472
global checkweightX2 := 981
global checkweightY2 := 488
global pylonresetlocationset := false
; ; Define skill bar search area (bottom portion of screen)
; global SkillBarX1 := 92
; global SkillBarY1 := 594
; global SkillBarX2 := 953
; global SkillBarY2 := 755
global SequentialDPSEnabled := false
global CurrentSequentialIndex := 1

; ========= KeyPresser Variables =========
; Global variables

global win1 := ""
global SettingsFile := "keypresser_settings.ini"
global SkipInitial1 := false

; Sequence 1 variables
global KeyCombination1 := ""
global KeyDelay1 := 0.1
global TimerInterval1 := 1
global IsRunning1 := false
global KeySequence1 := []
global NextExecutionTime1 := 0

; Sequence 2 variables
global KeyCombination2 := ""
global KeyDelay2 := 0.1
global TimerInterval2 := 2
global IsRunning2 := false
global KeySequence2 := []
global NextExecutionTime2 := 0

; Sequence 3 variables
global KeyCombination3 := ""
global KeyDelay3 := 0.1
global TimerInterval3 := 3
global IsRunning3 := false
global KeySequence3 := []
global NextExecutionTime3 := 0

; Sequence 4 variables
global KeyCombination4 := ""
global KeyDelay4 := 0.1
global TimerInterval4 := 4
global IsRunning4 := false
global KeySequence4 := []
global NextExecutionTime4 := 0

; Sequence 5 variables
global KeyCombination5 := ""
global KeyDelay5 := 0.1
global TimerInterval5 := 5
global IsRunning5 := false
global KeySequence5 := []
global NextExecutionTime5 := 0

; Sequence 6 variables
global KeyCombination6 := ""
global KeyDelay6 := 0.1
global TimerInterval6 := 6
global IsRunning6 := false
global KeySequence6 := []
global NextExecutionTime6 := 0

; Timer execution flags for waypoint-based execution
global gnollBuffNeeded := false
global dtBuffNeeded := false
global sequence1Needed := false
global sequence2Needed := false
global sequence3Needed := false
global potionDestroyNeeded := false
global duraRepairNeeded := false
global signalCheckCounter := 0

; GUI control variables

global KeyCombinationEdit1 := ""
global KeyDelayEdit1 := ""
global TimerIntervalEdit1 := ""
global KeyCombinationEdit2 := ""
global KeyDelayEdit2 := ""
global TimerIntervalEdit2 := ""
global KeyCombinationEdit3 := ""
global KeyDelayEdit3 := ""
global TimerIntervalEdit3 := ""
global farming := false
global returnafterheal
global CurrentChar := 1
global selectedChars := []
;templar globals
;global iniFile := "templarpuller.ini"
global pullAreas := 3
global clickLocations := 4
global randomOffsetX := 5
global randomOffsetY := 5
global returnSleepTime := 4500
global mouseMoveDelay := 90
global mouseClickDelay := 50
global movementAreaSet := false
global movementX1 := 0, movementY1 := 0, movementX2 := 0, movementY2 := 0
global movementArea2Set := false
global movement2X1 := 0, movement2Y1 := 0, movement2X2 := 0, movement2Y2 := 0
global clickCoords := []
global pullingActive := false
global currentPullArea := 1
global currentClickIndex := 1
global selectedWindow := ""
global PullAreasEdit
global ClickLocationsEdit
global OffsetXEdit
global OffsetYEdit
global SleepTimeEdit
global MovementStatus
global WindowStatus
global StatusText
global MouseMoveDelayEdit
global MouseClickDelayEdit
global MainTabs
Global refreshScrollEndTime := 0

; Add these with your other global variables at the top of your script
; Add these at the very top of your script with other globals
global dpsEnabled := false
global dpsHotkey := "2"
global dpsDuration := 3000
global dpsStatusText
; Key delay variables for randomization
global KeyDelayPress := 100
global KeyDelayDuration := 90
global MonitorWindowID := ""
global BaselineImage := ""
global MonitorActive := false
global movingg := false
global autofolloww := false
global randomdelaymax := 250
global randomdelaymin := 80
global pullHotkey := "1" ; Default value
global templardps := false
; Live calibration variables
Global CalibrationActive := false
Global CalibrationClicks := []
Global CalibrationStartX := 0
Global CalibrationStartY := 0
Global NavigationIniFile := A_ScriptDir "\AdvancedNavigation.ini"
; NEW VARIABLES FOR ENHANCED FEATURES
Global DistanceToleranceX := 50 ; Distance tolerance X
Global DistanceToleranceY := 50 ; Distance tolerance Y
Global MovementMode := "click" ; "click" or "wasd"
Global MaxClickDistance := 140 ; Maximum click distance in pixels
Global WASDKeys := {w: false, a: false, s: false, d: false} ; Track key states
Global WaypointCommands := {} ; Store commands for each waypoint
Global SingleWaypointMode := false ; Track if going to single waypoint vs full route
;Global Farming := false ; Track farming mode status

; Visual nodes for click targeting (multiple nodes)
Global TargetNodes := [] ; Array of node objects {id, worldX, worldY, guiID}
Global NodeGUIs := {} ; Map of node IDs to GUI names
Global NodeSize := 15
Global PlacingNodeMode := false
Global NextNodeID := 1
Global AvailableNodeIDs := [] ; Stack of deleted node IDs to reuse
Global ShowTargetNodes := true ; Show/hide target nodes
Global LastPlayerX := 0 ; Track last position for optimization
Global LastPlayerY := 0
Global NodeBeingDragged := false ; Track if a node is being dragged
Global DraggedNodeID := 0 ; Track which node is being dragged
Global NodeMoveMode := false ; Track if in interactive move mode
Global NodesMovedDuringSession := {} ; Track which nodes were moved during move mode
Global ResourcesINI := A_ScriptDir . "\resources.ini"

; ========= Initialization =========
; Load saved text patterns when script starts
LoadAllPatterns()
InitializePatternCounter() ; Initialize the counter based on existing patterns
; Load pet buff patterns and timers
LoadPetBuffPatterns()
LoadPetBuffTimers()
; Update GUI labels with loaded timer values
UpdatePetBuffLabels()
; Load auto-dura settings
LoadAutoDuraSettings()
; Load skillbar coordinates
LoadSkillbarCoordinates()
; Load QWERTZ keyboard setting
LoadQWERTZSetting()
; Load custom names into memory at startup
ReloadCustomNames()

; Load heal priorities and settings
LoadHealPriorities()
LoadHealSettings()

; Load DPS patterns and settings
LoadAllDPSPatterns()
LoadDPSPriorities()
LoadAllCCPatterns()
LoadCCPriorities()
;LoadTemplarSettings()
LoadImageClickerSettings()

LoadSettings()
; NOTE: LoadAllCheckboxStates() and GUI control initialization is now called AFTER GUI is created (see line ~809)
CheckPreviousSettings()
LoadWaypoints()
CoordMode, Pixel, Screen
coordmode, mouse, screen

; Auto-load keypresser settings on startup
Gosub, LoadKeypresserSettings

; Load pet buff image settings
Gosub, LoadPetBuffImageSettings

; Load game window settings
LoadGameWindowSettings()

; Load default profile  
LoadDefaultProfile()

; Create the combined GUI
Gosub, CreateCombinedGUI
return

CreateCombinedGUI:
    ; Create main GUI with tabs (added Templar tab)
    Gui, Add, Tab3, x10 y10 w520 h630 vMainTabs, Setup|Healer|DPS|CC|Buffs|Tools|Navigation|Templar

    ; ===== Setup tab =====
    Gui, Tab, Setup
    ; Window Setup Section
    Gui, Add, GroupBox, x20 y40 w470 h90, Game Setup
    Gui, Add, Button, x30 y60 w120 h30 gSelectWindow, Select Game Window
    Gui, Add, Button, x300 y60 w120 h30 gShowThumbnailView, Show Thumbnail View
    Gui, Add, Text, x160 y65 w130 h20 vWindowStatus, No window selected
    Gui, Add, Button, x30 y95 w80 h25 gLaunchGame, Launch Game
    Gui, Add, Button, x120 y95 w80 h25 gSelectGame, Select Game
    Gui, Add, Button, x210 y95 w80 h25 gCharacters, Characters
    Gui, Add, Button, x300 y95 w80 h25 gpasswordonly, Password

    ; Main Controls Section
    Gui, Add, GroupBox, x20 y140 w490 h125, Main Controls
    Gui, Add, Button, x30 y160 w100 h30 gStartDynamicHealing, Start Healer
    Gui, Add, Button, x140 y160 w100 h30 gCancelHealerScript, Stop Healer
    Gui, Add, Button, x250 y160 w100 h30 gStartDPSScript, Start DPS
    Gui, Add, Button, x360 y160 w100 h30 gStopDPSScript, Stop DPS
    Gui, Add, Checkbox, x30 y200 w170 vhealanddps ghealanddps, Enable DPS + Heal Combo
    Gui, Add, Checkbox, x200 y200 w130 vdpstargetedhealing gdpstargetedhealing, DPS + Targeted Heal
    Gui, Add, Checkbox, x200 y220 w120 vreturnafterheal greturnafterheal, Follow f2 after heal
    Gui, Add, Checkbox, x30 y220 w140 vfarming gfarming, Enable Farming Mode
    gui, add, checkbox, x340 y200 w180 vdestroyskypotionstimer gdestroyskypotionstimer, Destroy Potions (5 mins)
    gui, add, checkbox, x340 y220 w130 vinfinitemouse ginfinitemouse, Infinite Mouse
    Gui, Add, Checkbox, x30 y240 w140 h20 vrefreshscrollEnabled grefreshscrollToggle, Enable refresh scroll (1 Hr)
    Gui, Add, Text, x240 y240 w150 h20 vrefreshScrollTimer, Time left: --:--:--
    Gui, Add, Edit, x180 y240 w50 h20 vrefreshKey grefreshKeyChanged
    GuiControl, Hide, refreshKeyLabel
    GuiControl, Hide, refreshKey
    ; Keyboard Layout Section
    ;Gui, Add, GroupBox, x20 y240 w200 h30, Keyboard Layout
    ;gui, add, checkbox, x30 y255 w150 vqwertzmode gqwertzmode, QWERTZ-Keys

    ; Auto-Resurrection Section
    Gui, Add, GroupBox, x20 y280 w470 h70, Auto-Resurrection
    Gui, Add, Checkbox, x30 y300 w150 vResurrectionEnabled gResurrectionEnabled, Enable Auto-Resurrection
    ;gui, add, button, x200 y270 w80 h20 gtestdeathdetection, Test
    Gui, Add, Text, x30 y320 w120 h20, Max Resurrections:
    Gui, Add, Edit, x150 y320 w50 h20 vMaxResurrectionsEdit
    Gui, Add, Button, x210 y320 w80 h20 gSaveResurrectionSettings, Save Settings
    Gui, Add, Button, x300 y320 w80 h20 gResetResurrections, Reset Count
    Gui, Add, Text, x390 y320 w80 h25 vResurrectionStatus, Count: 0/8

    ;aut dura Section Section
    Gui, Add, GroupBox, x20 y360 w470 h70, Auto-Dura
    Gui, Add, Checkbox, x30 y380 w150 vautodura gautodura, Enable Auto-Dura
    Gui, Add, Text, x190 y380 w90 h20, Timer (minutes):
    Gui, Add, Edit, x280 y380 w40 h20 vautoDuraIntervalEdit, %autoDuraInterval%
    Gui, Add, Button, x330 y380 w60 h20 gSaveAutoDuraInterval, Save
    Gui, Add, Button, x400 y380 w60 h20 gtestduradetection, Test

    ; DPS Navigation Section
    Gui, Add, GroupBox, x20 y440 w470 h80, DPS Navigation
    Gui, Add, Checkbox, x30 y460 w150 vdpsNavEnabled gdpsNavEnabled, Enable DPS Navigation
    Gui, Add, Text, x230 y460 w80 h20, Group Radius:
    Gui, Add, Edit, x300 y460 w40 h20 vdpsNavRadiusEdit, %dpsNavRadius%
    Gui, Add, Text, x30 y485 w20 h20, X:
    Gui, Add, Edit, x50 y485 w60 h20 vdpsNavTargetXEdit
    Gui, Add, Text, x120 y485 w20 h20, Y:
    Gui, Add, Edit, x140 y485 w60 h20 vdpsNavTargetYEdit
    Gui, Add, Button, x210 y485 w80 h20 gSetDPSNavCoords, Set Current
    Gui, Add, Button, x300 y485 w60 h20 gSaveDPSNavCoords, Save

    ; Text Input Section
    Gui, Add, GroupBox, x20 y530 w470 h80, Text Input
    Gui, Add, Edit, x30 y550 w300 h40 vTextInputBox
    Gui, Add, Button, x340 y550 w60 h40 gSendText, Send
    Gui, Add, Button, x410 y550 w60 h40 gClearText, Clear

    ; ===== HEALER TAB =====
    Gui, Tab, Healer
    ; Configuration Section
    Gui, Add, GroupBox, x20 y40 w470 h120, Healing Configuration
    ;Gui, Add, Text, x30 y60 w85 h20, Check Rate (ms):
    ;Gui, Add, Edit, x120 y60 w60 h20 vHealIntervalInput gValidateHealInterval, %healCheckInterval%
    ;Gui, Add, Button, x190 y60 w50 h20 gSaveHealInterval, Save
    Gui, Add, Button, x30 y60 w100 h20 gTestPartyDetection, Test Detection
    ;Gui, Add, Button, x360 y60 w100 h20 gStartDynamicHealing, Auto Healing

    Gui, Add, Text, x30 y85 w100 h20, Heal at Health `%:
    Gui, Add, Edit, x130 y85 w50 h20 vHealThresholdInput gValidateHealThreshold, %healThresholdPercent%
    Gui, Add, Button, x190 y85 w50 h20 gSaveHealThreshold, Save

    ; Manual healing controls
    Gui, Add, Text, x30 y110 w50 h20, Players:
    Gui, Add, Edit, x80 y110 w30 h20 vPlayerCountEdit, 0
    Gui, Add, Text, x120 y110 w30 h20, Pets:
    Gui, Add, Edit, x150 y110 w30 h20 vPetCountEdit, 0
    Gui, Add, Button, x190 y110 w80 h20 gSetManualCoords, Set Coords
    Gui, Add, Button, x280 y110 w80 h20 gStartManualHealing, Manual Heal
    Gui, Add, Button, x370 y110 w80 h20 gStopManualHealing, Stop Manual

    Gui, Add, Text, x30 y135 w450 h20 vHealerSkillbarCoords, Skillbar: Not set - use Tools tab
    Gui, Add, Text, x30 y130 w450 h20 vManualHealStatus, Manual: Not configured

    ; Skill Management Section
    Gui, Add, GroupBox, x20 y170 w470 h140, Skill Management
    Gui, Add, Button, x30 y190 w130 h30 gAddHealingSkill, Add Heal Skill
    Gui, Add, Button, x170 y190 w130 h30 gfindhealingskill, Test Skills
    Gui, Add, Button, x310 y190 w130 h30 gclearskills, Clear All
    Gui, Add, Button, x30 y230 w130 h30 gAssignHealKeys, Assign Keys
    Gui, Add, Button, x170 y230 w130 h30 gRenameHealSkills, Rename Skills
    ;Gui, Add, Button, x310 y230 w130 h30 gShowHealKeysStatus, Show Status
    Gui, Add, Button, x310 y230 w130 h30 gModifyHealSkill, Modify Skill

    ; Priority Management Section
    Gui, Add, GroupBox, x20 y320 w470 h160, Priority Order
    Gui, Add, ListBox, x30 y340 w350 h140 vHealPriorityList gHealPrioritySelect VScroll
    Gui, Add, Button, x390 y340 w80 h25 gMoveHealUp, Move Up
    Gui, Add, Button, x390 y370 w80 h25 gMoveHealDown, Move Down
    Gui, Add, Button, x390 y400 w80 h25 gRemoveFromHealPriority, Remove
    Gui, Add, Button, x390 y430 w80 h25 gAddToHealPriority, Add

    ; Status Section
    Gui, Add, GroupBox, x20 y490 w470 h120, Healer Status
    Gui, Add, Edit, x30 y510 w450 h90 vHealerStatusEdit ReadOnly VScroll

    ; ===== DPS TAB =====
    Gui, Tab, DPS

    ; Hotkey to hold for continuous DPS + DynamicHealthCheck
    Gui, Add, Text, x50 y350 w220 h20, Hold key to loop DPS + Dynamic Heal:
    Gui, Add, Hotkey, x240 y348 w60 h20 vDPSHoldHotkey gDPSHoldHotkey, % DPSHoldHotkey
    Gui, Add, Text, x320 y350 w60 h20, (hold to run)

    ; DPS Start/Stop Toggle Hotkey
    Gui, Add, Text, x50 y372 w180 h20, Start/Stop DPS Toggle Hotkey:
    Gui, Add, Hotkey, x240 y370 w60 h20 vDPSToggleHotkey gDPSToggleHotkeyChanged, %DPSToggleHotkey%
    Gui, Add, Text, x320 y372 w160 h20, (press to start/stop DPS)

    ; Auto Follow Hotkey
    Gui, Add, Text, x50 y394 w180 h20, Auto Follow Hotkey (e.g. F2):
    gui, add, hotkey, x240 y392 w60 h20 vautofollowhotkey gautofollowhotkey, Auto Follow, %autofollowhotkey%
    gui, add, text, x320 y394 w70 h20, Follow Who?
    Gui, Add, DropDownList, x390 y392 w60 h120 vselectedKey, F2||F3|F4|F5|F6|F7|F8

    ; Melee Attack After Skill Cast
    Gui, Add, Checkbox, x50 y416 w250 h20 vmeleeAttackEnabled gMeleeAttackToggle, Enable Melee After Skill Cast (dps/heal/cc)
    ;ui, Add, Text, x240 y418 w90 h20 vMeleeKeyLabel, Melee Key:
    Gui, Add, Edit, x330 y416 w50 h20 vmeleeAttackKey gMeleeKeyChanged
    GuiControl, Hide, MeleeKeyLabel
    GuiControl, Hide, meleeAttackKey

    ; Force Sequential Mode Checkbox
    Gui, Add, Checkbox, x50 y438 w200 vSequentialDPSMode gSequentialDPSMode, Force Sequential Skill Order

    ; Skill Management Section
    Gui, Add, GroupBox, x20 y40 w470 h110, DPS Skill Management
    Gui, Add, Button, x30 y60 w130 h30 gAddDPSSkill, Add DPS Skill
    Gui, Add, Button, x170 y60 w130 h30 gTestDPSSkills, Test Skills
    Gui, Add, Button, x310 y60 w130 h30 gClearDPSSkills, Clear All
    Gui, Add, Button, x30 y100 w130 h30 gAssignDPSKeys, Assign Keys
    Gui, Add, Button, x170 y100 w130 h30 gRenameDPSSkills, Rename Skills
    Gui, Add, Button, x310 y100 w130 h30 gModifyDPSSkill, Modify Skill

    ; Priority Management Section
    Gui, Add, GroupBox, x20 y160 w470 h140, DPS Priority Order
    Gui, Add, ListBox, x30 y190 w350 h150 vDPSPriorityList gDPSPrioritySelect VScroll
    Gui, Add, Button, x390 y210 w80 h25 gMoveDPSUp, Move Up
    Gui, Add, Button, x390 y240 w80 h25 gMoveDPSDown, Move Down
    Gui, Add, Button, x390 y270 w80 h25 gRemoveFromDPSPriority, Remove
    Gui, Add, Button, x390 y300 w80 h25 gAddToDPSPriority, Add

    ; Status Section
    Gui, Add, GroupBox, x20 y470 w470 h150, DPS Status
    Gui, Add, Edit, x30 y490 w450 h120 vDPSStatusEdit ReadOnly VScroll

    ; ===== CC TAB =====
    gui, tab, CC
    Gui, Add, GroupBox, x20 y40 w470 h100, crowd control
    Gui, Add, Button, x30 y60 w130 h30 gAddCCskill, Add CC Skill
    Gui, Add, Button, x170 y60 w130 h30 gTestCCSkills, Test Skills
    Gui, Add, Button, x310 y60 w130 h30 gClearCCSkills, Clear All
    Gui, Add, Button, x30 y100 w130 h30 gAssignCCKeys, Assign Keys
    Gui, Add, Button, x170 y100 w130 h30 gRenameCCSkills, Rename Skills

    ; Priority Management Section
    Gui, Add, GroupBox, x20 y150 w470 h250, CC Priority Order
    Gui, Add, ListBox, x30 y170 w350 h180 vCCPriorityList gCCPrioritySelect VScroll
    Gui, Add, Button, x390 y170 w80 h25 gMoveCCUp, Move Up
    Gui, Add, Button, x390 y200 w80 h25 gMoveCCDown, Move Down
    Gui, Add, Button, x390 y230 w80 h25 gRemoveFromCCPriority, Remove
    Gui, Add, Button, x390 y260 w80 h25 gAddToCCPriority, Add

    ; Status Section
    Gui, Add, GroupBox, x20 y410 w470 h130, CC Status
    Gui, Add, Edit, x30 y430 w450 h100 vCCStatusEdit ReadOnly VScroll

    ; ===== BUFFS TAB =====
    Gui, Tab, Buffs

    ; Profile Management Section
    Gui, Add, GroupBox, x20 y40 w470 h90, Profile Management
    Gui, Add, Text, x30 y60 w80 h20, Active Profile:
    Gui, Add, DropDownList, x110 y60 w160 h120 vCurrentProfile gProfileChanged, % CurrentProfileName
    Gui, Add, Button, x270 y60 w60 h25 gSaveProfile, Save
    Gui, Add, Button, x340 y60 w60 h25 gLoadProfile, Load 
    Gui, Add, Button, x410 y60 w60 h25 gNewProfile, New
    Gui, Add, Text, x30 y85 w100 h20, Profile Name:
    Gui, Add, Edit, x110 y85 w220 h20 vProfileNameEdit
    Gui, Add, Button, x340 y85 w60 h25 gRenameProfile, Rename
    Gui, Add, Button, x410 y85 w60 h25 gDeleteProfile, Delete

    ; Settings Section
    Gui, Add, GroupBox, x20 y140 w470 h60, Settings
    Gui, Add, Checkbox, x30 y160 w160 vSkipInitial1, Skip initial execution
    Gui, Add, Button, x200 y155 w80 h25 gStopAll, Stop Timers
    Gui, Add, Button, x290 y155 w100 h25 gStartAllTimers, Start All Timers

    ; Sequence 1
    Gui, Add, GroupBox, x20 y210 w470 h80, Sequence 1 (Blue)
    Gui, Add, Text, x30 y230 w80, Keys:
    Gui, Add, Edit, x110 y230 w180 h20 vKeyCombinationEdit1, %KeyCombination1%
    Gui, Add, Text, x30 y255 w50, Delay (sec):
    Gui, Add, Edit, x80 y255 w50 h20 vKeyDelayEdit1, %KeyDelay1%
    Gui, Add, Text, x140 y255 w50, Timer (min):
    Gui, Add, Edit, x190 y255 w50 h20 vTimerIntervalEdit1, %TimerInterval1%
    Gui, Add, Button, x290 y230 w50 h30 gStartStop1, Start
    Gui, Add, Button, x350 y230 w50 h30 gStop1, Stop
    Gui, Add, Text, x410 y230 w70 vCountdownText1, Next: --
    Gui, Add, Text, x410 y255 w70 vStatusText1, Ready

    ; Sequence 2
    Gui, Add, GroupBox, x20 y300 w470 h80, Sequence 2 (Red)
    Gui, Add, Text, x30 y320 w80, Keys:
    Gui, Add, Edit, x110 y320 w180 h20 vKeyCombinationEdit2, %KeyCombination2%
    Gui, Add, Text, x30 y345 w50, Delay (sec):
    Gui, Add, Edit, x80 y345 w50 h20 vKeyDelayEdit2, %KeyDelay2%
    Gui, Add, Text, x140 y345 w50, Timer (min):
    Gui, Add, Edit, x190 y345 w50 h20 vTimerIntervalEdit2, %TimerInterval2%
    Gui, Add, Button, x290 y320 w50 h30 gStartStop2, Start
    Gui, Add, Button, x350 y320 w50 h30 gStop2, Stop
    Gui, Add, Text, x410 y320 w70 vCountdownText2, Next: --
    Gui, Add, Text, x410 y345 w70 vStatusText2, Ready

    ; Sequence 3
    Gui, Add, GroupBox, x20 y390 w470 h80, Sequence 3 (Green)
    Gui, Add, Text, x30 y410 w80, Keys:
    Gui, Add, Edit, x110 y410 w180 h20 vKeyCombinationEdit3, %KeyCombination3%
    Gui, Add, Text, x30 y435 w50, Delay (sec):
    Gui, Add, Edit, x80 y435 w50 h20 vKeyDelayEdit3, %KeyDelay3%
    Gui, Add, Text, x140 y435 w50, Timer (min):
    Gui, Add, Edit, x190 y435 w50 h20 vTimerIntervalEdit3, %TimerInterval3%
    Gui, Add, Button, x290 y410 w50 h30 gStartStop3, Start
    Gui, Add, Button, x350 y410 w50 h30 gStop3, Stop
    Gui, Add, Text, x410 y410 w70 vCountdownText3, Next: --
    Gui, Add, Text, x410 y435 w70 vStatusText3, Ready

    ; Help Section
    Gui, Add, GroupBox, x20 y480 w470 h60, Help
    Gui, Add, Text, x30 y500 w450 h30, Example: !1|+2|^c means Alt+1, then Shift+2, then Ctrl+C`nModifiers: ! = Alt, + = Shift, ^ = Ctrl

    ; Pet Buff Section
    Gui, Add, GroupBox, x20 y550 w230 h100, Pet Buff

    ; Calculate initial timer display values
    gnollMins := Round(gnollBuffInterval / 60000)
    dtMins := Round(dtBuffInterval / 60000)

    Gui, Add, Checkbox, x30 y570 w200 vgnollbuff ggnollbuff, Enable Gnoll Buff (%gnollMins% mins)
    Gui, Add, Checkbox, x30 y590 w200 vdtbuff gdtbuff, Enable Death Tyrant Buff (%dtMins% mins)
    Gui, Add, Button, x30 y606 w130 h30 gPetBuffSettings, Pet Buff Pattern Settings
    Gui, Add, GroupBox, x250 y550 w240 h100, Additional-Settings
    Gui, Add, Button, x270 y570 w200 h30 gShowAdditionalBuffSequences, Additional Buff Sequences
    ;Gui, Add, Button, x270 y610 w200 h30 gImageClickerSettings, Image Clicker

    ; ===== Tools Tab ======
    Gui, Tab, Tools

    ; Quick Tools Section
    Gui, Add, GroupBox, x20 y40 w470 h120, Quick Tools
    Gui, Add, Button, x30 y60 w110 h30 gskillboxesnpc, MasterBoxes NPC
    Gui, Add, Button, x150 y60 w110 h30 genchanter, Gear Enchanter
    Gui, Add, Button, x270 y60 w110 h30 gBuffheal2nd, Buff&Heal 2nd
    Gui, Add, Button, x390 y60 w80 h30 galtassist, Alt Assist

    ; File Editor Section
    Gui, Add, GroupBox, x20 y170 w470 h100, File Editor
    Gui, Add, Button, x30 y190 w100 h25 gSelectFile, Select File
    Gui, Add, Text, x140 y190 w320 h20 vSelectedFilePath, No file selected
    Gui, Add, Text, x30 y220 w60 h20, RADIUS:
    Gui, Add, Edit, x90 y220 w100 h20 vRadiusValue
    Gui, Add, Button, x200 y220 w60 h25 gSaveRadius, Save

    ; Coordinate Settings Section
    Gui, Add, GroupBox, x20 y280 w470 h120, Coordinate Settings
    Gui, Add, Button, x30 y300 w140 h30 gSetSkillbarArea, Set Skillbar Area
    Gui, Add, Button, x180 y300 w180 h30 gSetCheckSnapshotCoords, Set CheckWeight/Snapshot Area
    Gui, Add, Text, x30 y340 w450 h25 vToolsSkillbarCoords, Skillbar: Not set
    Gui, Add, Text, x30 y360 w450 h25 vCheckSnapshotCoordsText, CheckWeight/Snapshot: Not set

    Gui, Add, GroupBox, x20 y420 w470 h120, Memory Monitor
    Gui, Add, Text, x30 y440 w440 h20, Click buttons 1-8 then left-click to select windows to monitor:
    Gui, Add, Button, x30 y460 w25 h25 gMonitorButton, 1
    Gui, Add, Button, x60 y460 w25 h25 gMonitorButton, 2
    Gui, Add, Button, x90 y460 w25 h25 gMonitorButton, 3
    Gui, Add, Button, x120 y460 w25 h25 gMonitorButton, 4
    Gui, Add, Button, x150 y460 w25 h25 gMonitorButton, 5
    Gui, Add, Button, x180 y460 w25 h25 gMonitorButton, 6
    Gui, Add, Button, x210 y460 w25 h25 gMonitorButton, 7
    Gui, Add, Button, x240 y460 w25 h25 gMonitorButton, 8
    Gui, Add, Button, x30 y490 w100 h25 gclosemonitors, Close Monitors
    Gui, Add, Button, x140 y490 w80 h25 gexpmonitor, Exp Monitor
    Gui, Add, Button, x230 y490 w90 h25 gRupeemonitor, Rupee Monitor

    ; ===== Navigation Tab =====

    Gui, Tab, Navigation

    ; Window & Coordinate Controls
    Gui, Add, GroupBox, x20 y40 w470 h80, Window & Coordinates
    Gui, Add, Button, x30 y60 w110 h25 gSelectcam, Select Camera
    Gui, Add, Button, x150 y60 w110 h25 gActivateCoordinates, Get Coords
    Gui, Add, Button, x270 y60 w110 h25 gShowSearchArea, Show Area
    Gui, Add, Text, x30 y90 w450 h20 vNavCurrentCoords, Current: X: --- Y: ---
    Gui, Add, Button, x390 y60 w70 h25 gBD5Cam, BD5 Cam
    ; Route Management
    Gui, Add, GroupBox, x20 y130 w470 h80, Route Management
    Gui, Add, Button, x30 y150 w80 h25 gSelectRoute, Select Route
    Gui, Add, Button, x120 y150 w80 h25 gNewPath, New Path
    Gui, Add, Button, x210 y150 w80 h25 gWaypointCmds vCommandsButton, Commands
    Gui, Add, Text, x30 y180 w450 h20 vNavRouteStatus, No route selected
    Gui, Add, Button, x300 y150 w80 h25 gCapturePattern, Capture Pattern 
    ; Travel Controls
    Gui, Add, GroupBox, x20 y220 w470 h80, Travel Controls
    Gui, Add, Button, x30 y240 w170 h25 gStartTravel vStartBtn, Start Travel
    Gui, Add, Button, x210 y240 w170 h25 gStopTravel vStopBtn Disabled, Stop Travel
    Gui, Add, Checkbox, x30 y270 w100 h20 vNavCameraLockCheck gToggleCameraLock Checked, Camera Lock

    ; Movement Settings
    Gui, Add, GroupBox, x20 y310 w470 h80, Movement Settings
    Gui, Add, Radio, x30 y330 w120 h20 vClickMode gSetMovementMode Checked, Click-to-Move
    ;Gui, Add, Radio, x160 y330 w120 h20 vWASDMode gSetMovementMode, WASD Keys
    Gui, Add, Text, x140 y330 w100 h15, Max Click Distance:
    Gui, Add, Edit, x245 y330 w50 h20 vMaxClickEdit, %MaxClickDistance%
    Gui, Add, Button, x300 y330 w50 h20 gSaveClickDistance, Save
    Gui, Add, Text, x30 y360 w80 h15, Tolerance X:
    Gui, Add, Edit, x110 y360 w50 h20 vToleranceX, %DistanceToleranceX%
    Gui, Add, Text, x170 y360 w20 h15, Y:
    Gui, Add, Edit, x190 y360 w50 h20 vToleranceY, %DistanceToleranceY%
    Gui, Add, Button, x250 y360 w60 h20 gSaveTolerance, Save

    ; Waypoint Navigation
    Gui, Add, GroupBox, x20 y400 w470 h120, Waypoint Navigation
    Gui, Add, Button, x30 y420 w80 h25 gPrevWaypoint vPrevWaypointBtn Disabled, Prev
    Gui, Add, Button, x120 y420 w80 h25 gNextWaypoint vNextWaypointBtn Disabled, Next
    Gui, Add, Button, x210 y420 w80 h25 gAddWaypoint, Add Point
    Gui, Add, Button, x300 y420 w80 h25 gClearWaypoints, Clear All

    Gui, Add, Text, x30 y450 w50 h15, Go to:
    Gui, Add, Edit, x85 y450 w50 h20 vGotoWaypoint
    Gui, Add, Button, x140 y450 w80 h25 gGotoSpecificWaypoint vGotoBtn Disabled, Go
    Gui, Add, Text, x230 y450 w80 h15, Delete WP:
    Gui, Add, Edit, x315 y450 w50 h20 vDeleteWaypointID
    Gui, Add, Button, x370 y450 w80 h25 gDeleteWaypoint, Delete

    Gui, Add, Button, x30 y480 w150 h25 gMoveWaypointByNumber, Move Waypoint
    Gui, Add, Checkbox, x190 y480 w120 h15 vShowWaypointsCheck gToggleWaypoints Checked, Show Waypoints
    Gui, Add, Text, x320 y480 w150 h15 vWaypointStatus, Waypoints: 0 placed

    ; Function Blocking
    ; Gui, Add, Button, x20 y510 w150 h30 gOpenFunctionBlockingGUI, Function Blocking Settings

    ; Target Nodes
    Gui, Add, GroupBox, x20 y520 w470 h120, Target Nodes

    Gui, Add, Button, x210 y540 w80 h25 gAddTargetNode, Add Node
    Gui, Add, Button, x300 y540 w80 h25 gClearAllNodes, Clear All

    Gui, Add, Text, x230 y570 w80 h15, Delete Node:
    Gui, Add, Edit, x315 y570 w50 h20 vDeleteNodeID
    Gui, Add, Button, x370 y570 w80 h25 gDeleteNode, Delete

    Gui, Add, Button, x30 y600 w150 h25 gMoveNode, Move Node
    Gui, Add, Checkbox, x190 y600 w120 h15 vShowTargetNodesCheck gToggleTargetNodes Checked, Show Nodes
    Gui, Add, Text, x320 y600 w150 h15 vNodeStatus, Nodes: 0 placed

    ; Gui, Tab, Navigation

    ; ; Window & Coordinate Controls
    ; Gui, Add, GroupBox, x20 y40 w470 h80, Window & Coordinates
    ; Gui, Add, Button, x30 y60 w110 h25 gNavSelectWindow, Select Window
    ; Gui, Add, Button, x150 y60 w110 h25 gActivateCoordinates, Activate Coords
    ; Gui, Add, Button, x270 y60 w110 h25 gShowSearchArea, Show Area
    ; Gui, Add, Text, x30 y90 w450 h20 vNavCurrentCoords, Current: X: --- Y: ---

    ; ; Route Management
    ; Gui, Add, GroupBox, x20 y130 w470 h80, Route Management
    ; Gui, Add, Button, x30 y150 w80 h25 gSelectRoute, Select Route
    ; Gui, Add, Button, x120 y150 w80 h25 gNewPath, New Path
    ; Gui, Add, Button, x210 y150 w80 h25 gAddWaypoint, Add Waypoint
    ; Gui, Add, Button, x300 y150 w80 h25 gClearWaypoints, Clear Points
    ; Gui, Add, Text, x30 y180 w450 h20 vNavRouteStatus, No route selected

    ; ; Travel Controls
    ; Gui, Add, GroupBox, x20 y220 w470 h80, Travel Controls
    ; Gui, Add, Button, x30 y240 w170 h25 gStartTravel, Start Travel
    ; Gui, Add, Button, x210 y240 w170 h25 gStopTravel, Stop Travel
    ; Gui, Add, Checkbox, x30 y270 w100 h20 vNavCameraLockCheck gToggleCameraLock Checked, Camera Lock

    ; ; Camera Settings
    ; Gui, Add, GroupBox, x20 y310 w470 h80, Camera Settings
    ; Gui, Add, Text, x30 y330 w50 h20, Radius:
    ; Gui, Add, Edit, x85 y330 w60 h20 vNavRadiusEdit
    ; Gui, Add, Button, x155 y330 w50 h20 gSaveNavRadius, Save
    ; Gui, Add, Text, x30 y360 w450 h20 vNavCameraFile, No camera file loaded

    ; ===== TEMPLAR TAB =====
    Gui, Tab, Templar

    ; Configuration Section
    Gui, Add, GroupBox, x20 y40 w470 h90, Configuration
    Gui, Add, Text, x30 y60 w80 h20, Pull Areas:
    Gui, Add, Edit, x120 y60 w50 h20 vPullAreasEdit gUpdatePullAreas, %pullAreas%
    Gui, Add, Text, x180 y60 w80 h20, Click Locations:
    Gui, Add, Edit, x270 y60 w50 h20 vClickLocationsEdit gUpdateClickLocations, %clickLocations%

    Gui, Add, Text, x30 y85 w85 h20, Random Offset X:
    Gui, Add, Edit, x120 y85 w50 h20 vOffsetXEdit gUpdateOffsetX, %randomOffsetX%
    Gui, Add, Text, x180 y85 w85 h20, Random Offset Y:
    Gui, Add, Edit, x270 y85 w50 h20 vOffsetYEdit gUpdateOffsetY, %randomOffsetY%

    Gui, Add, Button, x330 y60 w120 h25 gSetMovementArea, Set Movement Area
    Gui, Add, Text, x330 y85 w140 h15 vMovementStatus, Area: Not Set

    ; Window Selection
    Gui, Add, GroupBox, x20 y140 w470 h50, Anti-town spam monitor
    ;Gui, Add, Button, x30 y160 w120 h25 gSelectTemplarWindow, Select Game Window
    ;windowText := selectedWindow != "" ? "Window: Selected" : "Window: None"
    ;Gui, Add, Text, x160 y165 w140 h15 vTemplarWindowStatus, %windowText%
    Gui, Add, Button, x30 y160 w80 h25 gStartWindowMonitor, Start Monitor
    Gui, Add, Button, x110 y160 w80 h25 gStopWindowMonitor, Stop Monitor

    ; Setup Actions
    Gui, Add, GroupBox, x20 y200 w470 h50, Setup Actions
    Gui, Add, Button, x30 y220 w120 h25 gSetClickLocations, Set Click Locations
    Gui, Add, Button, x160 y220 w120 h25 gReturnToCharacter, Return to Character
    gui, add, text, x300 y225 w180 h15 , Holyground hotkey:
    Gui, Add, Hotkey, x400 y220 w50 h20 vHotkeyEdit gHotkeyChanged, %pullHotkey%
    ; Timing Settings
    Gui, Add, GroupBox, x20 y260 w470 h120, Timing Settings
    Gui, Add, Text, x30 y280 w120 h20, Mouse Move Delay (ms):
    Gui, Add, Edit, x160 y280 w50 h20 vMouseMoveDelayEdit gUpdateMouseMoveDelay, %mouseMoveDelay%

    Gui, Add, Text, x30 y305 w120 h20, Mouse Click Delay (ms):
    Gui, Add, Edit, x160 y305 w50 h20 vMouseClickDelayEdit gUpdateMouseClickDelay, %mouseClickDelay%

    Gui, Add, Text, x30 y330 w120 h20, Sleep After Area (ms):
    Gui, Add, Edit, x160 y330 w50 h20 vSleepTimeEdit gUpdateSleepTime, %returnSleepTime%

    Gui, Add, Text, x240 y280 w120 h20, Random Delay Min (ms):
    Gui, Add, Edit, x370 y280 w50 h20 vrandomdelaymin, %randomdelaymin%
    Gui, Add, Text, x240 y305 w120 h20, Random Delay Max (ms):
    Gui, Add, Edit, x370 y305 w50 h20 vrandomdelaymax, %randomdelaymax%

    Gui, Add, Checkbox, x30 y355 w150 h20 gautofollow, Enable Autofollow
    Gui, Add, Checkbox, x200 y355 w200 h20 gamimovingg, Enable Movement Detection
    gui, add, checkbox, x30 y385 w150 h20 gtemplardpsing, Enable templar dps

    ; ; DPS Configuration
    ; Gui, Add, GroupBox, x20 y390 w470 h120, DPS Configuration

    ; ; DPS Enable Checkbox
    ; Gui, Add, Checkbox, x30 y410 w200 h20 vDpsEnabledCheckbox gUpdateDpsEnabled Checked%dpsEnabled%, Enable DPS after Return to Character

    ; ; DPS Hotkey Input
    ; Gui, Add, Text, x30 y435 w100 h20, DPS Hotkey:
    ; Gui, Add, Edit, x140 y435 w50 h20 vDpsHotkeyEdit gUpdateDpsHotkey, %dpsHotkey%
    ; Gui, Add, Text, x200 y435 w80 h20, (e.g., 2, f, space)

    ; ; DPS Duration Input
    ; Gui, Add, Text, x30 y460 w100 h20, Hold Duration (ms):
    ; Gui, Add, Edit, x140 y460 w50 h20 vDpsDurationEdit gUpdateDpsDuration, %dpsDuration%
    ; Gui, Add, Text, x200 y460 w80 h20, (e.g., 3000 = 3sec)

    ; ; DPS Test Button
    ; Gui, Add, Button, x300 y435 w100 h25 gTestDpsHotkey, Test DPS Hotkey

    ; ; DPS Status
    ; dpsStatusText := dpsEnabled ? "DPS: Enabled" : "DPS: Disabled"
    ; Gui, Add, Text, x300 y465 w150 h20 vDpsStatusText, %dpsStatusText%

    ; Control Section
    Gui, Add, GroupBox, x20 y520 w470 h50, Control
    Gui, Add, Button, x30 y540 w80 h25 gStartPulling, Start Templar
    Gui, Add, Button, x120 y540 w60 h25 gStopPulling, Stop
    Gui, Add, Button, x190 y540 w60 h25 gSaveCoords, Save
    ;Gui, Add, Button, x260 y540 w60 h25 gLoadCoords, Load
    ;Gui, Add, Button, x330 y540 w100 h25 gSaveDpsSettings, Save DPS Settings

    ; Status Section - moved to bottom to fit within GUI height
    statusText := "Status: Ready. Set movement area and click locations first."
    if (movementAreaSet) {
        GuiControl,, MovementStatus, Area: Set
        coordsCount := clickCoords.Length()
        if (coordsCount > 0) {
            statusText := "Status: Ready to start pulling!"
        }
    }
    Gui, Add, Text, x30 y580 w440 h20 vTemplarStatusText, %statusText%

    ; ===== GLOBAL CONTROLS =====
    Gui, Tab
    Gui, Add, Button, x30 y640 w60 h25 gMinimizeToTray, Minimize
    Gui, Add, Button, x150 y640 w60 h25 gSaveAllSettings, Save All
    Gui, Add, Button, x220 y640 w60 h25 gCloseApp, Close
    Gui, Add, Button, x290 y640 w60 h25 greload, Reload

    ; Populate profile dropdown from INI so renamed/new profiles appear
    RefreshProfileDropdown()
    LoadProfile()
    GuiControl,, AutoFollowHotkey, %autofollowhotkeydefault%

    ; Show GUI
    Gui, Show, x1394 y0 w540 h680, Rappelz Automation Nexus
    gui, +AlwaysOnTop
    ;SetTimer, CheckWindowActivity, 500

    ; Start timer signal checking immediately
    ;SetTimer, TimerSignalCheck, 100

    ; Ensure default patterns exist in CapturedText.ini
    EnsureDefaultPatterns()

    ; Load heal/DPS patterns from CapturedText.ini
    LoadPatternsFromINI()

    ; Update skillbar display
    UpdateSkillbarDisplay()

    ; Update GUI status if a route is already selected
    if (SelectedRouteFile && FileExist(SelectedRouteFile)) {
        SplitPath, SelectedRouteFile, fileName
        waypointCount := Waypoints.Length()
        nodeCount := TargetNodes.Length()
        GuiControl,, RouteStatus, Route: %fileName% (%waypointCount% waypoints)
        GuiControl,, NodeStatus, Nodes: %nodeCount% placed

        ; Enable navigation buttons if waypoints exist
        if (waypointCount > 0) {
            GuiControl, Enable, PrevWaypointBtn
            GuiControl, Enable, NextWaypointBtn
            GuiControl, Enable, GotoBtn
        }
    }
    ; Load and display existing heal skills after GUI is shown
    SetTimer, LoadHealSkillsDelayed, -100
    ; Load and display existing DPS skills after GUI is shown
    SetTimer, LoadDPSSkillsDelayed, -150
    setTimer, LoadCCSkillsDelayed, -200
    ; Load last selected file
    SetTimer, LoadLastFile, -250
    ; Load all checkbox states after GUI is created
    SetTimer, LoadCheckboxStatesDelayed, -50
    SetTimer, ChangeKeyDelay, 1000
    ; Initialize navigation variables
    ;InitializeNavigation()
return
templardpsing:
    if (templardps)
    {
        templardps := False
        return
    }
    else if (!templardps)
    {
        templardps := True
        return
    }
HotkeyChanged:
    Gui, Submit, NoHide
    pullHotkey := HotkeyEdit
    if (pullHotkey = "")
        pullHotkey := "1" ; Default to "1" if empty

    ; Save the hotkey to INI file
    IniWrite, %pullHotkey%, %INIFILE%, Hotkeys, PullHotkey
return

; ===== MINIMIZE/RESTORE GUI FUNCTIONS =====
MinimizeToTray:
    global SavedMiniX, SavedMiniY, SavedGuiX, SavedGuiY, MiniGuiID

    ; Save current main GUI position before hiding
    WinGetPos, SavedGuiX, SavedGuiY,,, Buff & Heal - Game Automation Tool

    ; Hide the main GUI
    Gui, Hide

    ; Create mini GUI - draggable window with button to restore
    Gui, Mini:New, +AlwaysOnTop +ToolWindow
    Gui, Mini:Color, 0x2E4C2E
    Gui, Mini:Font, s5 cWhite Bold
    Gui, Mini:Add, Button, x0 y0 w50 h50 gRestoreFromTray, SHOW

    ; Show mini GUI at last known position (or centered if first time)
    if (SavedMiniX != "" && SavedMiniY != "" && SavedMiniX != "ERROR") {
        Gui, Mini:Show, x%SavedMiniX% y%SavedMiniY% w50 h50, Mini Control
    } else {
        Gui, Mini:Show, w50 h50, Mini Control
    }

    ; Get the window ID immediately after showing
    MiniGuiID := WinExist("Mini Control")
return

RestoreFromTray:
    global SavedGuiX, SavedGuiY, SavedMiniX, SavedMiniY, MiniGuiID

    ; Get the mini GUI window ID if not set
    if (!MiniGuiID)
        MiniGuiID := WinExist("Mini Control")

    ; Save mini GUI position before destroying it
    WinGetPos, SavedMiniX, SavedMiniY,,, ahk_id %MiniGuiID%

    ; Destroy mini GUI first
    Gui, Mini:Destroy

    ; Restore main GUI at saved position (or default if not set)
    if (SavedGuiX != "" && SavedGuiY != "")
        Gui, 1:Show, x%SavedGuiX% y%SavedGuiY% w540 h680, Buff & Heal - Game Automation Tool
    else
        Gui, 1:Show, x1394 y0 w540 h680, Buff & Heal - Game Automation Tool
return

infinitemouse:
    Gui, Submit, NoHide
    if (infinitemouse) {
        Hotkey, ~RButton, RButtonDown, On
        Hotkey, ~RButton up, RButtonUp, On
    } else {
        Hotkey, ~RButton, Off
        Hotkey, ~RButton up, Off
    }
    msgbox, % (infinitemouse ? "Infinite Mouse Active `nRight-click and hold to keep mouse centered" : "Infinite Mouse Deactivated") 
return

RButtonDown:
    MouseGetPos, centerX, centerY
    SetTimer, InfiniteMouseMove, 5
return

RButtonUp:
    SetTimer, InfiniteMouseMove, Off
return
; ===== Pet Buff Timers =====
gnollbuff:
    ; Check if Critical mode is enabled
    if (CriticalModeEnabled) {
        return
    }
    if (win1 = "" || !WinExist("ahk_id " . win1)) {
        GuiControl,, gnollbuff, 0
        gnollbuff := false
        tooltip, Please select a window first.
        SetTimer, RemoveTooltip, -3000
        return
    }
    if (gnollbuff = false)
    {
        gnollbuff := true
        gnoll()
        SetTimer, gnoll, %gnollBuffInterval%
    }
    else if (gnollbuff = true)
    {
        gnollbuff := false
        SetTimer, gnoll, Off
    }
Return

; ===== Auto-Dura Functions =====
autodura:
    Gui, Submit, NoHide
    autoDuraEnabled := autodura ; Update autoDuraEnabled from checkbox state

    if (win1 = "" || !WinExist("ahk_id " . win1)) {
        GuiControl,, autodura, 0
        autoDuraEnabled := false
        MsgBox, Please select a window first.
        return
    }

    if (autoDuraEnabled) {
        ; Calculate interval in milliseconds
        autoDuraTimerInterval := autoDuraInterval * 60000
        SetTimer, AutoRepairDura, %autoDuraTimerInterval%
        MsgBox, Auto-Dura enabled - will repair every %autoDuraInterval% minutes.
    } else {
        SetTimer, AutoRepairDura, Off
        MsgBox, Auto-Dura disabled.
    }
return
selectcam:
    FileSelectFile, selectedCameraFile, 1,, Select Camera File, TXT Files (*.txt)
    if (selectedCameraFile != "") {
        NavCameraFile := selectedCameraFile
        LoadNavCameraSettings(NavCameraFile)
        ; Save to navpathingsettings.ini
        IniWrite, %NavTargetGamePID%, navpathingsettings.ini, Settings, WindowPID
        IniWrite, %NavCameraFile%, navpathingsettings.ini, Settings, CameraFile
        MsgBox, Camera file loaded: %NavCameraFile%
    }
return
SaveAutoDuraInterval:
    Gui, Submit, NoHide
    autoDuraInterval := autoDuraIntervalEdit
    ; if (autoDuraInterval < 1) {
    ;     autoDuraInterval := 1
    ;     GuiControl,, autoDuraIntervalEdit, 1
    ;     MsgBox, Minimum interval is 1 minute.
    ; }
    IniWrite, %autoDuraInterval%, %SettingsFile%, AutoDura, Interval
    MsgBox, Auto-Dura interval set to %autoDuraInterval% minutes and saved.

    ; Restart timer if it's currently running
    if (autoDuraEnabled) {
        autoDuraTimerInterval := autoDuraInterval * 60000
        SetTimer, AutoRepairDura, Off
        SetTimer, AutoRepairDura, %autoDuraTimerInterval%
    }
return

testduradetection:
    PerformDuraRepair()
return

AutoRepairDura:
    PerformDuraRepair()
return

ShowAdditionalBuffSequences:
    Gui, 2:New
    Gui, 2:Add, GroupBox, x10 y10 w480 h150, Sequence 4
    Gui, 2:Add, Text, x20 y35 w100 h20, Keys:
    Gui, 2:Add, Edit, x130 y35 w150 h20 vKeyCombinationEdit4, %KeyCombination4%
    Gui, 2:Add, Text, x20 y65 w100 h20, Key Delay (sec):
    Gui, 2:Add, Edit, x130 y65 w60 h20 vKeyDelayEdit4, %KeyDelay4%
    Gui, 2:Add, Text, x20 y95 w100 h20, Timer Interval (min):
    Gui, 2:Add, Edit, x130 y95 w60 h20 vTimerIntervalEdit4, %TimerInterval4%
    Gui, 2:Add, Button, x20 y125 w100 h25 gSaveSequence4, Save Sequence 4
    Gui, 2:Add, Button, x130 y125 w100 h25 gToggleSequence4, Toggle Sequence 4
    Gui, 2:Add, Text, x240 y125 w200 h25 vSequence4Status, Status: Stopped

    Gui, 2:Add, GroupBox, x10 y170 w480 h150, Sequence 5
    Gui, 2:Add, Text, x20 y195 w100 h20, Keys:
    Gui, 2:Add, Edit, x130 y195 w150 h20 vKeyCombinationEdit5, %KeyCombination5%
    Gui, 2:Add, Text, x20 y225 w100 h20, Key Delay (sec):
    Gui, 2:Add, Edit, x130 y225 w60 h20 vKeyDelayEdit5, %KeyDelay5%
    Gui, 2:Add, Text, x20 y255 w100 h20, Timer Interval (min):
    Gui, 2:Add, Edit, x130 y255 w60 h20 vTimerIntervalEdit5, %TimerInterval5%
    Gui, 2:Add, Button, x20 y285 w100 h25 gSaveSequence5, Save Sequence 5
    Gui, 2:Add, Button, x130 y285 w100 h25 gToggleSequence5, Toggle Sequence 5
    Gui, 2:Add, Text, x240 y285 w200 h25 vSequence5Status, Status: Stopped

    Gui, 2:Add, GroupBox, x10 y330 w480 h150, Sequence 6
    Gui, 2:Add, Text, x20 y355 w100 h20, Keys:
    Gui, 2:Add, Edit, x130 y355 w150 h20 vKeyCombinationEdit6, %KeyCombination6%
    Gui, 2:Add, Text, x20 y385 w100 h20, Key Delay (sec):
    Gui, 2:Add, Edit, x130 y385 w60 h20 vKeyDelayEdit6, %KeyDelay6%
    Gui, 2:Add, Text, x20 y415 w100 h20, Timer Interval (min):
    Gui, 2:Add, Edit, x130 y415 w60 h20 vTimerIntervalEdit6, %TimerInterval6%
    Gui, 2:Add, Button, x20 y445 w100 h25 gSaveSequence6, Save Sequence 6
    Gui, 2:Add, Button, x130 y445 w100 h25 gToggleSequence6, Toggle Sequence 6
    Gui, 2:Add, Text, x240 y445 w200 h25 vSequence6Status, Status: Stopped

    Gui, 2:Show, w500 h490, Additional Buff Sequences
return
SaveSequence4:
    Gui, 2:Submit, NoHide
    KeyCombination4 := KeyCombinationEdit4
    KeyDelay4 := KeyDelayEdit4
    TimerInterval4 := TimerIntervalEdit4
    KeySequence4 := StrSplit(KeyCombination4, "|")
    IniWrite, %KeyCombination4%, %SettingsFile%, Sequence4, KeyCombination
    IniWrite, %KeyDelay4%, %SettingsFile%, Sequence4, KeyDelay
    IniWrite, %TimerInterval4%, %SettingsFile%, Sequence4, TimerInterval
    MsgBox, Sequence 4 saved!
return

SaveSequence5:
    Gui, 2:Submit, NoHide
    KeyCombination5 := KeyCombinationEdit5
    KeyDelay5 := KeyDelayEdit5
    TimerInterval5 := TimerIntervalEdit5
    KeySequence5 := StrSplit(KeyCombination5, "|")
    IniWrite, %KeyCombination5%, %SettingsFile%, Sequence5, KeyCombination
    IniWrite, %KeyDelay5%, %SettingsFile%, Sequence5, KeyDelay
    IniWrite, %TimerInterval5%, %SettingsFile%, Sequence5, TimerInterval
    MsgBox, Sequence 5 saved!
return

SaveSequence6:
    Gui, 2:Submit, NoHide
    KeyCombination6 := KeyCombinationEdit6
    KeyDelay6 := KeyDelayEdit6
    TimerInterval6 := TimerIntervalEdit6
    KeySequence6 := StrSplit(KeyCombination6, "|")
    IniWrite, %KeyCombination6%, %SettingsFile%, Sequence6, KeyCombination
    IniWrite, %KeyDelay6%, %SettingsFile%, Sequence6, KeyDelay
    IniWrite, %TimerInterval6%, %SettingsFile%, Sequence6, TimerInterval
    MsgBox, Sequence 6 saved!
return

ToggleSequence4:
    IsRunning4 := !IsRunning4
    if (IsRunning4) {
        KeySequence4 := StrSplit(KeyCombination4, "|")
        SetTimer, CheckExecutions456, 50
        NextExecutionTime4 := A_TickCount
        Gosub, SendKeys4
        NextExecutionTime4 := A_TickCount + (TimerInterval4 * 60 * 1000)
        GuiControl, 2:, Sequence4Status, Status: Running
    } else {
        SetTimer, CheckExecutions456, Off
        GuiControl, 2:, Sequence4Status, Status: Stopped
    }
return

ToggleSequence5:
    IsRunning5 := !IsRunning5
    if (IsRunning5) {
        KeySequence5 := StrSplit(KeyCombination5, "|")
        SetTimer, CheckExecutions456, 50
        NextExecutionTime5 := A_TickCount
        Gosub, SendKeys5
        NextExecutionTime5 := A_TickCount + (TimerInterval5 * 60 * 1000)
        GuiControl, 2:, Sequence5Status, Status: Running
    } else {
        SetTimer, CheckExecutions456, Off
        GuiControl, 2:, Sequence5Status, Status: Stopped
    }
return

ToggleSequence6:
    IsRunning6 := !IsRunning6
    if (IsRunning6) {
        KeySequence6 := StrSplit(KeyCombination6, "|")
        SetTimer, CheckExecutions456, 50
        NextExecutionTime6 := A_TickCount
        Gosub, SendKeys6
        NextExecutionTime6 := A_TickCount + (TimerInterval6 * 60 * 1000)
        GuiControl, 2:, Sequence6Status, Status: Running
    } else {
        SetTimer, CheckExecutions456, Off
        GuiControl, 2:, Sequence6Status, Status: Stopped
    }
return

CheckExecutions456:
    if (IsRunning4 && A_TickCount >= NextExecutionTime4) {
        Gosub, SendKeys4
        NextExecutionTime4 := A_TickCount + (TimerInterval4 * 60 * 1000)
    }
    if (IsRunning5 && A_TickCount >= NextExecutionTime5) {
        Gosub, SendKeys5
        NextExecutionTime5 := A_TickCount + (TimerInterval5 * 60 * 1000)
    }
    if (IsRunning6 && A_TickCount >= NextExecutionTime6) {
        Gosub, SendKeys6
        NextExecutionTime6 := A_TickCount + (TimerInterval6 * 60 * 1000)
    }
    if (!IsRunning4 && !IsRunning5 && !IsRunning6) {
        SetTimer, CheckExecutions456, Off
    }
return

SendKeys4:
    IfWinNotExist, ahk_id %win1%
        return
    IF (NavIsTraveling)
    {
        PauseNavigationForBuff()
    }
    Loop % KeySequence4.Length()
    {
        CurrentKey := Trim(KeySequence4[A_Index])
        if (CurrentKey != "") {
            ; Check for modifier keys
            hasCtrl := InStr(CurrentKey, "^")
            hasAlt := InStr(CurrentKey, "!")
            hasShift := InStr(CurrentKey, "+")

            ; Extract base key
            baseKey := CurrentKey
            if (hasCtrl)
                baseKey := StrReplace(baseKey, "^")
            if (hasAlt)
                baseKey := StrReplace(baseKey, "!")
            if (hasShift)
                baseKey := StrReplace(baseKey, "+")

            ; Send modifiers down
            if (hasCtrl)
                ControlSend,, {Ctrl down}, ahk_id %win1%
            if (hasAlt)
                ControlSend,, {Alt down}, ahk_id %win1%
            if (hasShift)
                ControlSend,, {Shift down}, ahk_id %win1%

            ; Send base key
            ControlSend,, {%baseKey% down}, ahk_id %win1%
            Sleep, % KeyDelay4 * 1000
            ControlSend,, {%baseKey% up}, ahk_id %win1%

            ; Release modifiers
            if (hasShift)
                ControlSend,, {Shift up}, ahk_id %win1%
            if (hasAlt)
                ControlSend,, {Alt up}, ahk_id %win1%
            if (hasCtrl)
                ControlSend,, {Ctrl up}, ahk_id %win1%

            Sleep, 100
        }
    }
    if (NavigationPausedForBuff) {
        ResumeNavigationAfterBuff()
    }
return

SendKeys5:
    IfWinNotExist, ahk_id %win1%
        return
    IF (NavIsTraveling)
    {
        PauseNavigationForBuff()
    }
    Loop % KeySequence5.Length()
    {
        CurrentKey := Trim(KeySequence5[A_Index])
        if (CurrentKey != "") {
            hasCtrl := InStr(CurrentKey, "^")
            hasAlt := InStr(CurrentKey, "!")
            hasShift := InStr(CurrentKey, "+")

            baseKey := CurrentKey
            if (hasCtrl)
                baseKey := StrReplace(baseKey, "^")
            if (hasAlt)
                baseKey := StrReplace(baseKey, "!")
            if (hasShift)
                baseKey := StrReplace(baseKey, "+")

            if (hasCtrl)
                ControlSend,, {Ctrl down}, ahk_id %win1%
            if (hasAlt)
                ControlSend,, {Alt down}, ahk_id %win1%
            if (hasShift)
                ControlSend,, {Shift down}, ahk_id %win1%

            ControlSend,, {%baseKey% down}, ahk_id %win1%
            Sleep, % KeyDelay5 * 1000
            ControlSend,, {%baseKey% up}, ahk_id %win1%

            if (hasShift)
                ControlSend,, {Shift up}, ahk_id %win1%
            if (hasAlt)
                ControlSend,, {Alt up}, ahk_id %win1%
            if (hasCtrl)
                ControlSend,, {Ctrl up}, ahk_id %win1%

            Sleep, 100
        }
    }
    if (NavigationPausedForBuff) {
        ResumeNavigationAfterBuff()
    }
return

SendKeys6:
    IfWinNotExist, ahk_id %win1%
        return
    IF (NavIsTraveling)
    {
        PauseNavigationForBuff()
    }
    Loop % KeySequence6.Length()
    {
        CurrentKey := Trim(KeySequence6[A_Index])
        if (CurrentKey != "") {
            hasCtrl := InStr(CurrentKey, "^")
            hasAlt := InStr(CurrentKey, "!")
            hasShift := InStr(CurrentKey, "+")

            baseKey := CurrentKey
            if (hasCtrl)
                baseKey := StrReplace(baseKey, "^")
            if (hasAlt)
                baseKey := StrReplace(baseKey, "!")
            if (hasShift)
                baseKey := StrReplace(baseKey, "+")

            if (hasCtrl)
                ControlSend,, {Ctrl down}, ahk_id %win1%
            if (hasAlt)
                ControlSend,, {Alt down}, ahk_id %win1%
            if (hasShift)
                ControlSend,, {Shift down}, ahk_id %win1%

            ControlSend,, {%baseKey% down}, ahk_id %win1%
            Sleep, % KeyDelay6 * 1000
            ControlSend,, {%baseKey% up}, ahk_id %win1%

            if (hasShift)
                ControlSend,, {Shift up}, ahk_id %win1%
            if (hasAlt)
                ControlSend,, {Alt up}, ahk_id %win1%
            if (hasCtrl)
                ControlSend,, {Ctrl up}, ahk_id %win1%

            Sleep, 100
        }
    }
    if (NavigationPausedForBuff) {
        ResumeNavigationAfterBuff()
    }
return

2GuiClose:
    Gui, 2:Destroy
return

PerformDuraRepair(force := false) {
    global win1, repairPattern

    if (CriticalModeEnabled) {
        return false
    }

    if ((NavIsTraveling || IsTraveling) && !force) {
        duraRepairNeeded := true
        return
    }

    IF (NavIsTraveling)
    {
        PauseNavigationForBuff()
    }
    WinGetPos, winX, winY,,, ahk_id %win1%
    inventorytext := "|<>E8E9E9-0.90$29.0001000022FC/C+WWN8Yd4WF9Ht4WGY294W8YG94C8aA"

    ; Press U up to 6 times to open inventory and find repair button
    Loop, 6 {
        ControlSend, , {u down}, ahk_id %win1%
        Sleep, 50
        ControlSend, , {u up}, ahk_id %win1%
        Sleep, 150

        if (FindText(foundX, foundY, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, repairPattern)) {
            SendMessageClick(foundX, foundY, win1)
            Sleep, 200

            ; Press U up to 6 times to close inventory
            Loop, 6 {
                if (!FindText(foundX, foundY, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, repairPattern)) {
                    ; Verify inventory is closed
                    Loop, 3 {
                        if (!FindText(invX, invY, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, inventorytext)) {
                            break, 2

                        }
                        ControlSend, , {u down}, ahk_id %win1%
                        Sleep, 50
                        ControlSend, , {u up}, ahk_id %win1%
                        Sleep, 150
                    }

                    return
                }

                ControlSend, , {u down}, ahk_id %win1%
                Sleep, 50
                ControlSend, , {u up}, ahk_id %win1%
                Sleep, 150
            }

            if (NavigationPausedForBuff) {
                ResumeNavigationAfterBuff()
            }
            return
        }
    }

    ; Repair button not found - ensure inventory is closed
    Loop, 6 {
        if (!FindText(invX, invY, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, inventorytext)) {
            Break
        }
        ControlSend, , {u down}, ahk_id %win1%
        Sleep, 50
        ControlSend, , {u up}, ahk_id %win1%
        Sleep, 150
    }

    if (NavigationPausedForBuff) {
        ResumeNavigationAfterBuff()
    }
}

reload:
    Reload
return

; ===== FILE EDITOR FUNCTIONS =====
SelectFile:
    FileSelectFile, SelectedFile, 1, , Select file to edit, Text Files (*.txt)
    if (SelectedFile != "") {
        GuiControl,, SelectedFilePath, %SelectedFile%
        ; Save file path to INI
        IniWrite, %SelectedFile%, settings.ini, FileEditor, LastFile
        ; Load current RADIUS value
        LoadRadiusValue()
    }
return

LoadRadiusValue() {
    GuiControlGet, FilePath,, SelectedFilePath
    if (FilePath = "No file selected" || FilePath = "")
        return

    FileRead, FileContent, %FilePath%
    if (ErrorLevel) {
        GuiControl,, RadiusValue, Error reading file
        return
    }

    ; Extract RADIUS value using regex
    if (RegExMatch(FileContent, "RADIUS\|([0-9.]+)\|", Match)) {
        GuiControl,, RadiusValue, %Match1%
    } else {
        GuiControl,, RadiusValue, RADIUS not found
    }
}

SaveRadius:
    GuiControlGet, FilePath,, SelectedFilePath
    GuiControlGet, NewRadius,, RadiusValue

    if (FilePath = "No file selected" || FilePath = "") {
        MsgBox, Please select a file first.
        return
    }

    if (NewRadius = "") {
        MsgBox, Please enter a RADIUS value.
        return
    }

    FileRead, FileContent, %FilePath%
    if (ErrorLevel) {
        MsgBox, Error reading file: %FilePath%
        return
    }

    ; Replace RADIUS value
    NewContent := RegExReplace(FileContent, "RADIUS\|[0-9.]+\|", "RADIUS|" . NewRadius . "|")

    FileDelete, %FilePath%
    FileAppend, %NewContent%, %FilePath%

    if (ErrorLevel) {
        MsgBox, Error saving file.
    } else {
        MsgBox, RADIUS value saved successfully!
    }
return

LoadLastFile:
    IniRead, LastFile, settings.ini, FileEditor, LastFile, %A_Space%
    if (LastFile != "" && FileExist(LastFile)) {
        GuiControl,, SelectedFilePath, %LastFile%
        LoadRadiusValue()
    }
return
dtbuff:
    ; Check if Critical mode is enabled
    if (CriticalModeEnabled) {
        return
    }
    ; Do nothing if no target window selected or window doesn't exist
    if (win1 = "" || !WinExist("ahk_id " . win1)) {
        GuiControl,, dtbuff, 0
        dtbuff := false
        tooltip, Please select a window first.
        SetTimer, RemoveTooltip, -3000
        return
    }

    if (dtbuff = false)
    {
        dtbuff := true
        deathtyrant()
        SetTimer, deathtyrant, %dtBuffInterval%
    }
    else if (dtbuff = true)
    {
        dtbuff := false
        SetTimer, deathtyrant, Off
    }
Return

SendText:
    ; Get text from input box
    GuiControlGet, inputText, , TextInputBox
    WinActivate, ahk_id %win1%
    ; Check if text is empty
    if (inputText = "") {
        return
    }

    ; Check if win1 is selected
    if (win1 = "" || !WinExist("ahk_id " . win1)) {
        ToolTip, Please select a window first.
        SetTimer, RemoveTooltip, -3000
        return
    }

    ; Activate window and wait until active

    ;WinWaitActive, ahk_id %win1%
    sleep, 90
    ; Copy text to clipboard
    Clipboard := inputText

    ; Send Ctrl+Enter to win1
    Send, {Enter}
    Sleep, 90

    ; Paste text
    Send, ^v
    Sleep, 90

    ; Send Ctrl+Enter again
    Send, {Enter}

return

ClearText:
    GuiControl, , TextInputBox,
return

gnoll(force := false) {
    ; Check if Critical mode is enabled
    if (CriticalModeEnabled) {
        return false
    }

    ; If navigation is running, set flag instead of executing, unless forced
    if ((NavIsTraveling || IsTraveling) && !force) {
        gnollBuffNeeded := true
        return false
    }
    IF (NavIsTraveling)
    {
        PauseNavigationForBuff()
    }
    ; Pause navigation while executing pet buff

    global gnollPatterns, gnollBuffImagePattern, customSummonPattern, summonKeybind

    ; Default patterns (fallback if custom not set)
    defaultReflectingShieldPattern := "|<>##0.90$0/0/F2D561,-14/17/C5E9FF,7/16/43EFFF,-3/21/426EAD,-15/-2/FEE530,-2/-2/CAB348,3/-2/847329,0/-2/D4C447"
    defaultSummonPattern := "|<>*156$30.zzzzzzy1zzjs0Tzzc01zy000Tw000DE0001E001Cs000bk003DFU00W3U01kDU01s/000Q2U01kNUATyQsRSCQyxTyHazsy7nQzwTtxjyLOTLw3PAy00000DVPfyNkPAy1sE6GRw0bUBT060RU"

    ; Use custom patterns if available, otherwise use defaults
    reflectingShieldPattern := (gnollBuffImagePattern != "") ? gnollBuffImagePattern : defaultReflectingShieldPattern
    summonPattern := (customSummonPattern != "") ? customSummonPattern : defaultSummonPattern

    ; ensure target window exists
    IfWinNotExist, ahk_id %win1%
        return false

    WinGetPos, winX, winY, winW, winH, ahk_id %win1%

    ; pre-check if gnoll buff already exists (if so, skip)
    if (FindText(rx, ry, winX, winY, winX + winW, winY + winH, 0, 0, reflectingShieldPattern))
    {
        ; Click at 10,10 to ensure game window is ready before casting skill
        lParam := (10 << 16) | (10 & 0xFFFF)
        SendMessage, 0x201, 1, %lParam%,, ahk_id %win1% ; WM_LBUTTONDOWN
        Sleep, 50
        SendMessage, 0x202, 0, %lParam%,, ahk_id %win1% ; WM_LBUTTONUP
        Sleep, 100
       
        ; Inline replacement for SendMessageClick(rx, ry) to avoid calling another function
        winId := win1
        WinGetPos, winX, winY,,, ahk_id %winId%
        relativeX := rx - winX
        relativeY := ry - winY
        ; Adjust for typical window borders/title bar
        relativeX -= 8
        relativeY -= 31
        lParam := (relativeY << 16) | (relativeX & 0xFFFF)
        ; Send mouse down/up twice (matches SendMessageClick behavior)
        SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
        Sleep, 50
        SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
        Sleep, 50
        SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
        Sleep, 50
        SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
        Sleep, 200
        if (NavigationPausedForBuff) {
            ResumeNavigationAfterBuff()
        }
        return
    }

    ; 1) Find gnoll on screen with fallback recovery - try all patterns
    gx := ""
    gy := ""
    foundGnoll := false

    ; Try to find gnoll with any of the stored patterns
    for index, gnollPattern in gnollPatterns {
        if (FindText(gx, gy, winX, winY, winX + winW, winY + winH, 0, 0, gnollPattern)) {
            foundGnoll := true
            break
        }
    }

    if (!foundGnoll) {
        ; Gnoll not found - try pressing ESC 3 times
        Loop, 3 {
            ControlSend, , {Escape}, ahk_id %win1%
            Sleep, 100
        }
        Sleep, 300

        ; Check again for gnoll with all patterns
        WinGetPos, winX, winY, winW, winH, ahk_id %win1%
        foundGnoll := false
        for index, gnollPattern in gnollPatterns {
            if (FindText(gx, gy, winX, winY, winX + winW, winY + winH, 0, 0, gnollPattern)) {
                foundGnoll := true
                break
            }
        }

        if (!foundGnoll) {
            ; Still not found - try pressing R
            ControlSend, , r, ahk_id %win1%
            Sleep, 500

            ; Check again with all patterns
            WinGetPos, winX, winY, winW, winH, ahk_id %win1%
            foundGnoll := false
            for index, gnollPattern in gnollPatterns {
                if (FindText(gx, gy, winX, winY, winX + winW, winY + winH, 0, 0, gnollPattern)) {
                    foundGnoll := true
                    break
                }
            }

            if (!foundGnoll) {
                ; Still not found - try pressing R again
                ControlSend, , r, ahk_id %win1%
                Sleep, 500

                ; Final check with all patterns
                WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                foundGnoll := false
                for index, gnollPattern in gnollPatterns {
                    if (FindText(gx, gy, winX, winY, winX + winW, winY + winH, 0, 0, gnollPattern)) {
                        foundGnoll := true
                        break
                    }
                }

                if (!foundGnoll) {
                    ; Abandon the process
                    tooltipX := winX + (winW / 2)
                    tooltipY := winY + (winH * 0.70)
                    ToolTip, Gnoll Buff Failed: Creature not found`nRetrying in 1 minute 5 seconds, %tooltipX%, %tooltipY%, 1
                    SetTimer, RemoveGnollFailTooltip, -5000
                    SetTimer, gnollRetry, -65000
                    return false
                }
            }
        }
    }

    ; 2) ControlClick the gnoll inside the game window
    WinGetPos, winX, winY,,, ahk_id %win1%
    relX := gx - winX
    relY := gy - winY
    ControlClick, x%relX% y%relY%, ahk_id %win1%,, Left, 1, NA
    Sleep, 150
    ControlClick, x%relX% y%relY%, ahk_id %win1%,, Left, 1, NA
    ; 3) Check if summon skill appears - if not, try recovery steps
    Sleep, 500
    WinGetPos, winX, winY, winW, winH, ahk_id %win1%
    if (!FindText(sx, sy, winX, winY, winX + winW, winY + winH, 0, 0, summonPattern)) {
        ; Summon not found - try pressing ESC 3 times
        Loop, 3 {
            ControlSend, , {Escape}, ahk_id %win1%
            Sleep, 100
        }
        Sleep, 300

        ; Check again for summon
        if (!FindText(sx, sy, winX, winY, winX + winW, winY + winH, 0, 0, summonPattern)) {
            ; Still not found - try pressing R
            ControlSend, , r, ahk_id %win1%
            Sleep, 500

            ; Final check
            if (!FindText(sx, sy, winX, winY, winX + winW, winY + winH, 0, 0, summonPattern)) {
                ; Abandon the process
                WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                tooltipX := winX + (winW / 2)
                tooltipY := winY + (winH * 0.70)
                ToolTip, Gnoll Buff Failed: Summon skill not found`nRetrying in 1 minute 5 seconds, %tooltipX%, %tooltipY%, 1
                SetTimer, RemoveGnollFailTooltip, -5000
                SetTimer, gnollRetry, -65000
                return false
            }
        }
    }

    ; 4) While "summon" icon/pattern exists, send custom summon keybind
    start := A_TickCount
    Loop {
        if (!FindText(sx, sy, winX, winY, winX + winW, winY + winH, 0, 0, summonPattern))
            break

        ; Send custom summon keybind with proper modifier handling
        SendKeybind(summonKeybind, "ahk_id " . win1)

        Sleep, 200

        ; safety timeout (15s)
        if (A_TickCount - start > 15000)
            break
    }

    Sleep, 1000

    ; Click at 10,10 to ensure game window is ready before casting skill
    lParam := (10 << 16) | (10 & 0xFFFF)
    SendMessage, 0x201, 1, %lParam%,, ahk_id %win1% ; WM_LBUTTONDOWN
    Sleep, 50
    SendMessage, 0x202, 0, %lParam%,, ahk_id %win1% ; WM_LBUTTONUP
    Sleep, 100

    ; 5) Click reflecting shield until it is no longer found (use SendMessageClick for reliability)
    ; 9 second timeout - if skill never disappears, retry in 30 seconds
    start := A_TickCount
    skillFound := false
    lastSkillSeen := A_TickCount
    Loop {
        ; First check if we can find the skill
        if (FindText(rx, ry, winX, winY, winX + winW, winY + winH, 0, 0, reflectingShieldPattern)) {
            skillFound := true
            lastSkillSeen := A_TickCount

            ; Check timeout - if skill has been visible for 9+ seconds, give up
            if (A_TickCount - start > 9000) {
                ; Skill never disappeared within 9 seconds - retry in 1 minute 5 seconds
                WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                tooltipX := winX + (winW / 2)
                tooltipY := winY + (winH * 0.70)
                ToolTip, Gnoll Buff Failed: Skill timed out (9s)`nRetrying in 1 minute 5 seconds, %tooltipX%, %tooltipY%, 1
                SetTimer, RemoveGnollFailTooltip, -5000
                SetTimer, gnollRetry, -65000
                return false
            }

            ; Inline replacement for SendMessageClick(rx, ry) to avoid calling another function
            winId := win1
            WinGetPos, winX, winY,,, ahk_id %winId%
            relativeX := rx - winX
            relativeY := ry - winY
            ; Adjust for typical window borders/title bar
            relativeX -= 8
            relativeY -= 31
            lParam := (relativeY << 16) | (relativeX & 0xFFFF)
            ; Send mouse down/up twice (matches SendMessageClick behavior)
            SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
            Sleep, 50
            SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
            Sleep, 50
            SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
            Sleep, 50
            SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
            Sleep, 200
        } else {
            ; Skill not found - if we saw it before, it disappeared (success)
            if (skillFound) {
                break
            }
            ; If we never saw the skill and more than 2 seconds passed, it's a failure
            if (A_TickCount - start > 2000) {
                WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                tooltipX := winX + (winW / 2)
                tooltipY := winY + (winH * 0.70)
                ToolTip, Gnoll Buff Failed: Skill never appeared`nRetrying in 1 minute 5 seconds, %tooltipX%, %tooltipY%, 1
                SetTimer, RemoveGnollFailTooltip, -5000
                SetTimer, gnollRetry, -65000
                ResumeNavigationAfterBuff()
                return false
            }
            ; Otherwise wait a bit and check again
            Sleep, 100
        }
    }

    ResumeNavigationAfterBuff()
return true
}

; Retry gnoll buff after failed attempt or blocked during navigation
gnollRetry:
    SetTimer, gnollRetry, Off
    gnoll()
return

DeathTyrant(force := false) {
    ; Check if Critical mode is enabled
    if (CriticalModeEnabled) {
        return false
    }

    ; If navigation is running, set flag instead of executing, unless forced
    if ((NavIsTraveling || IsTraveling) && !force) {
        dtBuffNeeded := true
        return false
    }

    IF (NavIsTraveling)
    {
        PauseNavigationForBuff()
    }

    global deathTyrantPatterns, dtBuffImagePattern, customSummonPattern, summonKeybind

    ; Default patterns (fallback if custom not set)
    defaultMonarchPattern := "|<>1F2024-0.74$20.zgMkPgPmwTwlDQ4Ta07V01sLsQDwT367Xk3szVwykTTU7zY3zy1zzkTzxzzzzzzzzzzzzyU"
    defaultMonarchPattern .= "|<>2E9AC1-0.77$21.y001zU00C000s3078s3vi0bMLYM46U00nU0TM2Dy0szED8A3d30E6k60y00NU06A01rU00y004"
    defaultSummonPattern := "|<>*156$30.zzzzzzy1zzjs0Tzzc01zy000Tw000DE0001E001Cs000bk003DFU00W3U01kDU01s/000Q2U01kNUATyQsRSCQyxTyHazsy7nQzwTtxjyLOTLw3PAy00000DVPfyNkPAy1sE6GRw0bUBT060RU"

    ; Use custom patterns if available, otherwise use defaults
    monarch := (dtBuffImagePattern != "") ? dtBuffImagePattern : defaultMonarchPattern
    summonPattern := (customSummonPattern != "") ? customSummonPattern : defaultSummonPattern

    ; Get window position first before any checks
    IfWinNotExist, ahk_id %win1%
    {
        ResumeNavigationAfterBuff()
        return false
    }
    WinGetPos, winX, winY, winW, winH, ahk_id %win1%

    ; pre-check if DT buff already exists (if so, skip)
    if (FindText(rx, ry, winX, winY, winX + winW, winY + winH, 0, 0, monarch))
    {
        ; Click at 10,10 to ensure game window is ready before casting skill
        lParam := (10 << 16) | (10 & 0xFFFF)
        SendMessage, 0x201, 1, %lParam%,, ahk_id %win1% ; WM_LBUTTONDOWN
        Sleep, 50
        SendMessage, 0x202, 0, %lParam%,, ahk_id %win1% ; WM_LBUTTONUP
        Sleep, 100

        ; Inline replacement for SendMessageClick(rx, ry) to avoid calling another function
        winId := win1
        WinGetPos, winX, winY,,, ahk_id %winId%
        relativeX := rx - winX
        relativeY := ry - winY
        ; Adjust for typical window borders/title bar
        relativeX -= 8
        relativeY -= 31
        lParam := (relativeY << 16) | (relativeX & 0xFFFF)
        ; Send mouse down/up twice (matches SendMessageClick behavior)
        SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
        Sleep, 50
        SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
        Sleep, 50
        SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
        Sleep, 50
        SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
        Sleep, 200 
        if (NavigationPausedForBuff) {
            ResumeNavigationAfterBuff()
        }
        return
    }

    ; 1) Find Death Tyrant on screen with fallback recovery - try all patterns
    gx := ""
    gy := ""
    foundDT := false

    ; Try to find Death Tyrant with any of the stored patterns
    for index, DeathTyrantPattern in deathTyrantPatterns {
        if (FindText(gx, gy, winX, winY, winX + winW, winY + winH, 0, 0, DeathTyrantPattern)) {
            foundDT := true
            break
        }
    }

    if (!foundDT) {
        ; Death Tyrant not found - try pressing ESC 3 times
        Loop, 3 {
            ControlSend, , {Escape}, ahk_id %win1%
            Sleep, 100
        }
        Sleep, 300

        ; Check again for Death Tyrant with all patterns
        WinGetPos, winX, winY, winW, winH, ahk_id %win1%
        foundDT := false
        for index, DeathTyrantPattern in deathTyrantPatterns {
            if (FindText(gx, gy, winX, winY, winX + winW, winY + winH, 0, 0, DeathTyrantPattern)) {
                foundDT := true
                break
            }
        }

        if (!foundDT) {
            ; Still not found - try pressing R
            ControlSend, , r, ahk_id %win1%
            Sleep, 500

            ; Check again with all patterns
            WinGetPos, winX, winY, winW, winH, ahk_id %win1%
            foundDT := false
            for index, DeathTyrantPattern in deathTyrantPatterns {
                if (FindText(gx, gy, winX, winY, winX + winW, winY + winH, 0, 0, DeathTyrantPattern)) {
                    foundDT := true
                    break
                }
            }

            if (!foundDT) {
                ; Still not found - try pressing R again
                ControlSend, , r, ahk_id %win1%
                Sleep, 500

                ; Final check with all patterns
                WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                foundDT := false
                for index, DeathTyrantPattern in deathTyrantPatterns {
                    if (FindText(gx, gy, winX, winY, winX + winW, winY + winH, 0, 0, DeathTyrantPattern)) {
                        foundDT := true
                        break
                    }
                }

                if (!foundDT) {
                    ; Abandon the process
                    tooltipX := winX + (winW / 2)
                    tooltipY := winY + (winH * 0.70)
                    ToolTip, Death Tyrant Buff Failed: Creature not found`nRetrying in 1 minute 5 seconds, %tooltipX%, %tooltipY%, 1
                    SetTimer, RemoveDTFailTooltip, -5000
                    SetTimer, deathTyrantRetry, -65000
                    ResumeNavigationAfterBuff()
                    return false
                }
            }
        }
    }

    ; 2) ControlClick the Death Tyrant inside the game window
    WinGetPos, winX, winY,,, ahk_id %win1%
    relX := gx - winX
    relY := gy - winY
    ControlClick, x%relX% y%relY%, ahk_id %win1%,, Left, 1, NA
    Sleep, 150
    ControlClick, x%relX% y%relY%, ahk_id %win1%,, Left, 1, NA
    ; 3) Check if summon skill appears - if not, try recovery steps
    Sleep, 500
    WinGetPos, winX, winY, winW, winH, ahk_id %win1%
    if (!FindText(sx, sy, winX, winY, winX + winW, winY + winH, 0, 0, summonPattern)) {
        ; Summon not found - try pressing ESC 3 times
        Loop, 3 {
            ControlSend, , {Escape}, ahk_id %win1%
            Sleep, 100
        }
        Sleep, 300

        ; Check again for summon
        if (!FindText(sx, sy, winX, winY, winX + winW, winY + winH, 0, 0, summonPattern)) {
            ; Still not found - try pressing R
            ControlSend, , r, ahk_id %win1%
            Sleep, 500

            ; Final check
            if (!FindText(sx, sy, winX, winY, winX + winW, winY + winH, 0, 0, summonPattern)) {
                ; Abandon the process
                WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                tooltipX := winX + (winW / 2)
                tooltipY := winY + (winH * 0.70)
                ToolTip, Death Tyrant Buff Failed: Summon skill not found`nRetrying in 1 minute 5 seconds, %tooltipX%, %tooltipY%, 1
                SetTimer, RemoveDTFailTooltip, -5000
                SetTimer, deathTyrantRetry, -65000
                ResumeNavigationAfterBuff()
                return false
            }
        }
    }

    ; 4) While "summon" icon/pattern exists, send custom summon keybind
    start := A_TickCount
    Loop {
        if (!FindText(sx, sy, winX, winY, winX + winW, winY + winH, 0, 0, summonPattern))
            break

        ; Send custom summon keybind (default: Shift+=)
        SendKeybind(summonKeybind, "ahk_id " . win1)

        Sleep, 200

        ; safety timeout (15s)
        if (A_TickCount - start > 15000)
            break
    }

    Sleep, 1000

    ; Click at 10,10 to ensure game window is ready before casting skill
    lParam := (10 << 16) | (10 & 0xFFFF)
    SendMessage, 0x201, 1, %lParam%,, ahk_id %win1% ; WM_LBUTTONDOWN
    Sleep, 50
    SendMessage, 0x202, 0, %lParam%,, ahk_id %win1% ; WM_LBUTTONUP
    Sleep, 100

    ; 5) Click monarch until it is no longer found (use SendMessageClick for reliability)
    ; 9 second timeout - if skill never disappears, retry in 30 seconds
    start := A_TickCount
    skillFound := false
    lastSkillSeen := A_TickCount
    Loop {
        ; First check if we can find the skill
        if (FindText(rx, ry, winX, winY, winX + winW, winY + winH, 0, 0, monarch)) {
            skillFound := true
            lastSkillSeen := A_TickCount

            ; Check timeout - if skill has been visible for 9+ seconds, give up
            if (A_TickCount - start > 9000) {
                ; Skill never disappeared within 9 seconds - retry in 1 minute 5 seconds
                WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                tooltipX := winX + (winW / 2)
                tooltipY := winY + (winH * 0.70)
                ToolTip, Death Tyrant Buff Failed: Skill timed out (9s)`nRetrying in 1 minute 5 seconds, %tooltipX%, %tooltipY%, 1
                SetTimer, RemoveDTFailTooltip, -5000
                SetTimer, deathTyrantRetry, -65000
                ResumeNavigationAfterBuff()
                return false
            }

            ; Inline replacement for SendMessageClick(rx, ry) to avoid calling another function
            winId := win1
            WinGetPos, winX, winY,,, ahk_id %winId%
            relativeX := rx - winX
            relativeY := ry - winY
            ; Adjust for typical window borders/title bar
            relativeX -= 8
            relativeY -= 31
            lParam := (relativeY << 16) | (relativeX & 0xFFFF)
            ; Send mouse down/up twice (matches SendMessageClick behavior)
            SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
            Sleep, 50
            SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
            Sleep, 50
            SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
            Sleep, 50
            SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
            Sleep, 200
        } else {
            ; Skill not found - if we saw it before, it disappeared (success)
            if (skillFound) {
                break
            }
            ; If we never saw the skill and more than 2 seconds passed, it's a failure
            if (A_TickCount - start > 2000) {
                WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                tooltipX := winX + (winW / 2)
                tooltipY := winY + (winH * 0.70)
                ToolTip, Death Tyrant Buff Failed: Skill never appeared`nRetrying in 1 minute 5 seconds, %tooltipX%, %tooltipY%, 1
                SetTimer, RemoveDTFailTooltip, -5000
                SetTimer, deathTyrantRetry, -65000
                ResumeNavigationAfterBuff()
                return false
            }
            ; Otherwise wait a bit and check again
            Sleep, 100
        }
    }

    ResumeNavigationAfterBuff()
return true
}

; Retry Death Tyrant buff after failed attempt or blocked during navigation
deathTyrantRetry:
    SetTimer, deathTyrantRetry, Off
    DeathTyrant()
return

; Pet Buff Pattern Settings GUI
PetBuffSettings:
    Gui, PetBuff:New
    Gui, PetBuff:+AlwaysOnTop
    Gui, PetBuff:Font, s10

    ; Calculate pattern counts and timer intervals in minutes
    gnollPatternCount := gnollPatterns.Length()
    dtPatternCount := deathTyrantPatterns.Length()
    gnollMinutes := Round(gnollBuffInterval / 60000)
    dtMinutes := Round(dtBuffInterval / 60000)

    ; Gnoll Pattern Section
    Gui, PetBuff:Add, GroupBox, x10 y10 w580 h280, Gnoll Patterns & Buff Detection
    Gui, PetBuff:Add, Text, x20 y35 w560 h20, Capture additional Gnoll or Event pet appearance patterns. Current patterns: %gnollPatternCount%
    Gui, PetBuff:Add, Button, x20 y60 w140 h30 gCaptureGnollPattern, Capture Gnoll Pattern
    Gui, PetBuff:Add, Button, x170 y60 w140 h30 gListGnollPatterns, View Gnoll Patterns
    Gui, PetBuff:Add, Button, x320 y60 w140 h30 gClearGnollPatterns, Reset Gnoll Patterns
    Gui, PetBuff:Add, Button, x470 y60 w100 h30 gTestGnollPatterns, Test Patterns

    ; Gnoll Buff Image Detection
    Gui, PetBuff:Add, Text, x20 y100 w560 h20, Reflecting Shield Buff Detection (detects if buff already exists)
    Gui, PetBuff:Add, Button, x20 y125 w140 h30 gCaptureGnollBuff, Capture Shield Image
    Gui, PetBuff:Add, Button, x170 y125 w140 h30 gTestGnollBuff, Test Shield Detection
    Gui, PetBuff:Add, Button, x320 y125 w140 h30 gRemoveGnollBuff, Remove Shield Image

    ; Summon Pattern and Keybind
    Gui, PetBuff:Add, Text, x20 y165 w560 h20, Summon Pattern & Keybind Settings
    Gui, PetBuff:Add, Button, x20 y190 w140 h30 gCaptureSummonPattern, Capture Summon Pattern
    Gui, PetBuff:Add, Button, x170 y190 w140 h30 gTestSummonPattern, Test Summon Pattern
    Gui, PetBuff:Add, Button, x320 y190 w140 h30 gRemoveSummonPattern, Remove Summon Pattern
    Gui, PetBuff:Add, Text, x20 y230 w80 h20, Summon Key:
    Gui, PetBuff:Add, Edit, x105 y230 w100 h20 vSummonKeybindEdit, %summonKeybind%
    Gui, PetBuff:Add, Button, x210 y228 w100 h24 gSaveSummonKeybind, Save Keybind

    ; Timer Setting
    Gui, PetBuff:Add, Text, x20 y260 w120 h20, Buff Timer (minutes):
    Gui, PetBuff:Add, Edit, x145 y260 w60 h20 vGnollTimerInput, %gnollMinutes%
    Gui, PetBuff:Add, Button, x210 y258 w100 h24 gSaveGnollTimer, Save Timer

    ; Death Tyrant Pattern Section
    Gui, PetBuff:Add, GroupBox, x10 y300 w580 h280, Death Tyrant Patterns & Buff Detection
    Gui, PetBuff:Add, Text, x20 y325 w560 h20, Capture additional Death Tyrant or Event pet patterns. Current patterns: %dtPatternCount%
    Gui, PetBuff:Add, Button, x20 y350 w140 h30 gCaptureDTPattern, Capture DT Pattern
    Gui, PetBuff:Add, Button, x170 y350 w140 h30 gListDTPatterns, View DT Patterns
    Gui, PetBuff:Add, Button, x320 y350 w140 h30 gClearDTPatterns, Reset DT Patterns
    Gui, PetBuff:Add, Button, x470 y350 w100 h30 gTestDTPatterns, Test Patterns

    ; DT Buff Image Detection
    Gui, PetBuff:Add, Text, x20 y390 w560 h20, Monarch Buff Detection (detects if buff already exists)
    Gui, PetBuff:Add, Button, x20 y415 w140 h30 gCaptureDTBuff, Capture Monarch Image
    Gui, PetBuff:Add, Button, x170 y415 w140 h30 gTestDTBuff, Test Monarch Detection
    Gui, PetBuff:Add, Button, x320 y415 w140 h30 gRemoveDTBuff, Remove Monarch Image

    ; Timer Setting
    Gui, PetBuff:Add, Text, x20 y455 w120 h20, Buff Timer (minutes):
    Gui, PetBuff:Add, Edit, x145 y455 w60 h20 vDTTimerInput, %dtMinutes%
    Gui, PetBuff:Add, Button, x210 y453 w100 h24 gSaveDTTimer, Save Timer

    ; Status Area
    Gui, PetBuff:Add, GroupBox, x10 y590 w580 h80, Status
    Gui, PetBuff:Add, Text, x20 y615 w560 h45 vPetBuffStatus, Ready to capture patterns and images...

    ; Close button
    Gui, PetBuff:Add, Button, x245 y680 w110 h30 gPetBuffSettingsClose, Close

    Gui, PetBuff:Show, w600 h725, Pet Buff Pattern Settings
return

PetBuffSettingsClose:
    Gui, PetBuff:Destroy
return

PetBuffGuiClose:
    Gui, PetBuff:Destroy
return

; Save Gnoll Timer
SaveGnollTimer:
    Gui, PetBuff:Submit, NoHide

    ; Validate input
    if (GnollTimerInput < 1 || GnollTimerInput > 999) {
        GuiControl, PetBuff:, PetBuffGnollStatus, Invalid timer! Please enter 1-999 minutes.
        return
    }

    ; Convert minutes to milliseconds and save
    gnollBuffInterval := GnollTimerInput * 60000
    SavePetBuffTimers()

    ; Update the timer if gnoll buff is already active
    if (gnollbuff = true) {
        SetTimer, gnoll, %gnollBuffInterval%
    }

    ; Update the main GUI checkbox label
    Gui, 1:Default
    GuiControl,, gnollbuff, Enable Gnoll Buff (%GnollTimerInput% mins)

    GuiControl, PetBuff:, PetBuffGnollStatus, Gnoll timer set to %GnollTimerInput% minutes.
return

; Save Death Tyrant Timer
SaveDTTimer:
    Gui, PetBuff:Submit, NoHide

    ; Validate input
    if (DTTimerInput < 1 || DTTimerInput > 999) {
        GuiControl, PetBuff:, PetBuffDTStatus, Invalid timer! Please enter 1-999 minutes.
        return
    }

    ; Convert minutes to milliseconds and save
    dtBuffInterval := DTTimerInput * 60000
    SavePetBuffTimers()

    ; Update the timer if DT buff is already active
    if (dtbuff = true) {
        SetTimer, DeathTyrant, %dtBuffInterval%
    }

    ; Update the main GUI checkbox label
    Gui, 1:Default
    GuiControl,, dtbuff, Enable Death Tyrant Buff (%DTTimerInput% mins)

    GuiControl, PetBuff:, PetBuffDTStatus, Death Tyrant timer set to %DTTimerInput% minutes.
return

; Capture new gnoll pattern
CaptureGnollPattern:
    GuiControl, PetBuff:, PetBuffGnollStatus, Hover over gnoll and press 1 to capture...
    KeyWait, 1, D
    capturedPattern := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)

    if (capturedPattern != "") {
        gnollPatterns.Push(capturedPattern)
        SavePetBuffPatterns()
        gnollPatternCount := gnollPatterns.Length()
        GuiControl, PetBuff:, PetBuffGnollStatus, Gnoll pattern captured! Total patterns: %gnollPatternCount%
        ; Update the count in the groupbox text
        Gui, PetBuff:Destroy
        Goto, PetBuffSettings
    } else {
        GuiControl, PetBuff:, PetBuffGnollStatus, Failed to capture pattern. Try again.
    }
return

; Capture new Death Tyrant pattern
CaptureDTPattern:
    GuiControl, PetBuff:, PetBuffDTStatus, Hover over Death Tyrant and press 1 to capture...
    KeyWait, 1, D
    capturedPattern := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)

    if (capturedPattern != "") {
        deathTyrantPatterns.Push(capturedPattern)
        SavePetBuffPatterns()
        dtPatternCount := deathTyrantPatterns.Length()
        GuiControl, PetBuff:, PetBuffDTStatus, Death Tyrant pattern captured! Total patterns: %dtPatternCount%
        ; Update the count in the groupbox text
        Gui, PetBuff:Destroy
        Goto, PetBuffSettings
    } else {
        GuiControl, PetBuff:, PetBuffDTStatus, Failed to capture pattern. Try again.
    }
return

; List all gnoll patterns
ListGnollPatterns:
    if (gnollPatterns.Length() = 0) {
        MsgBox, No gnoll patterns captured yet.
        return
    }

    patternList := "=== GNOLL PATTERNS ===`n`n"
    for index, pattern in gnollPatterns {
        ; Show first 60 characters of each pattern
        patternPreview := SubStr(pattern, 1, 60)
        if (StrLen(pattern) > 60)
            patternPreview .= "..."
        patternList .= index . ". " . patternPreview . "`n`n"
    }

    MsgBox, 0, Gnoll Patterns, %patternList%
return

; List all Death Tyrant patterns
ListDTPatterns:
    if (deathTyrantPatterns.Length() = 0) {
        MsgBox, No Death Tyrant patterns captured yet.
        return
    }

    patternList := "=== DEATH TYRANT PATTERNS ===`n`n"
    for index, pattern in deathTyrantPatterns {
        ; Show first 60 characters of each pattern
        patternPreview := SubStr(pattern, 1, 60)
        if (StrLen(pattern) > 60)
            patternPreview .= "..."
        patternList .= index . ". " . patternPreview . "`n`n"
    }

    MsgBox, 0, Death Tyrant Patterns, %patternList%
return

; Clear all gnoll patterns
ClearGnollPatterns:
    MsgBox, 4, Clear Gnoll Patterns, Are you sure you want to reset to the default gnoll pattern?`n`nThis will remove all additional patterns you captured.
    IfMsgBox Yes
    {
        ; Reset to default pattern
        defaultGnollPattern := "|<>9E9F85-0.66$32.nzsPGAzy4xbTwzTNrzaBkxyw0k6TC6Nhj270u3H74T4y237yNk1Xz6w0Fzxj08TyEw47zAj23zznk0ztyM0TzLk07zsTU1zysTUT7c"
        gnollPatterns := []
        gnollPatterns.Push(defaultGnollPattern)
        SavePetBuffPatterns()
        GuiControl, PetBuff:, PetBuffGnollStatus, Reset to default gnoll pattern.
        ; Refresh the GUI
        Gui, PetBuff:Destroy
        Goto, PetBuffSettings
    }
return

; Clear all Death Tyrant patterns
ClearDTPatterns:
    MsgBox, 4, Clear DT Patterns, Are you sure you want to reset to the default Death Tyrant patterns?`n`nThis will remove all additional patterns you captured.
    IfMsgBox Yes
    {
        ; Reset to default patterns
        defaultDTPattern1 := "|<>E5A657-0.52$19.rTszTwPjz5vzurzVv0sTUxD0ya2ML0CHCDDj3azW0Tk0hk1bU1rk0nw0vDsxwzWk1z0000001"
        defaultDTPattern2 := "|<>*94$16.QbRbnqTiNvz7rwjznTrSztwTbwuTzfzrBzwDzkTzU"
        deathTyrantPatterns := []
        deathTyrantPatterns.Push(defaultDTPattern1)
        deathTyrantPatterns.Push(defaultDTPattern2)
        SavePetBuffPatterns()
        GuiControl, PetBuff:, PetBuffDTStatus, Reset to default Death Tyrant patterns.
        ; Refresh the GUI
        Gui, PetBuff:Destroy
        Goto, PetBuffSettings
    }
return

; Test gnoll patterns on screen
TestGnollPatterns:
    if (gnollPatterns.Length() = 0) {
        GuiControl, PetBuff:, PetBuffGnollStatus, No gnoll patterns to test!
        return
    }

    GuiControl, PetBuff:, PetBuffGnollStatus, Testing gnoll patterns on screen...

    foundCount := 0
    for index, pattern in gnollPatterns {
        if (ok := FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, pattern)) {
            foundCount++
            GuiControl, PetBuff:, PetBuffGnollStatus, Found gnoll with pattern %index% at (%X%, %Y%)

            ; Highlight the found gnoll with MouseTip
            Try {
                For i, v in ok {
                    if (i <= 2)
                        FindText().MouseTip(ok[i].x, ok[i].y)
                }
            }
            Sleep, 2000
        }
    }

    if (foundCount = 0) {
        GuiControl, PetBuff:, PetBuffGnollStatus, No gnoll found on screen with any pattern.
    } else {
        GuiControl, PetBuff:, PetBuffGnollStatus, Test complete! Found %foundCount% gnoll(s).
    }
return

; Test Death Tyrant patterns on screen
TestDTPatterns:
    if (deathTyrantPatterns.Length() = 0) {
        GuiControl, PetBuff:, PetBuffDTStatus, No Death Tyrant patterns to test!
        return
    }

    GuiControl, PetBuff:, PetBuffDTStatus, Testing Death Tyrant patterns on screen...

    foundCount := 0
    for index, pattern in deathTyrantPatterns {
        if (ok := FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, pattern)) {
            foundCount++
            GuiControl, PetBuff:, PetBuffDTStatus, Found DT with pattern %index% at (%X%, %Y%)

            ; Highlight the found Death Tyrant with MouseTip
            Try {
                For i, v in ok {
                    if (i <= 2)
                        FindText().MouseTip(ok[i].x, ok[i].y)
                }
            }
            Sleep, 2000
        }
    }

    if (foundCount = 0) {
        GuiControl, PetBuff:, PetBuffDTStatus, No Death Tyrant found on screen with any pattern.
    } else {
        GuiControl, PetBuff:, PetBuffDTStatus, Test complete! Found %foundCount% Death Tyrant(s).
    }
return

; Remove gnoll failure tooltip
RemoveGnollFailTooltip:
    ToolTip,,,,1
return

; ========= NEW BUFF IMAGE CAPTURE FUNCTIONS =========

; Capture Gnoll Reflecting Shield buff image
CaptureGnollBuff:
    GuiControl, PetBuff:, PetBuffStatus, Press 1 when the Reflecting Shield buff icon is visible on screen.
    KeyWait, 1, D
    capturedText := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)

    if (capturedText) {
        gnollBuffImagePattern := capturedText
        Clipboard := capturedText
        ; Save to settings
        FileEncoding, UTF-8
        IniWrite, %gnollBuffImagePattern%, %SettingsFile%, PetBuffImages, GnollBuffPattern
        FileEncoding

        GuiControl, PetBuff:, PetBuffStatus, Reflecting Shield buff image captured successfully!
    } else {
        GuiControl, PetBuff:, PetBuffStatus, Failed to capture Reflecting Shield buff image. Try again.
    }
return

CheckGnollBuffCapture:
    ; This timer will be stopped when F1 is pressed
return

; Test Gnoll buff detection
TestGnollBuff:
    if (gnollBuffImagePattern = "") {
        GuiControl, PetBuff:, PetBuffStatus, No Reflecting Shield image captured yet! Please capture first.
        return
    }

    GuiControl, PetBuff:, PetBuffStatus, Testing Reflecting Shield detection on screen...

    if (ok := FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, gnollBuffImagePattern)) {
        GuiControl, PetBuff:, PetBuffStatus, Reflecting Shield buff found at (%X%, %Y%)!

        ; Highlight the found buff
        Try {
            For i, v in ok {
                if (i <= 1)
                    FindText().MouseTip(ok[i].x, ok[i].y)
            }
        }
        Sleep, 3000
    } else {
        GuiControl, PetBuff:, PetBuffStatus, Reflecting Shield buff not found on screen.
    }
return

; Remove Gnoll buff image
RemoveGnollBuff:
    gnollBuffImagePattern := ""
    IniDelete, %SettingsFile%, PetBuffImages, GnollBuffPattern
    GuiControl, PetBuff:, PetBuffStatus, Reflecting Shield buff image removed.
return

; Capture DT Monarch buff image
CaptureDTBuff:
    GuiControl, PetBuff:, PetBuffStatus, Press 1 when the Monarch buff icon is visible on screen.
    KeyWait, 1, D
    capturedText := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)

    if (capturedText) {
        dtBuffImagePattern := capturedText
        Clipboard := capturedText
        ; Save to settings
        FileEncoding, UTF-8
        IniWrite, %dtBuffImagePattern%, %SettingsFile%, PetBuffImages, DTBuffPattern
        FileEncoding

        GuiControl, PetBuff:, PetBuffStatus, Monarch buff image captured successfully!
    } else {
        GuiControl, PetBuff:, PetBuffStatus, Failed to capture Monarch buff image. Try again.
    }
return

CheckDTBuffCapture:
    ; This timer will be stopped when F1 is pressed
return

; Test DT buff detection
TestDTBuff:
    if (dtBuffImagePattern = "") {
        GuiControl, PetBuff:, PetBuffStatus, No Monarch image captured yet! Please capture first.
        return
    }

    GuiControl, PetBuff:, PetBuffStatus, Testing Monarch detection on screen...

    if (ok := FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, dtBuffImagePattern)) {
        GuiControl, PetBuff:, PetBuffStatus, Monarch buff found at (%X%, %Y%)!

        ; Highlight the found buff
        Try {
            For i, v in ok {
                if (i <= 1)
                    FindText().MouseTip(ok[i].x, ok[i].y)
            }
        }
        Sleep, 3000
    } else {
        GuiControl, PetBuff:, PetBuffStatus, Monarch buff not found on screen.
    }
return

; Remove DT buff image
RemoveDTBuff:
    dtBuffImagePattern := ""
    IniDelete, %SettingsFile%, PetBuffImages, DTBuffPattern
    GuiControl, PetBuff:, PetBuffStatus, Monarch buff image removed.
return

; Capture custom summon pattern
CaptureSummonPattern:
    GuiControl, PetBuff:, PetBuffStatus, Press 1 when the summon skill icon is visible on screen.
    KeyWait, 1, D
    capturedText := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)

    if (capturedText) {
        customSummonPattern := capturedText
        Clipboard := capturedText
        ; Save to settings
        FileEncoding, UTF-8
        IniWrite, %customSummonPattern%, %SettingsFile%, PetBuffImages, SummonPattern
        FileEncoding

        GuiControl, PetBuff:, PetBuffStatus, Custom summon pattern captured successfully!
    } else {
        GuiControl, PetBuff:, PetBuffStatus, Failed to capture summon pattern. Try again.
    }
return

CheckSummonCapture:
    ; This timer will be stopped when F1 is pressed
return

; Test summon pattern detection
TestSummonPattern:
    if (customSummonPattern = "") {
        GuiControl, PetBuff:, PetBuffStatus, No custom summon pattern captured yet! Please capture first.
        return
    }

    GuiControl, PetBuff:, PetBuffStatus, Testing custom summon pattern on screen...

    if (ok := FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, customSummonPattern)) {
        GuiControl, PetBuff:, PetBuffStatus, Custom summon pattern found at (%X%, %Y%)!

        ; Highlight the found pattern
        Try {
            For i, v in ok {
                if (i <= 1)
                    FindText().MouseTip(ok[i].x, ok[i].y)
            }
        }
        Sleep, 3000
    } else {
        GuiControl, PetBuff:, PetBuffStatus, Custom summon pattern not found on screen.
    }
return

; Remove custom summon pattern
RemoveSummonPattern:
    customSummonPattern := ""
    IniDelete, %SettingsFile%, PetBuffImages, SummonPattern
    GuiControl, PetBuff:, PetBuffStatus, Custom summon pattern removed.
return

; Save custom summon keybind
SaveSummonKeybind:
    Gui, PetBuff:Submit, NoHide
    summonKeybind := SummonKeybindEdit

    ; Save to settings
    FileEncoding, UTF-8
    IniWrite, %summonKeybind%, %SettingsFile%, PetBuffImages, SummonKeybind
    FileEncoding

    GuiControl, PetBuff:, PetBuffStatus, Summon keybind saved as: %summonKeybind%
return

; ========= END NEW BUFF IMAGE FUNCTIONS =========

; Helper function to send keybind with proper modifier handling
SendKeybind(keybind, targetWindow) {
    ; Parse AutoHotkey keybind syntax: +1 (Shift+1), ^1 (Ctrl+1), !1 (Alt+1), etc.

    ; Debug output
    ToolTip, SendKeybind called with: %keybind% to %targetWindow%, 100, 100, 2
    SetTimer, RemoveDebugTooltip, -2000

    ; Check for modifiers at the start of the string
    hasShift := InStr(keybind, "+") = 1
    hasCtrl := InStr(keybind, "^") = 1 
    hasAlt := InStr(keybind, "!") = 1

    ; Extract base key by removing modifier symbols from the beginning
    baseKey := keybind
    modifierCount := 0

    ; Remove modifiers one by one
    if (hasShift) {
        baseKey := SubStr(baseKey, 2)
        modifierCount++
    }
    if (hasCtrl) {
        baseKey := SubStr(baseKey, 2)
        modifierCount++
    }
    if (hasAlt) {
        baseKey := SubStr(baseKey, 2)
        modifierCount++
    }

    ; Debug what we parsed
    ToolTip, Parsed - Shift:%hasShift% Ctrl:%hasCtrl% Alt:%hasAlt% BaseKey:%baseKey%, 100, 120, 3
    SetTimer, RemoveDebugTooltip2, -3000

    ; Send modifiers down
    if (hasShift)
        ControlSend, , {Shift down}, %targetWindow%
    if (hasCtrl)
        ControlSend, , {Ctrl down}, %targetWindow%
    if (hasAlt)
        ControlSend, , {Alt down}, %targetWindow%

    Sleep, 25

    ; Send base key
    ControlSend, , {%baseKey% down}, %targetWindow%
    Sleep, 25
    ControlSend, , {%baseKey% up}, %targetWindow%

    Sleep, 25

    ; Send modifiers up (reverse order)
    if (hasAlt)
        ControlSend, , {Alt up}, %targetWindow%
    if (hasCtrl)
        ControlSend, , {Ctrl up}, %targetWindow%
    if (hasShift)
        ControlSend, , {Shift up}, %targetWindow%
}

RemoveDebugTooltip:
    ToolTip, , , , 2
return

RemoveDebugTooltip2:
    ToolTip, , , , 3
return

; Navigation pause/resume functions for pet buff execution
PauseNavigationForBuff() {
    global PetBuffExecuting, NavigationPausedForBuff, IsTraveling, NavIsTraveling

    ; Debug: Always show that function is called
    ;ToolTip, PAUSE called - IsTraveling:%IsTraveling% NavIsTraveling:%NavIsTraveling%, 100, 50, 5
    SetTimer, RemoveDebugPause, -3000

    ; Always pause navigation timers when this function is called
    PetBuffExecuting := true
    NavigationPausedForBuff := true

    ; Stop navigation timers but keep signal detection running
    SetTimer, NavTravelLoop, Off
    SetTimer, UpdateNavCoordinatesDisplay, Off
    SetTimer, TravelLoop, Off
    ; Keep TimerSignalCheck running so it can detect waypoint commands during pauses

    ; Visual feedback
    WinGetPos, winX, winY, winW, winH, ahk_id %win1%
    if (winX != "" && winY != "" && winW != "" && winH != "") {
        tooltipX := winX + (winW / 2)
        tooltipY := winY + (winH * 0.10)
        ToolTip, Navigation paused for pet buff..., %tooltipX%, %tooltipY%, 4
        }

}

RemoveDebugPause:
    ToolTip, , , , 5
return

ResumeNavigationAfterBuff() {
    global PetBuffExecuting, NavigationPausedForBuff, IsTraveling, NavIsTraveling

    ; Debug: Always show that function is called  
    ToolTip, RESUME called - IsTraveling:%IsTraveling% NavIsTraveling:%NavIsTraveling%, 100, 80, 6
    SetTimer, RemoveDebugResume, -3000

    PetBuffExecuting := false
    NavigationPausedForBuff := false

    ; Always restart navigation timers when this function is called
    SetTimer, NavTravelLoop, 100
    SetTimer, UpdateNavCoordinatesDisplay, 500
    SetTimer, TravelLoop, 50
    ;SetTimer, TimerSignalCheck, 100 ; Start signal checking timer

    ; Clear visual feedback
    ToolTip, , , , 4
}
return
; Separate timer for signal detection that doesn't get paused
; TimerSignalCheck:
;     ; Debug: Show that signal checking is running (only every 50 cycles = 5 seconds)
;     signalCheckCounter++
;     if (Mod(signalCheckCounter, 50) = 0) {
;         ;ToolTip, TimerSignalCheck running (%signalCheckCounter%), 500, 400, 8
;         SetTimer, RemoveSignalRunningDebug, -2000
;     }

;     ; Check for timer execution signal from waypoint scripts
;     signalFile := A_ScriptDir . "\timer_signal.tmp"
;     if (FileExist(signalFile)) {
;         FileDelete, %signalFile%
;         ;ToolTip, Signal detected - executing timer flags, 300, 300, 9
;         SetTimer, RemoveSignalDebug, -3000
;         CheckAndExecuteTimerFlags()
;     }
; return

RemoveSignalRunningDebug:
    ToolTip, , , , 8
return

RemoveDebugResume:
    ToolTip, , , , 6
return

; Remove Death Tyrant failure tooltip
RemoveDTFailTooltip:
    ToolTip,,,,1
return

DestroyskyPotionstimer:
    GuiControlGet, destroyskypotionstimer

    if (destroyskypotionstimer = 1)
    {
        ; Ask if user wants to destroy essences too
        MsgBox, 4, Destroy Essences?, Do you want to destroy essences too?
        IfMsgBox Yes
        {
            destroyessences := true
        }
        Else
        {
            destroyessences := false
        }

        destroypotions := true
        SetTimer, DestroyskyPotions, 2000
        DestroySkyPotions()
    }
    else
    {
        destroypotions := false
        destroyessences := false
        SetTimer, DestroyskyPotions, Off
    }
Return 

DestroySkyPotions(force := false) {
    ; Check if Critical mode is enabled
    if (CriticalModeEnabled) {
        return
    }

    ; If navigation is running, set flag instead of executing
    if ((NavIsTraveling || IsTraveling) && !force) {
        potionDestroyNeeded := true
        return false
    }

    ; Pause navigation during potion destruction
    IF (NavIsTraveling)
    {
        PauseNavigationForBuff()
    }
    sleep, 3000
    lvl3pot:="|<>*117$26.7wwE1z/20zqM0Dyb1rrds33tDzsqSTu933zWMTzMW0zrjvzxtzzzLTrzonwzwaTjz9nvy3yDw2"
    lvl3pot.="|<>*118$29.z7bc7wTD07tyS07Xww0CDtsUQTmkUlzgk1XzdkTjjHk4kyHztlgwzyWEmzz4kzy68UDwDTrzsSTzzkizjzd4DDz143Ty2A2zw2QTs47wTk8"
    lvl3pot.="|<>*127$14.nUQw7D0twDDXNzLAqsQnTDzszwDz7zvzyzzTzzzzzzzzzzzzzU"
    lvl3pot.="|<>*126$29.zlnw7z7bc7wTD07tyS0DXww0SDtsUwTmkVlzgk3XzdkTjjHkAkyHzllgszyWEkyz4kzy68UDsDTrzkSTzzk"

    ; Add essences patterns if user selected to destroy them
    if (destroyessences) {
        lvl3pot.="|<essences>*118$15.zzzzzzzzzzzzzzzzzzzzzkjs7s8s1hMUQ0703w"
        lvl3pot.="|<essences>*105$15.zzzzzzzzzzzzzzzztzy3zFykTk7sELw3w0T0qw"
        lvl3pot.="|<essences>*122$15.zzzzzzzzzzzzzzzziTr0s060EE06070SEsUc04"
    }

    inventory:="|<>*124$13.y3ySwzgztDwvuAx/K6f/YJuPQnqrx7zDw"
    inventory.="|<>*137$13.y3ySwzgztDwluAx/K6f/YJuPQnqrx7zDw"

    inventorytext:="|<>E8E9E9-0.90$29.0001000022FC/C+WWN8Yd4WF9Ht4WGY294W8YG94C8aA"

    destroytab:="|<>3F3F3F-0.86$20.zzzzzzzU03vzyyjyjhzPvjiyxrjjfvvxyyyjjjRvvjiyrxjfzfvzyy00Dzzzzzzs"
    destroytab.="|<>334356-0.90$26.000040011000EHzzY400117zwEFTx44Pyl17TQEFvj44TLl17vwEFxT44Svl17TQEFjv44LzF17zwEE0044zzt1000ETzzw00002"

    destroybutton:="|<>B92C36-0.90$29.s040080800/rvT0IsZZ0zN++VkOIT5U4grlzhD80000E0001c"

    ; Ensure win1 is valid
    IfWinNotExist, ahk_id %win1%
        Return

    ;WinActivate, ahk_id %win1%
    Sleep, 100

    ; Work only inside the game window bounds
    WinGetPos, winX, winY, winW, winH, ahk_id %win1%
    if (!winW || !winH)
        Return

    ; Main processing loop
    Loop {
        ; Open inventory with error handling
        ControlSend,, {i}, ahk_id %win1%
        Sleep, 100

        ; Verify inventory opened (wait up to 2 seconds)
        inventoryOpened := false
        Loop, 20 {
            if (FindText(invTextX, invTextY, winX, winY, winX + winW, winY + winH, 0, 0, inventorytext)) {
                inventoryOpened := true
                Sleep, 10
                Break
            }
            Sleep, 100
        }

        ; If inventory didn't open, try again
        if (!inventoryOpened) {
            ControlSend,, {i}, ahk_id %win1%
            Sleep, 200
            ; Final check
            if !(FindText(invTextX, invTextY, winX, winY, winX + winW, winY + winH, 0, 0, inventorytext)) {
                ; If still not open, exit
                Break
            }
        }

        ; 1) Find inventorytext and calculate potions tab position
        ; Original coordinates: inventorytext at 735,174 and potionstab at 918,373
        ; Offset: 183 right, 199 down
        if (FindText(invTextX, invTextY, winX, winY, winX + winW, winY + winH, 0, 0, inventorytext)) {
            ; Calculate potions tab position
            potionsTabX := invTextX + 183
            potionsTabY := invTextY + 199

            ; Click the potions tab
            winId := win1
            WinGetPos, winX, winY,,, ahk_id %winId%
            relativeX := potionsTabX - winX - 8
            relativeY := potionsTabY - winY - 31
            lParam := (relativeY << 16) | (relativeX & 0xFFFF)
            SendMessage, 0x201, 1, %lParam%,, ahk_id %winId%
            Sleep, 50
            SendMessage, 0x202, 0, %lParam%,, ahk_id %winId%
            Sleep, 500
        } else {
            ; If inventory text not found, break
            Break
        }
        destroyTabClicked := false
        if (FindText(invTextX, invTextY, winX, winY, winX + winW, winY + winH, 0, 0, inventorytext)) {
            ; Calculate potions tab position
            DESTROYX := invTextX + 16
            DESTROYY := invTextY + 25

            ; Click the potions tab
            winId := win1
            WinGetPos, winX, winY,,, ahk_id %winId%
            relativeX := DESTROYX - winX - 8
            relativeY := DESTROYY - winY - 31
            lParam := (relativeY << 16) | (relativeX & 0xFFFF)
            SendMessage, 0x201, 1, %lParam%,, ahk_id %winId%
            Sleep, 80
            SendMessage, 0x202, 0, %lParam%,, ahk_id %winId%
            destroyTabClicked := true
            SLEEP, 200

        } else {
            ; If inventory text not found, break
            Break
        }
        ; 2) Click Destroy tab with retry logic
        ; W
        ; Loop, 3 {
        ;     if (FindText(dTabX, dTabY, winX, winY, winX + winW, winY + winH, 0, 0, destroytab)) {
        ;         winId := win1
        ;         WinGetPos, winX, winY,,, ahk_id %winId%
        ;         relativeX := dTabX - winX - 8
        ;         relativeY := dTabY - winY - 31
        ;         lParam := (relativeY << 16) | (relativeX & 0xFFFF)
        ;         SendMessage, 0x201, 1, %lParam%,, ahk_id %winId%
        ;         Sleep, 50
        ;         SendMessage, 0x202, 0, %lParam%,, ahk_id %winId%
        ;         Sleep, 50
        ;         SendMessage, 0x201, 1, %lParam%,, ahk_id %winId%
        ;         Sleep, 50
        ;         SendMessage, 0x202, 0, %lParam%,, ahk_id %winId%
        ;         Sleep, 300
        ;         destroyTabClicked := true
        ;         Break
        ;     }
        ;     Sleep, 200
        ; }

        ; If destroy tab wasn't found, continue to next iteration
        if (!destroyTabClicked) {
            BREAK
        }

        ; 3) Find all lvl3pot inside the window and Alt+Click each one
        lvl3Results := FindText()
        lvl3Results := FindText(xp, yp, winX, winY, winX + winW, winY + winH, 0, 0, lvl3pot)
        if (lvl3Results) {
            ; Hold Alt down
            ControlSend,, {Alt down}, ahk_id %win1%

            ;Send, {Alt down}
            Sleep, 50

            ; Click each potion found
            for idx, entry in lvl3Results {
                X := entry.x
                Y := entry.y

                ; Click with Alt held
                SendMessageClick(X, Y, WIN1)
                ;FindText().Click(X, Y, "L")
                Sleep, 100
            }

            ; Release Alt
            ControlSend,, {Alt UP}, ahk_id %win1%
            Sleep, 100

            ; 4) Click destroy button (if present)
            destroyClicked := false
            Loop, 3 {
                if (FindText(destX, destY, winX, winY, winX + winW, winY + winH, 0, 0, destroybutton)) {
                    winId := win1
                    WinGetPos, winX, winY,,, ahk_id %winId%
                    relativeX := destX - winX - 8
                    relativeY := destY - winY - 31
                    lParam := (relativeY << 16) | (relativeX & 0xFFFF)
                    SendMessage, 0x201, 1, %lParam%,, ahk_id %winId%
                    Sleep, 50
                    SendMessage, 0x202, 0, %lParam%,, ahk_id %winId%
                    Sleep, 50
                    SendMessage, 0x201, 1, %lParam%,, ahk_id %winId%
                    Sleep, 50
                    SendMessage, 0x202, 0, %lParam%,, ahk_id %winId%
                    destroyClicked := true
                    Break
                }
                Sleep, 100
            }
        }

        ; 5) Wait and refresh inventory
        Sleep, 1000

        ; ; Click inventory button to refresh
        ; if (FindText(bInvX2, bInvY2, winX, winY, winX + winW, winY + winH, 0, 0, inventory)) {
        ;     winId := win1
        ;     WinGetPos, winX, winY,,, ahk_id %winId%
        ;     relativeX := bInvX2 - winX - 8
        ;     relativeY := bInvY2 - winY - 31
        ;     lParam := (relativeY << 16) | (relativeX & 0xFFFF)
        ;     SendMessage, 0x201, 1, %lParam%,, ahk_id %winId%
        ;     Sleep, 50
        ;     SendMessage, 0x202, 0, %lParam%,, ahk_id %winId%
        ;     Sleep, 50
        ;     SendMessage, 0x201, 1, %lParam%,, ahk_id %winId%
        ;     Sleep, 50
        ;     SendMessage, 0x202, 0, %lParam%,, ahk_id %winId%
        ; } 

        Sleep, 400

        ; Check if inventory needs to be closed or reopened
        Loop, {
            ; Check if inventory is still open
            if !(FindText(iX, iY, winX, winY, winX + winW, winY + winH, 0, 0, inventorytext)) {
                ; Inventory closed - verify it's actually closed
                Sleep, 200
                if !(FindText(iX2, iY2, winX, winY, winX + winW, winY + winH, 0, 0, inventorytext)) {
                    ; Confirmed closed, exit inner loop
                    Break
                }
            }
            ; Inventory is still open, try to close/reopen it
            else if (FindText(bInvX, bInvY, winX, winY, winX + winW, winY + winH, 0, 0, inventorytext)) {
                ControlSend,, {i}, ahk_id %win1%
                Sleep, 500

                ; Wait for inventory to close
                Loop, 10 {
                    if !(FindText(iX3, iY3, winX, winY, winX + winW, winY + winH, 0, 0, inventorytext)) {
                        Break
                    }
                    Sleep, 200
                }
                Break
            }
            Break
        }

        ; Final check - ensure inventory is closed before next iteration
        Sleep, 200
        if (FindText(finalCheckX, finalCheckY, winX, winY, winX + winW, winY + winH, 0, 0, inventorytext)) {
            ; Inventory still open, force close with 'i' key
            ControlSend,, {i}, ahk_id %win1%
            Sleep, 300
        }

        Break
    }
    if (NavigationPausedForBuff) {
        ResumeNavigationAfterBuff()
    }
Return
}

Farming:
    if (Farming = False)
    {
        ; Ask user to right-click pylon location
        MsgBox, 4, Set Pylon Location, Right-click on the location where the pylon will spawn.
        IfMsgBox No
        return

        ; Wait for right-click to capture coordinates
        KeyWait, RButton, D
        MouseGetPos, tempPylonX, tempPylonY
        KeyWait, RButton

        ; Convert to window-relative coordinates
        WinGetPos, winX, winY,,, ahk_id %win1%
        pylonX := tempPylonX - winX
        pylonY := tempPylonY - winY

        MsgBox, Pylon location set to: %pylonX%, %pylonY% (relative to window)

        Farming := True
        LoadCoordinateSettings()
        settimer, capchacheck, 500
        SetTimer, essences, 30000
        SetTimer, buffdaddystone, 2000000
        SetTimer, buffpetscroll, 2017000
        settimer, checkweight, 1000
        SetTimer, snapshot, 5000
        ;SetTimer, farmzone, 100
    }
    else if (Farming = True)
    {
        Farming := False
        settimer, capchacheck, off
        SetTimer, essences, off
        SetTimer, buffdaddystone, off
        SetTimer, buffpetscroll, off
        SetTimer, PylonClicker, off
    }
Return
Farmzone:

    mobhealth:="|<>C6053F-0.79$101.zzzzzzzzzzzzzzzzy0000000000000000Tzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzk"
    WinGetPos, winX, winY,,, ahk_id %winId%

    ; Calculate relative coordinates (simple screen to window conversion)
    relativeX := 255 - winX
    relativeY := 322 - winY
    relativex2 := 820 - winX
    relativey2 := 760 - winY

    ; Adjust for title bar and borders (typical Windows offset)
    relativeX := relativeX - 8
    relativeY := relativeY - 31
    if (ok:=FindText(X, Y, %relativeX%, %relativeY%, %relativex2%, %relativey2%, 0, 0, mobhealth))
    {
        ;SendMessageClick3(X, Y+40, win1)
        ;MouseClick, left, %X%, %Y%+30
        TryCastDPSSkills()
        sleep, 4000
    }
    ; FileRead, dpsEnabled, com.ini
    ; dpsEnabled := Trim(dpsEnabled)
    ; if (dpsEnabled = "1") {
    ;     TryCastDPSSkills()
    ; }
return
healanddps:
    Gui, Submit, NoHide
    if (healanddps) {
        ; Uncheck the other checkbox
        GuiControl,, dpstargetedhealing, 0
        dpstargetedhealing := false
    }
Return

returnafterheal:
    if (retrnafterheal = false)
    {
        returnafterheal := true
    }
    else if (returnafterheal = true)
    {
        retrnafterheal := false
    }
return

dpsNavEnabled:
    ; Get the actual checkbox state
    GuiControlGet, dpsNavEnabled

    if (dpsNavEnabled) {
        ; Checkbox is checked - turn ON
        MsgBox, DPS Navigation ENABLED. When using this feature, make sure to set your camera at 900 and change the angle to top down view for best results.
            ; Add any initialization code here for when navigation is enabled
        InitializeNavigation()
        dpsNavEnabled := true
    } else {
        ; Checkbox is unchecked - turn OFF  
        MsgBox, DPS Navigation DISABLED.
        ; Add any cleanup code here for when navigation is disabled
        SetTimer, UpdateNavCoordinatesDisplay, off
        dpsNavEnabled := false
    }
return

SetDPSNavCoords:
    if (!NavTargetGameWindow) {
        MsgBox, Please select a navigation window first!
        return
    }

    GetNavCurrentCoordinates(coordX, coordY)
    if (coordX = "" || coordY = "") {
        MsgBox, Could not get current coordinates!
        return
    }

    GuiControl,, dpsNavTargetXEdit, %coordX%
    GuiControl,, dpsNavTargetYEdit, %coordY%
    dpsNavTargetX := coordX
    dpsNavTargetY := coordY
    MsgBox, DPS Navigation coordinates set to X: %coordX% Y: %coordY%
return

SaveDPSNavCoords:
    Gui, Submit, NoHide
    dpsNavTargetX := dpsNavTargetXEdit
    dpsNavTargetY := dpsNavTargetYEdit
    dpsNavRadius := dpsNavRadiusEdit

    ; Validate radius (minimum 25)
    if (dpsNavRadius < 25) {
        dpsNavRadius := 25
        GuiControl,, dpsNavRadiusEdit, 25
        MsgBox, Radius cannot be less than 25. Set to minimum value.
    }

    ;IniWrite, %dpsNavEnabled%, dpsnavsettings.ini, Navigation, Enabled
    IniWrite, %dpsNavTargetX%, dpsnavsettings.ini, Navigation, TargetX
    IniWrite, %dpsNavTargetY%, dpsnavsettings.ini, Navigation, TargetY
    IniWrite, %dpsNavRadius%, dpsnavsettings.ini, Navigation, Radius

    MsgBox, DPS Navigation settings saved!
return

dpstargetedhealing:
    Gui, Submit, NoHide
    if (dpstargetedhealing) {
        ; Uncheck the other checkbox
        GuiControl,, healanddps, 0
        healanddps := false

        ; Ask for player and pet counts
        InputBox, playerCount, DPS Targeted Healing, Enter number of players (0-10):, , 300, 130, , , , , 0
        if (ErrorLevel)
            return

        InputBox, petCount, DPS Targeted Healing, Enter number of pets (0-10):, , 300, 130, , , , , 0
        if (ErrorLevel)
            return

        if (playerCount = 0 && petCount = 0) {
            MsgBox, Must have at least 1 player or pet
            GuiControl,, dpstargetedhealing, 0
            dpstargetedhealing := false
            return
        }

        ; Capture coordinates
        DPSTargetedPlayerCoords := []
        DPSTargetedPetCoords := []

        Gui, Hide

        if (playerCount > 0) {
            MsgBox, Right-click on %playerCount% player health bar locations
            Loop, %playerCount% {
                ToolTip, Right-click Player %A_Index% health bar, 100, 100
                KeyWait, RButton, D
                MouseGetPos, px, py
                DPSTargetedPlayerCoords.Push({x: px, y: py})
                KeyWait, RButton
                Sleep, 200
            }
        }

        if (petCount > 0) {
            MsgBox, Right-click on %petCount% pet health bar locations
            Loop, %petCount% {
                ToolTip, Right-click Pet %A_Index% health bar, 100, 100
                KeyWait, RButton, D
                MouseGetPos, px, py
                DPSTargetedPetCoords.Push({x: px, y: py})
                KeyWait, RButton
                Sleep, 200
            }
        }

        ToolTip
        Gui, Show

        MsgBox, DPS Targeted Healing configured: %playerCount% players, %petCount% pets
    }
Return
; Button handler for monitor selection
MonitorButton:
    monitorNum := A_GuiControl
    if (activeMonitors < maxMonitors) {
        GuiControl, Main:, MonitorStatus, Click on window %monitorNum% to monitor...
        KeyWait, LButton, D
        MouseGetPos,,, winId
        WinGetTitle, title, ahk_id %winId%

        ; Launch a new AHK process for this window
        Run, "%A_AhkPath%" "%A_ScriptDir%\MemoryMonitor%monitorNum%.ahk" "%winId%"

        activeMonitors++
        GuiControl, Main:, MonitorStatus, Monitoring %activeMonitors% window(s)
    } else {
        GuiControl, Main:, MonitorStatus, Maximum of %maxMonitors% windows reached
    }
return
Closemonitors:
    ; Close all monitor processes
    Loop, 8 {
        Process, Close, MemoryMonitor%A_Index%.ahk
    }
Return
Expmonitor:
    Run, %A_ScriptDir%\expperhour.ahk
return
altassist:
    Run, C:\Users\zombi\Desktop\ahk stuff\AA\AltAssistV2.exe
return
Rupeemonitor:
    Run, %A_ScriptDir%\rupeeperhour.ahk
return
SetSkillbarArea:
    ; Hide the GUI temporarily
    Gui, 1:Hide

    ; Instructions
    MsgBox, 4, Set Skillbar Area, Click OK then drag to select your skillbar area.`n`nPress ESC to cancel.
    IfMsgBox No
    {
        Gui, 1:Show
        return
    }

    ; Wait for left mouse button down to start dragging
    ToolTip, Click and drag to select the skillbar area (Press ESC to cancel), 100, 100

    ; Create overlay GUIs for the selection box (4 borders)
    borderThickness := 2

    ; Top border
    Gui, SelectionBoxTop:New, +AlwaysOnTop +ToolWindow -Caption +E0x20
    Gui, SelectionBoxTop:Color, Red

    ; Bottom border
    Gui, SelectionBoxBottom:New, +AlwaysOnTop +ToolWindow -Caption +E0x20
    Gui, SelectionBoxBottom:Color, Red

    ; Left border
    Gui, SelectionBoxLeft:New, +AlwaysOnTop +ToolWindow -Caption +E0x20
    Gui, SelectionBoxLeft:Color, Red

    ; Right border
    Gui, SelectionBoxRight:New, +AlwaysOnTop +ToolWindow -Caption +E0x20
    Gui, SelectionBoxRight:Color, Red

    ; Wait for left button down
    KeyWait, LButton, D

    ; Get starting position
    MouseGetPos, startX, startY

    ; Initialize tracking variables
    lastSelectionX := startX
    lastSelectionY := startY
    selectionBoxHwnd := ""

    ; Track mouse movement and draw selection box
    SetTimer, UpdateSelectionBox, 200

    ; Wait for left button release
    KeyWait, LButton

    ; Stop updating the box
    SetTimer, UpdateSelectionBox, Off

    ; Get ending position
    MouseGetPos, endX, endY

    ; Clean up all selection box GUIs
    Gosub, CleanupSelectionBox
    ToolTip

    ; Ensure we have valid coordinates (X1 < X2 and Y1 < Y2)
    tempX1 := (startX < endX) ? startX : endX
    tempX2 := (startX < endX) ? endX : startX
    tempY1 := (startY < endY) ? startY : endY
    tempY2 := (startY < endY) ? endY : startY

    ; Validate coordinates
    if (tempX1 >= tempX2 || tempY1 >= tempY2) {
        MsgBox, 16, Error, Invalid selection! Area is too small.
        Gosub, CleanupSelectionBox
        Gui, 1:Show
        return
    }

    ; Convert to window-relative coordinates
    WinGetPos, winX, winY,,, ahk_id %win1%
    SkillBarX1 := tempX1 - winX
    SkillBarY1 := tempY1 - winY
    SkillBarX2 := tempX2 - winX
    SkillBarY2 := tempY2 - winY

    ; Calculate dimensions
    width := SkillBarX2 - SkillBarX1
    height := SkillBarY2 - SkillBarY1

    ; Save to INI file
    SaveSkillbarCoordinates()

    ; Update the display
    UpdateSkillbarDisplay()

    ; Show the GUI again first
    Gui, 1:Show

    ; Show success message
    MsgBox, 64, Success, Skillbar area updated successfully!`n`nNew coordinates:`nTop-left: %SkillBarX1%,%SkillBarY1%`nBottom-right: %SkillBarX2%,%SkillBarY2%`n`nArea size: %width%x%height% pixels
return

; Bounding box function for creating selection rectangles
bounding_box(color, x, y, w, h) {
    tc := 0x1 ; Transparent color
    Gui, New, -Caption +AlwaysOnTop +LastFound hwndgoo ; Make a gui with no caption (window features) and always on top
    opt := "x0 y0 w" w " h" h " c" tc " Background" color ; Progress bar options. Set bar color to tc and background to desired color
    Gui, Add, Progress, % opt, 100 ; Add progress bar to gui
    WinSet, TransColor, % tc ; Set the transparent color of the window
    Gui, Show, % "x" x " y" y " w" w " h" h ; Show the GUI. All that should show is the progress bar's outline box
return goo ; Return gui hwnd to further extend usability. Make a show/hide hotkey for example.
}

UpdateSelectionBox:
    ; Get current mouse position
    MouseGetPos, currentX, currentY

    ; Only update if mouse position has changed significantly (reduces flicker)
    if (Abs(currentX - lastSelectionX) < 3 && Abs(currentY - lastSelectionY) < 3)
        return

    lastSelectionX := currentX
    lastSelectionY := currentY

    ; Calculate box dimensions (handle dragging in any direction)
    boxX := (startX < currentX) ? startX : currentX
    boxY := (startY < currentY) ? startY : currentY
    boxW := Abs(currentX - startX)
    boxH := Abs(currentY - startY)

    ; Skip if box is too small
    if (boxW < 5 || boxH < 5)
        return

    ; Destroy existing selection box if it exists
    if (selectionBoxHwnd)
        Gui, %selectionBoxHwnd%:Destroy

    ; Create new selection box using the bounding_box function
    selectionBoxHwnd := bounding_box("Red", boxX, boxY, boxW, boxH)
return

CleanupSelectionBox:
    ; Destroy the selection box GUI
    if (selectionBoxHwnd)
        Gui, %selectionBoxHwnd%:Destroy
    selectionBoxHwnd := ""
return

; Function to save skillbar coordinates to INI
SaveSkillbarCoordinates() {
    global iniFile, SkillBarX1, SkillBarY1, SkillBarX2, SkillBarY2

    FileEncoding, UTF-8
    IniWrite, %SkillBarX1%, %iniFile%, SkillbarArea, X1
    IniWrite, %SkillBarY1%, %iniFile%, SkillbarArea, Y1
    IniWrite, %SkillBarX2%, %iniFile%, SkillbarArea, X2
    IniWrite, %SkillBarY2%, %iniFile%, SkillbarArea, Y2
    FileEncoding
}

; Function to load skillbar coordinates from INI
LoadSkillbarCoordinates() {
    global iniFile, SkillBarX1, SkillBarY1, SkillBarX2, SkillBarY2

    FileEncoding, UTF-8
    IniRead, loadedX1, %iniFile%, SkillbarArea, X1, %SkillBarX1%
    IniRead, loadedY1, %iniFile%, SkillbarArea, Y1, %SkillBarY1%
    IniRead, loadedX2, %iniFile%, SkillbarArea, X2, %SkillBarX2%
    IniRead, loadedY2, %iniFile%, SkillbarArea, Y2, %SkillBarY2%
    FileEncoding

    ; Only update if valid coordinates were loaded
    if (loadedX1 != "ERROR" && loadedY1 != "ERROR" && loadedX2 != "ERROR" && loadedY2 != "ERROR") {
        SkillBarX1 := loadedX1
        SkillBarY1 := loadedY1
        SkillBarX2 := loadedX2
        SkillBarY2 := loadedY2
    }
}

; Function to load QWERTZ mode setting from INI
LoadQWERTZSetting() {
    global iniFile, qwertzModeEnabled

    ; Load QWERTZ mode setting (default: false)
    IniRead, loadedQWERTZ, %iniFile%, Settings, QWERTZMode, 0
    if (loadedQWERTZ != "ERROR") {
        qwertzModeEnabled := (loadedQWERTZ = "1" || loadedQWERTZ = "true")
        ; Set the checkbox state in the GUI
        GuiControl,, qwertzmode, %qwertzModeEnabled%
    }
}

; Function to update the skillbar display
UpdateSkillbarDisplay() {
    global SkillBarX1, SkillBarY1, SkillBarX2, SkillBarY2

    width := SkillBarX2 - SkillBarX1
    height := SkillBarY2 - SkillBarY1
    displayText := "Current Skillbar Area: X1=" . SkillBarX1 . " Y1=" . SkillBarY1 . " X2=" . SkillBarX2 . " Y2=" . SkillBarY2 . " (Size: " . width . "x" . height . ")"
    GuiControl,, HealerSkillbarCoords, %displayText%
    GuiControl,, ToolsSkillbarCoords, %displayText%
}
LoadHealSkillsDelayed:
    RefreshHealSkillsList()
    RefreshHealPriorityList()
    ; Update the heal interval display with loaded value
    GuiControl,, HealIntervalInput, %healCheckInterval%
    ; Update skillbar coordinates display
    UpdateSkillbarDisplay()
return

LoadccSkillsDelayed:
    RefreshccPriorityList()
return
LoadDPSSkillsDelayed:
    RefreshDPSPriorityList()
return
; ========= Quick Menu's =========
skillboxesnpc:
    Run, %A_ScriptDir%\openmasterboxes.ahk
return
buffheal2nd:
    Run, C:\Users\zombi\Desktop\New folder (2) - Copy\buff&heal.ahk
return
enchanter:
    Run, %A_ScriptDir%\gear_enchanter.ahk
return
; ========= HEALER FUNCTIONS =========

; Calculate health check X position based on percentage threshold
; Health bar appears to start around portrait.x + 12
; Health bar width is approximately 108 pixels
CalculateHealthCheckX(baseHealthX, thresholdPercent) {
    healthBarWidth := 108
    ; The health bar starts at baseHealthX (portrait.x + 12)
    ; At 1%, we want to check near the start of the bar (baseHealthX + ~1)
    ; At 100%, we want to check near the end of the bar (baseHealthX + 108)
    ; Calculate offset: ((percent - 1) / 99) * width to map 1-100% to 0-108 pixels
    offset := ((thresholdPercent - 1) / 99.0) * healthBarWidth
return baseHealthX + offset
}

TestPartyDetection:
    DetectPartyMembers()
return

DetectPartyMembers() {
    ; Find the party window bar
    if (!(partyBar := FindText(0, 0, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, partywindow))) {
        UpdateHealerStatus("Party window not found")
        return
    }

    ; Create search area: 15px left, 175px right, 430px down
    searchX1 := partyBar.1.x - 15
    searchY1 := partyBar.1.y
    searchX2 := partyBar.1.x + 175
    searchY2 := partyBar.1.y + 430

    playerPatterns := magus . "|" . Corruptor . "|" . voidmage . "|" . deadeye . "|" . beastmaster . "|" . slayer . "|" . berserker . "|" . overlord . "|" . masterbreeder . "|" . Marksman
    petPatterns := windpixie . "|" . gnoll . "|" . etherealpixie

    playerCount := 0
    petCount := 0

    ; Find player portraits and show health check dots
    if (ok := FindText(0, 0, searchX1, searchY1, searchX2, searchY2, 0, 0, playerPatterns)) {
        playerCount := ok.Length()
        for i, portrait in ok {
            centerY := portrait.y - 1
            healthX := portrait.x + 12
            ; Create red dot at health check position (must match DynamicHealthCheck exactly)
            dotX := CalculateHealthCheckX(healthX, healThresholdPercent)
            dotY := centerY - 3
            ; Debug: Show calculation
            offset := dotX - healthX
            UpdateHealerStatus("Player " . i . ": healthX=" . healthX . " + offset=" . Round(offset, 1) . " = dotX=" . Round(dotX, 1) . " (Threshold: " . healThresholdPercent . "%)")
            Gui, HealthDot%i%:New, +AlwaysOnTop -Caption +ToolWindow, HealthCheck
            Gui, HealthDot%i%:Color, Red
            Gui, HealthDot%i%:Show, x%dotX% y%dotY% w3 h9 NoActivate
            SetTimer, RemoveHealthDot%i%, -3000
        }
    }

    ; Find pet portraits and show health check dots
    if (ok := FindText(0, 0, searchX1, searchY1, searchX2, searchY2, 0, 0, petPatterns)) {
        petCount := ok.Length()
        for i, portrait in ok {
            centerY := portrait.y - 1
            healthX := portrait.x + 54
            ; Create blue dot at health check position (must match DynamicHealthCheck exactly)
            dotIndex := i + 10 ; Offset to avoid conflicts with player dots
            petDotX := healthX - 18
            petDotY := centerY - 3
            Gui, HealthDot%dotIndex%:New, +AlwaysOnTop -Caption +ToolWindow, PetHealthCheck
            Gui, HealthDot%dotIndex%:Color, Blue
            Gui, HealthDot%dotIndex%:Show, x%petDotX% y%petDotY% w3 h9 NoActivate
            SetTimer, RemoveHealthDot%dotIndex%, -3000
        }
    }

    UpdateHealerStatus("Detected: " . playerCount . " players, " . petCount . " pets - Heal threshold: " . healThresholdPercent . "% - Dots shown for 3 seconds")
}
autofollow:
    if (autofolloww)
    {
        autofolloww := false
        GuiControl,, StatusText, Status: Autofollow Disabled
    }
    else
    {
        autofolloww := true
        GuiControl,, StatusText, Status: Autofollow Enabled
    }
return

amimovingg:
    if (movingg)
    {
        movingg := false
        GuiControl,, StatusText, Status: Movement Detection Disabled
    }
    else
    {
        movingg := true
        GuiControl,, StatusText, Status: Movement Detection Enabled
    }
return
ValidateHealThreshold:
    Gui, Submit, NoHide
    if (HealThresholdInput < 1)
    {
        HealThresholdInput := 1
        GuiControl,, HealThresholdInput, 1
    }
    else if (HealThresholdInput > 100)
    {
        HealThresholdInput := 100
        GuiControl,, HealThresholdInput, 100
    }
return

SaveHealThreshold:
    Gui, Submit, NoHide
    Gosub, ValidateHealThreshold
    healThresholdPercent := HealThresholdInput
    SaveHealSettings()
    UpdateHealerStatus("Heal threshold set to " . healThresholdPercent . "% and saved to INI")
return

ValidateHealInterval:
    Gui, Submit, NoHide
    if (HealIntervalInput < 100)
    {
        HealIntervalInput := 100
        GuiControl,, HealIntervalInput, 100
    }
    else if (HealIntervalInput > 10000)
    {
        HealIntervalInput := 10000
        GuiControl,, HealIntervalInput, 10000
    }
return

SaveHealInterval:
    Gui, Submit, NoHide
    Gosub, ValidateHealInterval
    healCheckInterval := HealIntervalInput
    SaveHealSettings()
    UpdateHealerStatus("Heal check interval set to " . healCheckInterval . "ms and saved to INI")

    ; Update the timer if healing is active
    SetTimer, CheckHealth, Off
    SetTimer, DynamicHealthCheck, Off
    SetTimer, ManualHealthCheck, Off
    if (PlayerCoords.Length() > 0 || PetCoords.Length() > 0) {
        SetTimer, CheckHealth, %healCheckInterval%
        UpdateHealerStatus("Heal timer updated - now checking every " . healCheckInterval . "ms")
    }
    ; Also update DynamicHealthCheck timer if it's running
    SetTimer, DynamicHealthCheck, %healCheckInterval%
    ; Update manual healing timer if active
    if (isManualHealingActive) {
        SetTimer, ManualHealthCheck, %healCheckInterval%
    }
return
CheckForDeath() {
    global usegodmotherbottle, win1

    if (!win1 || win1 = "") {
        return false
    }

    ; Get window position
    WinGetPos, winX, winY,,, ahk_id %win1%

    if (winX = "" || winY = "") {
        return false
    }

    ; Search for death patterns across the entire window
    WinGetPos, winX, winY, winWidth, winHeight, ahk_id %win1%

    ; Search for the god mother bottle patterns (indicating death screen)
    deathPattern := FindText(0, 0, winX, winY, winX + winWidth, winY + winHeight, 0, 0, usegodmotherbottle)

    if (deathPattern) {
        return true
    }

return false
}

; Handle resurrection process
HandleResurrection() {
    global usegodmotherbottle, win1, CurrentResurrections, MaxResurrections
    global ResurrectionEnabled

    if (!ResurrectionEnabled) {
        return false
    }

    if (CurrentResurrections >= MaxResurrections) {
        UpdateResurrectionStatus("Max resurrections reached!")
        MsgBox, 0, Auto-Resurrection, Maximum number of resurrections (%MaxResurrections%) reached!, 3
        return false
    }

    ; Get window position
    WinGetPos, winX, winY,,, ahk_id %win1%

    if (winX = "" || winY = "") {
        return false
    }

    ; Search for and click the resurrection bottle
    WinGetPos, winX, winY, winWidth, winHeight, ahk_id %win1%
    deathPattern := FindText(0, 0, winX, winY, winX + winWidth, winY + winHeight, 0, 0, usegodmotherbottle)

    if (deathPattern && IsObject(deathPattern) && deathPattern.MaxIndex() >= 1) {
        ; Get click coordinates
        clickX := deathPattern.1.x
        clickY := deathPattern.1.y

        ; Validate coordinates
        if (clickX > 0 && clickY > 0 && clickX < A_ScreenWidth && clickY < A_ScreenHeight) {
            ; Use SendMessage to click - it handles coordinate conversion
            SendMessageClick(clickX, clickY, win1)
            Sleep, 500

            ; Increment counter
            CurrentResurrections++
            UpdateResurrectionStatus("Resurrected! " . CurrentResurrections . "/" . MaxResurrections)

            ; Log the resurrection
            ToolTip, Character Resurrected (%CurrentResurrections%/%MaxResurrections%), 10, 10, 4
            SetTimer, ClearResurrectionTooltip, -3000

            return true
        }
    }

return false
}

; Clear resurrection tooltip
ClearResurrectionTooltip:
    ToolTip, , , , 4
return
ChangeKeyDelay:
    SetRandomKeyDelay()
return
; Main death detection timer function
DeathDetectionTimer:
    global DeathCheckActive, ResurrectionEnabled

    if (!DeathCheckActive || !ResurrectionEnabled) {
        return
    }

    if (CheckForDeath()) {
        ; Character died - attempt resurrection
        if (HandleResurrection()) {
            ; Successfully resurrected
            Sleep, 2000 ; Wait a bit before next check
        } else {
            ; Failed to resurrect or max reached
            DeathCheckActive := false
            SetTimer, DeathDetectionTimer, Off
        }
    }
return

; Start death detection
StartDeathDetection() {
    global DeathCheckActive, ResurrectionEnabled

    if (!ResurrectionEnabled) {
        MsgBox, 0, Death Detection, Please enable auto-resurrection first!, 2
        return
    }

    DeathCheckActive := true
    SetTimer, DeathDetectionTimer, 3000 ; Check every 3 seconds
    ;MsgBox, 0, Death Detection, Death detection started!, 1
}

; Stop death detection
StopDeathDetection() {
    global DeathCheckActive

    DeathCheckActive := false
    SetTimer, DeathDetectionTimer, Off
    ;MsgBox, 0, Death Detection, Death detection stopped!, 1
}

; Update resurrection status display
UpdateResurrectionStatus(message) {
    GuiControl,, ResurrectionStatus, %message%
}

; =============================================================================
; GUI EVENT HANDLERS
; =============================================================================

; Handle resurrection checkbox
ResurrectionEnabled:
    GuiControlGet, ResurrectionEnabled

    if (ResurrectionEnabled) {
        ; Load current settings
        GuiControlGet, MaxResurrectionsEdit
        if (MaxResurrectionsEdit > 0) {
            MaxResurrections := MaxResurrectionsEdit
        } else {
            MaxResurrections := 8
            GuiControl,, MaxResurrectionsEdit, 8
        }
        UpdateResurrectionStatus("Enabled - " . CurrentResurrections . "/" . MaxResurrections)
        StartDeathDetection()
    } else {
        UpdateResurrectionStatus("Disabled")
        StopDeathDetection()
    }
return

; Save resurrection settings
SaveResurrectionSettings:
    GuiControlGet, MaxResurrectionsEdit

    if (MaxResurrectionsEdit > 0 && MaxResurrectionsEdit <= 99) {
        MaxResurrections := MaxResurrectionsEdit
        ; Save to INI file
        IniWrite, %MaxResurrections%, %iniFile%, Settings, MaxResurrections
        UpdateResurrectionStatus("Settings saved - " . CurrentResurrections . "/" . MaxResurrections)
        MsgBox, 0, Settings, Max resurrections set to %MaxResurrections% and saved!, 2
    } else {
        MsgBox, 0, Error, Please enter a valid number (1-99)!, 2
        GuiControl,, MaxResurrectionsEdit, %MaxResurrections%
    }
return

; Reset resurrection counter
ResetResurrections:
    CurrentResurrections := 0
    UpdateResurrectionStatus("Count reset - " . CurrentResurrections . "/" . MaxResurrections)
    MsgBox, 0, Reset, Resurrection count reset to 0!, 1
return

; Manual test death detection
TestDeathDetection:
    if (CheckForDeath()) {
        MsgBox, 0, Test, Death screen detected!
        if (HandleResurrection()) {
            MsgBox, 0, Test, Resurrection attempted!
        }
    } else {
        MsgBox, 0, Test, No death screen found.
    }
return

SelectWindow:
    MsgBox, Now right click on the game window 
    KeyWait, RButton, D
    MouseGetPos,,, selectedWindow
    WinGetTitle, title, ahk_id %selectedWindow%
    WinGet, pid, PID, ahk_id %selectedWindow%
    MsgBox, You have selected: %title% (PID: %pid%)
    WinMove, ahk_id %selectedWindow%, , 0, 0
    ; Set up for healing system
    FindText().BindWindow(selectedWindow)
    global TargetGameWindow := selectedWindow
    global TargetGameTitle := title
    global TargetGamePID := pid
    global windowWasClosed := false
    global win1 := selectedWindow
    ; Set up for navigation system
    global NavTargetGameWindow := selectedWindow
    global NavTargetGamePID := pid

    ; Handle camera file selection for both systems
    ; Check if there's a saved navigation camera file
    IniRead, savedNavCameraFile, navpathingsettings.ini, Settings, CameraFile, ERROR
    IniRead, savedMainCameraFile, pathingsettings.ini, Settings, CameraFile, ERROR

    selectedCameraFile := ""

    ; Prioritize navigation camera file, then main camera file
    if (savedNavCameraFile != "ERROR" && FileExist(savedNavCameraFile)) {
        MsgBox, 4,, Use previous navigation camera file?`n%savedNavCameraFile%
        IfMsgBox Yes
        {
            selectedCameraFile := savedNavCameraFile
        }
    }
    else if (savedMainCameraFile != "ERROR" && FileExist(savedMainCameraFile)) {
        MsgBox, 4,, Use previous camera file?`n%savedMainCameraFile%
        IfMsgBox Yes
        {
            selectedCameraFile := savedMainCameraFile
        }
    }

    ; If no saved file or user declined, ask for new file
    if (selectedCameraFile = "") {
        FileSelectFile, selectedCameraFile, 1,, Select Camera File, TXT Files (*.txt)
    }

    ; Apply camera file to both systems if selected
    if (selectedCameraFile != "") {
        ; Set up navigation camera
        NavCameraFile := selectedCameraFile
        LoadNavCameraSettings(NavCameraFile)
        GuiControl,, NavCameraFile, Camera: %NavCameraFile%
        GuiControl,, NavRadiusEdit, %NavCameraRadius%

        ; Set up main camera
        CameraFile := selectedCameraFile
        LoadCameraSettings(CameraFile)

        MsgBox, Camera file loaded for both systems: %selectedCameraFile%
        SaveNavSettings()
        SaveSettings()
    }
    ; Move the selected window to 0,0 (top-left corner of the screen)

    UpdateHealerStatus("Selected window: " . title)
    SaveGameWindowSettings()
    UpdateWindowStatusDisplay()
return

return
SelectWindow2:
    MsgBox, Now right click on the window 
    KeyWait, RButton, D
    MouseGetPos,,, win2
    WinGetTitle, title, ahk_id %win2%
    WinGet, pid, PID, ahk_id %win2%
    MsgBox, You have selected: %title%
    WinMove, ahk_id %win2%, , 0, 0

    ; Check if there's a saved camera file and ask user
    IniRead, savedCameraFile, navpathingsettings.ini, Settings, CameraFile, ERROR
    selectedCameraFile := ""

    if (savedCameraFile != "ERROR" && FileExist(savedCameraFile)) {
        MsgBox, 4,, Use previous camera file?`n%savedCameraFile%
        IfMsgBox Yes
        {
            selectedCameraFile := savedCameraFile
        }
        else
        {
            FileSelectFile, selectedCameraFile, 1,, Select Camera File, TXT Files (*.txt)
        }
    }
    else
    {
        FileSelectFile, selectedCameraFile, 1,, Select Camera File, TXT Files (*.txt)
    }

    if (selectedCameraFile != "") {
        NavCameraFile := selectedCameraFile
        LoadNavCameraSettings(NavCameraFile)
        GuiControl,, NavCameraFile, Camera: %NavCameraFile%
        GuiControl,, NavRadiusEdit, %NavCameraRadius%
        MsgBox, Camera file loaded: %NavCameraFile%
        SaveNavSettings()
    }
    ; Store the window ID globally for healing activation
    global TargetGameWindow := win2
    global TargetGameTitle := title
    global windowWasClosed := false ; Reset the flag when new window is selected
    global navwin1 := win1
    UpdateHealerStatus("Selected window: " . title)
return

SelectDPSWindow:
    MsgBox, Now right click on the game window for DPS.
        KeyWait, RButton, D
    MouseGetPos,,, win1
    WinGetTitle, title, ahk_id %win1%
    WinGet, pid, PID, ahk_id %win1%
    MsgBox, You have selected: %title%
    WinMove, ahk_id %win1%, , 0, 0

    ; Store the window ID globally for DPS activation
    global TargetGameWindow := win1
    global TargetGameTitle := title
    UpdateDPSStatus("Selected window: " . title)
return

InfiniteMouseMove:
    MouseGetPos, currentX, currentY
    distance := Sqrt((currentX-centerX)**2 + (currentY-centerY)**2)
    if (distance > 10) {
        Click Up Right
        MouseMove, centerX, centerY, 0
        Click Down Right
    }
return

StartDynamicHealing:
    ; Use win1 if TargetGameWindow is not set
    if (TargetGameWindow = "" && win1 != "") {
        TargetGameWindow := win1
    }

    if (TargetGameWindow = "" && win1 = "") {
        UpdateHealerStatus("Please select a target window first.")
        return
    }

    SetTimer, DynamicHealthCheck, %healCheckInterval%
    UpdateHealerStatus("Dynamic healing started - auto-detecting party members")
return

DynamicHealthCheck:
    ; Find the party window bar
    if (!(partyBar := FindText(0, 0, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, partywindow))) {
        return
    }

    ; Create search area: 15px left, 175px right, 430px down
    searchX1 := partyBar.1.x - 15
    searchY1 := partyBar.1.y
    searchX2 := partyBar.1.x + 175
    searchY2 := partyBar.1.y + 430

    playerPatterns := magus . "|" . Corruptor . "|" . voidmage . "|" . deadeye . "|" . beastmaster . "|" . slayer . "|" . berserker . "|" . overlord . "|" . masterbreeder . "|" . Marksman
    petPatterns := windpixie . "|" . gnoll . "|" . etherealpixie

    ; Check players in party area
    if (ok := FindText(0, 0, searchX1, searchY1, searchX2, searchY2, 0, 0, playerinparty)) {
        for i, portrait in ok {
            centerY := portrait.y - 1
            healthX := portrait.x + 12

            ; Look for full health bar (green)
            healthFull := "|<>##0.90$0/0/24690C,0/1/00AA90,0/2/006655,0/3/3ED514"
            checkX := CalculateHealthCheckX(healthX, healThresholdPercent)
            checkY := centerY - 3
            ; Search in a small area (3x9 pixels) matching the red dot size exactly
            healthFullFound := FindText(0, 0, checkX, checkY, checkX + 3, checkY + 9, 0, 0, healthFull)
            if (!healthFullFound) {
                ; FIXED: Add coordinate validation before clicking
                clickX := portrait.x + 9
                clickY := centerY

                ; Validate coordinates before clicking
                if (clickX > 0 && clickY > 0 && clickX < A_ScreenWidth && clickY < A_ScreenHeight) {
                    ;ToolTip, Dynamic Player Click at %clickX%`, %clickY%, , , 3
                    SendMessageClick(clickX, clickY)
                    TryCastHealingSkill()
                    Sleep, 25
                } else {
                    ;UpdateHealerStatus("⚠ Invalid dynamic player click coordinates: " . clickX . "," . clickY)
                }
            }
        }
    }

    ; Check pets in party area
    if (ok := FindText(0, 0, searchX1, searchY1, searchX2, searchY2, 0, 0, petsinparty)) {
        for i, portrait in ok {
            centerY := portrait.y - 1
            healthX := portrait.x + 54

            ; Look for full health bar (green)
            healthFull := "|<>##0.90$0/0/24690C,0/1/00AA90,0/2/006655,0/3/3ED514"
            checkX := healthX - 18
            checkY := centerY - 3
            ; Search in a small area (3x9 pixels) matching the blue dot size exactly
            healthFullFound := FindText(0, 0, checkX, checkY, checkX + 3, checkY + 9, 0, 0, healthFull)
            if (!healthFullFound) {
                ; FIXED: Add coordinate validation before clicking
                clickX := portrait.x + 9
                clickY := centerY

                ; Validate coordinates before clicking
                if (clickX > 0 && clickY > 0 && clickX < A_ScreenWidth && clickY < A_ScreenHeight) {
                    ;;;;;ToolTip, Dynamic Pet Click at %clickX%`, %clickY%, , , 4
                    SendMessageClick(clickX, clickY)
                    TryCastHealingSkill()
                    Sleep, 25
                } else {
                    ;UpdateHealerStatus("⚠ Invalid dynamic pet click coordinates: " . clickX . "," . clickY)
                }
            }
        }
    }
return

CancelHealerScript:
    SetTimer, CheckHealth, Off
    SetTimer, UpdateBoundingBoxes, Off
    SetTimer, DynamicHealthCheck, Off
    SetTimer, ManualHealthCheck, Off
    ClearBoundingBoxes()
    isManualHealingActive := false
    UpdateHealerStatus("All healer scripts stopped.")
return

clearskills:
    InputBox, patternToClear, Clear Heal Pattern, Enter the name of the heal pattern to clear (leave empty to clear all):, , 300, 130
    if (ErrorLevel)
        return

    if (patternToClear = "") {
        ; Clear only heal patterns
        healPatternsToDelete := []
        for patternName, patternText in patterns {
            if (SubStr(patternName, 1, 4) = "heal") {
                healPatternsToDelete.Push(patternName)
            }
        }

        for index, patternName in healPatternsToDelete {
            patterns.Delete(patternName)
            patternKeys.Delete(patternName)
            patternNames.Delete(patternName)
            IniDelete, %iniFile%, Patterns, %patternName%
            IniDelete, %iniFile%, PatternKeys, %patternName%
            IniDelete, %iniFile%, PatternNames, %patternName%
        }

        healPriorities := []
        IniDelete, %iniFile%, HealPriorities
        patternCounter := 1
        RefreshHealPriorityList()
        UpdateHealerStatus("All heal patterns have been cleared.")
    } else {
        ; Check both pattern name and custom name
        patternToDelete := ""
        for healPat, healText in patterns {
            if (SubStr(healPat, 1, 4) = "heal") {
                displayName := GetDisplayName(healPat)
                if (healPat = patternToClear || displayName = patternToClear) {
                    patternToDelete := healPat
                    break
                }
            }
        }

        if (patternToDelete != "") {
            patterns.Delete(patternToDelete)
            patternKeys.Delete(patternToDelete)
            patternNames.Delete(patternToDelete)

            ; Remove from priority list
            for index, priorityPattern in healPriorities {
                if (priorityPattern = patternToDelete) {
                    healPriorities.RemoveAt(index)
                    break
                }
            }

            IniDelete, %iniFile%, Patterns, %patternToDelete%
            IniDelete, %iniFile%, PatternKeys, %patternToDelete%
            IniDelete, %iniFile%, PatternNames, %patternToDelete%
            SaveHealPriorities()
            RefreshHealPriorityList()
            UpdateHealerStatus("Heal pattern '" . patternToClear . "' has been cleared.")
        } else {
            UpdateHealerStatus("Heal pattern '" . patternToClear . "' not found.")
        }
    }
return

findhealingskill:
    if (patterns.Count() = 0) {
        UpdateHealerStatus("No healing skills captured. Add some skills first.")
        return
    }

    UpdateHealerStatus("Testing healing skills - searching for patterns on screen...")

    foundCount := 0
    totalCount := 0

    ; Test each heal pattern
    for patternName, patternText in patterns {
        if (SubStr(patternName, 1, 4) = "heal") {
            totalCount++
            displayName := GetDisplayName(patternName)

            ; Search in the skill bar area - convert window-relative to screen coordinates
            WinGetPos, winX, winY,,, ahk_id %win1%
            screenX1 := winX + SkillBarX1
            screenY1 := winY + SkillBarY1
            screenX2 := winX + SkillBarX2
            screenY2 := winY + SkillBarY2
            if (ok := FindText(X, Y, screenX1, screenY1, screenX2, screenY2, 0, 0, patternText)) {
                foundCount++
                UpdateHealerStatus("✓ FOUND: " . displayName . " at coordinates: " . X . ", " . Y)

                ; Highlight the found skill
                Try {
                    For i, v in ok {
                        if (i <= 2)
                            FindText().MouseTip(ok[i].x, ok[i].y)
                    }
                }
            } else {
                UpdateHealerStatus("✗ Not found: " . displayName)
            }
        }
    }

    UpdateHealerStatus("Test complete - Found " . foundCount . " out of " . totalCount . " healing skills on screen.")
return

AddHealingSkill:
    UpdateHealerStatus("Hover your mouse over the healing skill and press 1 to capture it")
    KeyWait, 1, D
    capturedText := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)
    Clipboard := capturedText
    patternName := "heal" . patternCounter

    ; Prompt for custom name and key assignment
    InputBox, customName, Name Healing Skill, Enter a name for this healing skill:, , 300, 130, , , , , %patternName%
        if (ErrorLevel)
        return

    if (customName = "")
        customName := patternName

    ; Ask if need to press key before cast
    MsgBox, 4, Press Key Before Cast?, Do you need to press a DIFFERENT key BEFORE the main skill key?`n`n(Example: Press Tab to swap weapon bar, then press the skill key)
    IfMsgBox, Yes
    {
        needsPreCastKey := true
        InputBox, preCastKey, Pre-Cast Key, Enter the key to press BEFORE the main skill key (e.g. Tab):, , 350, 150
        if (ErrorLevel)
            preCastKey := ""
    }
    IfMsgBox, No
    {
        needsPreCastKey := false
        preCastKey := ""
    }

    InputBox, assignedKey, Assign Key, Enter a key for this skill (leave empty to click with mouse):, , 300, 130
        if (ErrorLevel)
        return

    ; Ask if ground-targeted skill
    MsgBox, 4, Ground Target Skill?, Is this a ground-targeted skill that requires clicking a location AFTER the key is pressed?
    IfMsgBox, Yes
    {
        isGroundTarget := true
        MsgBox, 0, Right-Click to Set Location, Right-click on the location where the skill should be cast.`n`nPress OK first, then right-click the location.
        UpdateHealerStatus("Waiting for right-click to set ground target location...")
        KeyWait, RButton, D
        MouseGetPos, groundX, groundY
        ; Convert screen coords to window-relative coords for saving
        WinGetPos, winX, winY,,, ahk_id %win1%
        groundX := groundX - winX
        groundY := groundY - winY
        UpdateHealerStatus("Ground target location set (relative): " . groundX . ", " . groundY)
    }
    IfMsgBox, No
    {
        isGroundTarget := false
        groundX := ""
        groundY := ""
    }

    ; Save pattern with key, custom name, ground target info, and pre-cast key info
    SavePattern(patternName, capturedText, assignedKey, isGroundTarget, groundX, groundY, needsPreCastKey, preCastKey)
    SavePatternName(patternName, customName)

    UpdateHealerStatus("Healing skill captured and saved as '" . customName . "' [" . patternName . "]")
    patternCounter++

    ; Add to priority list at the end
    healPriorities.Push(patternName)
    SaveHealPriorities()
    RefreshHealSkillsList()
    RefreshHealPriorityList()
Return

CaptureCoordinates() {
    global PlayerCount, PetCount, PlayerCoords, PetCoords, partywindowlogo

    ; Find party window logo first
    if (!FindText(logoX, logoY, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, partywindowlogo)) {
        MsgBox, 16, Error, Party window logo not found! Make sure the party window is visible.
        return
    }

    PlayerCoords := []
    PetCoords := []
    ClearBoundingBoxes()

    MsgBox, 0, Coordinate Capture, Please click on the center of each player character (total: %PlayerCount%).`n`nPress F12 to cancel.

    Loop, %PlayerCount% {
        currentPlayer := A_Index
        ToolTip, Click on the center of Player %currentPlayer%, 100, 100

        KeyWait, LButton, D
        MouseGetPos, PlayerCenterX, PlayerCenterY

        ; Calculate relative position to party window logo
        relativeX := PlayerCenterX - logoX
        relativeY := PlayerCenterY - logoY

        PlayerCoords.Push({RelativeX: relativeX, RelativeY: relativeY})

        ; Draw rectangle at current position for visual feedback
        PlayerX1 := PlayerCenterX - 2
        PlayerX2 := PlayerCenterX + 3
        PlayerY1 := PlayerCenterY - 12
        PlayerY2 := PlayerCenterY + 13
        DrawHollowRectangle(PlayerX1, PlayerY1, PlayerX2, PlayerY2, "Player" . currentPlayer, "00FF00", "FFFF00")

        KeyWait, LButton
        Sleep, 500
    }

    ToolTip

    if (PetCount > 0) {
        MsgBox, 0, Coordinate Capture, Now please click on the center of each pet (total: %PetCount%).`n`nPress F12 to cancel.

        Loop, %PetCount% {
            currentPet := A_Index
            ToolTip, Click on the center of Pet %currentPet%, 100, 100

            KeyWait, LButton, D
            MouseGetPos, PetCenterX, PetCenterY

            ; Calculate relative position to party window logo
            relativeX := PetCenterX - logoX
            relativeY := PetCenterY - logoY

            PetCoords.Push({RelativeX: relativeX, RelativeY: relativeY})

            ; Draw rectangle at current position for visual feedback
            PetX1 := PetCenterX - 2
            PetX2 := PetCenterX + 3
            PetY1 := PetCenterY - 12
            PetY2 := PetCenterY + 13
            DrawHollowRectangle(PetX1, PetY1, PetX2, PetY2, "Pet" . currentPet, "0000FF", "FF00FF")

            KeyWait, LButton
            Sleep, 500
        }
    }

    ToolTip

    summaryText := "Captured coordinates for " . PlayerCount . " players and " . PetCount . " pets relative to party window.`n`n"
    summaryText .= "Player coordinates (relative to logo):`n"
    For index, coords in PlayerCoords {
        summaryText .= "Player " . index . ": Offset(" . coords.RelativeX . "," . coords.RelativeY . ")`n"
    }

    if (PetCount > 0) {
        summaryText .= "`nPet coordinates (relative to logo):`n"
        For index, coords in PetCoords {
            summaryText .= "Pet " . index . ": Offset(" . coords.RelativeX . "," . coords.RelativeY . ")`n"
        }
    }

    summaryText .= "`nPress F12 to clear all bounding boxes.`nDo you want to start monitoring these areas?"

    MsgBox, 4, Coordinates Captured, %summaryText%
    IfMsgBox Yes
    {
        StartMonitoring()
    }
}

StartMonitoring() {
    global PlayerCoords, PetCoords, HealthPattern, healCheckInterval
    SetTimer, CheckHealth, %healCheckInterval%
    SetTimer, UpdateBoundingBoxes, 2000
    UpdateHealerStatus("Health monitoring started - checking every " . healCheckInterval . "ms")
return
}

UpdateBoundingBoxes:
    global PlayerCoords, PetCoords, partywindowlogo, BoundingBoxes, lastLogoX, lastLogoY

    if (!FindText(logoX, logoY, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, partywindowlogo))
        return

    ; Only update if logo position changed
    if (logoX = lastLogoX && logoY = lastLogoY)
        return

    lastLogoX := logoX
    lastLogoY := logoY

    ClearBoundingBoxes()

    For index, coords in PlayerCoords {
        currentX := logoX + coords.RelativeX
        currentY := logoY + coords.RelativeY
        PlayerX1 := currentX - 2
        PlayerX2 := currentX + 3
        PlayerY1 := currentY - 4
        PlayerY2 := currentY + 5
        DrawHollowRectangle(PlayerX1, PlayerY1, PlayerX2, PlayerY2, "Player" . index, "00FF00", "FFFF00")
    }

    For index, coords in PetCoords {
        currentX := logoX + coords.RelativeX
        currentY := logoY + coords.RelativeY
        PetX1 := currentX - 2
        PetX2 := currentX + 3
        PetY1 := currentY - 4
        PetY2 := currentY + 5
        DrawHollowRectangle(PetX1, PetY1, PetX2, PetY2, "Pet" . index, "0000FF", "FF00FF")
    }
return

CheckHealth:
CheckHealthMain:
    ; Check if Critical mode is enabled
    if (CriticalModeEnabled) {
        return
    }
    global partywindowlogo

    ; Find current party window logo position
    if (!FindText(logoX, logoY, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, partywindowlogo)) {
        UpdateHealerStatus("Party window not found - healing paused")
        return
    }

    For index, coords in PlayerCoords {
        ; Calculate current position based on logo position
        currentX := logoX + coords.RelativeX
        currentY := logoY + coords.RelativeY

        ; Create health check area around current position
        PlayerX1 := currentX - 2
        PlayerX2 := currentX + 3
        PlayerY1 := currentY - 4
        PlayerY2 := currentY + 5

        healthpresent := "|<>##0.90$0/0/24690C,0/1/00AA90,0/2/006655,0/3/3ED514"
        ok := FindText(0, 0, PlayerX1, PlayerY1, PlayerX2, PlayerY2, 0, 0, healthpresent)

        if (!ok) {
            if (PlayerCount > 1 || PetCount > 0) {
                Loop 5 {
                    SendMessageClick(currentX, currentY)
                    Sleep, 20
                } 
            }
            healResult := TryCastHealingSkill()
            if (healResult) {
                UpdateHealerStatus("→ Healed Player " . index)
            } else {
                UpdateHealerStatus("Targeted Player " . index . " but no healing skill available")
            }
            Sleep, 25
        }
    }

    For index, coords in PetCoords {
        ; Calculate current position based on logo position
        currentX := logoX + coords.RelativeX
        currentY := logoY + coords.RelativeY

        ; Create health check area around current position
        PetX1 := currentX - 2
        PetX2 := currentX + 3
        PetY1 := currentY - 4
        PetY2 := currentY + 5

        healthpresent := "|<>##0.90$0/0/24690C,0/1/00AA90,0/2/006655,0/3/3ED514"
        ok := FindText(0, 0, PetX1, PetY1, PetX2, PetY2, 0, 0, healthpresent)

        if (!ok) {
            Loop 5 {
                SendMessageClick(currentX, currentY)
                Sleep, 20
            }
            Sleep, 25
            healResult := TryCastHealingSkill()
            if (healResult) {
                UpdateHealerStatus("→ Healed Pet " . index)
            } else {
                UpdateHealerStatus("Targeted Pet " . index . " but no healing skill available")
            }
            Sleep, 25
        }
    }
return

TryCastHealingSkill() {
    global patterns, patternKeys, healPriorities, partywindowlogo
    global SkillBarX1, SkillBarY1, SkillBarX2, SkillBarY2
    global TargetGameWindow, TargetGameTitle
    global healGroundTargetSkills, healGroundTargetCoords
    global healPressKeyBeforeCast, healPreCastKeys

    ; Find current party window logo position for skill bar search
    if (!FindText(logoX, logoY, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, partywindowlogo)) {
        ;UpdateHealerStatus("Party window not found - cannot cast healing skills")
        return false
    }

    ; Go through heal priority order
    for index, priorityPattern in healPriorities {
        if (!patterns.HasKey(priorityPattern) || SubStr(priorityPattern, 1, 4) != "heal")
            continue

        patternText := patterns[priorityPattern]

        ; Convert window-relative coords to screen coords
        WinGetPos, winX, winY,,, ahk_id %win1%

        ; Validate window position first
        if (winX = "" || winY = "" || winX < 0 || winY < 0) {
            ;UpdateHealerStatus("⚠ Invalid window position detected - skipping heal cycle")
            return false
        }

        screenX1 := winX + SkillBarX1
        screenY1 := winY + SkillBarY1
        screenX2 := winX + SkillBarX2
        screenY2 := winY + SkillBarY2

        ; For 4K monitors, search the entire screen width but constrain to skill bar height
        ; This ensures skills on left side are found even if coordinates are slightly off
        healingSkill := FindText(X, Y, 0, screenY1, A_ScreenWidth, screenY2, 0, 0, patternText)

        if (healingSkill) {
            displayName := GetDisplayName(priorityPattern)

            ; Show both ID and custom name if different
            healInfo := (displayName != priorityPattern) ? priorityPattern . " = " . displayName : priorityPattern

            ; Spam protection
            spamCount := 0
            maxSpam := 3
            success := false
            skillCastSuccessfully := false

            Loop {
                spamCount++

                ; Press pre-cast key if needed (only on first spam attempt)
                if (spamCount = 1 && healPressKeyBeforeCast.HasKey(priorityPattern) && (healPressKeyBeforeCast[priorityPattern] = true || healPressKeyBeforeCast[priorityPattern] = "1" || healPressKeyBeforeCast[priorityPattern] = "true") && healPreCastKeys.HasKey(priorityPattern) && healPreCastKeys[priorityPattern] != "") {
                    preCastKey := healPreCastKeys[priorityPattern]
                    ControlSend,, {%preCastKey% down}, ahk_id %win1%
                    Sleep, 25
                    ControlSend,, {%preCastKey% up}, ahk_id %win1%
                    Sleep, 150
                }

                if (patternKeys.HasKey(priorityPattern) && patternKeys[priorityPattern] != "") {
                    assignedKey := patternKeys[priorityPattern]

                    ; Check for modifier keys
                    hasCtrl := InStr(assignedKey, "^")
                    hasAlt := InStr(assignedKey, "!")
                    hasShift := InStr(assignedKey, "+")

                    ; Extract base key
                    baseKey := StrReplace(assignedKey, "^", "")
                    baseKey := StrReplace(baseKey, "!", "")
                    baseKey := StrReplace(baseKey, "+", "")

                    ; Apply QWERTZ conversion if enabled
                    baseKey := ConvertQwertyToQwertz(baseKey)

                    ; Send modifiers down
                    if (hasCtrl)
                        ControlSend,, {Ctrl down}, ahk_id %win1%
                    if (hasAlt)
                        ControlSend,, {Alt down}, ahk_id %win1%
                    if (hasShift)
                        ControlSend,, {Shift down}, ahk_id %win1%
                    Sleep, 25

                    ; Send base key
                    ControlSend,, {%baseKey% down}, ahk_id %win1%
                    Sleep, 25
                    ControlSend,, {%baseKey% up}, ahk_id %win1%
                    Sleep, 25

                    ; Release modifiers
                    if (hasShift)
                        ControlSend,, {Shift up}, ahk_id %win1%
                    if (hasAlt)
                        ControlSend,, {Alt up}, ahk_id %win1%
                    if (hasCtrl)
                        ControlSend,, {Ctrl up}, ahk_id %win1%
                    Sleep, 25

                    skillCastSuccessfully := true

                } else {
                    ; FIXED: Add coordinate validation before clicking
                    if (IsObject(healingSkill) && healingSkill.MaxIndex() >= 1) {
                        X := healingSkill.1.x
                        Y := healingSkill.1.y

                        ; Validate coordinates before clicking
                        if (X > 0 && Y > 0 && X < A_ScreenWidth && Y < A_ScreenHeight) {
                            ToolTip, Heal Click at %X%`, %Y%, , , 2
                            SendMessageClick(X, Y)
                            Sleep, 25
                            skillCastSuccessfully := true
                        } else {
                            ;UpdateHealerStatus("⚠ Invalid heal coordinates: " . X . "," . Y . " - skipping click")
                            break ; Exit the spam loop for this skill
                        }
                    } else {
                        ;UpdateHealerStatus("⚠ No heal coords available, skipping click.")
                        break
                    }
                }

                ; Debug: Show ground target status
                ; if (spamCount = 1) {
                ;     hasKey := healGroundTargetSkills.HasKey(priorityPattern)
                ;     isEnabled := (healGroundTargetSkills[priorityPattern] = true || healGroundTargetSkills[priorityPattern] = "1" || healGroundTargetSkills[priorityPattern] = "true")
                ;     hasCoords := healGroundTargetCoords.HasKey(priorityPattern)
                ;     ToolTip, GT Debug: hasKey=%hasKey% isEnabled=%isEnabled% hasCoords=%hasCoords% cast=%skillCastSuccessfully%, , , 4
                ;     SetTimer, RemoveToolTip4, 3000
                ; }

                ; Handle ground targeting if enabled (only on first spam attempt)
                if (spamCount = 1 && skillCastSuccessfully && healGroundTargetSkills.HasKey(priorityPattern) && (healGroundTargetSkills[priorityPattern] = true || healGroundTargetSkills[priorityPattern] = "1" || healGroundTargetSkills[priorityPattern] = "true") && healGroundTargetCoords.HasKey(priorityPattern)) {
                    Sleep, 150
                    groundCoords := healGroundTargetCoords[priorityPattern]
                    ; Add randomization to coordinates (±20 pixels)
                    Random, randX, -20, 20
                    Random, randY, -20, 20
                    relX := groundCoords.x + randX
                    relY := groundCoords.y + randY
                    ToolTip, Ground Target Click: %relX%`, %relY%, , , 3
                    SetTimer, RemoveToolTip3, 2000
                    ; Move mouse to ground target location
                    lParamMove := (relY << 16) | (relX & 0xFFFF)
                    SendMessage, 0x200, 0, lParamMove,, ahk_id %win1% ; WM_MOUSEMOVE
                    Sleep, 50
                    ; Click at ground target location
                    lParam := (relY << 16) | (relX & 0xFFFF)
                    SendMessage, 0x201, 0x0001, lParam,, ahk_id %win1% ; WM_LBUTTONDOWN
                    Sleep, 50
                    SendMessage, 0x202, 0, lParam,, ahk_id %win1% ; WM_LBUTTONUP
                    Sleep, 100
                }

                ; Recheck availability (search full screen width for 4K monitors)
                Sleep, 125
                healingSkill := FindText(X, Y, 0, screenY1, A_ScreenWidth, screenY2, 0, 0, patternText)

                if (!healingSkill) {
                    success := true
                    break
                }

                if (spamCount >= maxSpam) {
                    break
                }

                ; Optional: return to main character after heal
                if (returnafterheal = true) {
                    if (Templarok := FindText(0, 0, searchX1, searchY1, searchX2, searchY2, 0, 0, Templar)) {
                        ReturnToMainCharacter()
                    }
                }
            }

            ; Post-spam status
            if (!success) {
                ;UpdateHealerStatus("⚠ Heal pattern did not disappear after " . spamCount . " attempts, skipping.")
            } else {
                method := (patternKeys.HasKey(priorityPattern) && patternKeys[priorityPattern] != "") 
                ? "key: " . patternKeys[priorityPattern] 
                : "clicking"
                    ;UpdateHealerStatus("Used heal " . healInfo . " with " . method . " (" . spamCount . "x)")
                }

                SendMeleeAttack() ; Send melee attack after successful heal skill cast
                return true
            }
        }

        ;UpdateHealerStatus("No healing skills were found on screen.")
        return false
    }
    return

    DrawHollowRectangle(X1, Y1, X2, Y2, Name, BoxColor, IndicatorColor) {
        global BoundingBoxes

        Width := X2 - X1 + 1
        Height := Y2 - Y1 + 1

        IndicatorWidth := Width + 10
        IndicatorHeight := Height + 10
        IndicatorX1 := X1 - 5
        IndicatorY1 := Y1 - 5
        IndicatorX2 := IndicatorX1 + IndicatorWidth - 1
        IndicatorY2 := IndicatorY1 + IndicatorHeight - 1

        IndTopName := "IndTop" . A_Now . A_MSec
        Gui, %IndTopName%:New, +AlwaysOnTop -MaximizeBox -MinimizeBox +LastFound +ToolWindow -Caption, %Name%_IndTop
        Gui, %IndTopName%:Color, %IndicatorColor%
        WinSet, Transparent, 200
        Gui, %IndTopName%:Show, x%IndicatorX1% y%IndicatorY1% w%IndicatorWidth% h1 NoActivate
        BoundingBoxes.Push({hwnd: WinExist(), name: IndTopName})

        IndBottomName := "IndBottom" . A_Now . A_MSec
        Gui, %IndBottomName%:New, +AlwaysOnTop -MaximizeBox -MinimizeBox +LastFound +ToolWindow -Caption, %Name%_IndBottom
        Gui, %IndBottomName%:Color, %IndicatorColor%
        WinSet, Transparent, 200
        Gui, %IndBottomName%:Show, x%IndicatorX1% y%IndicatorY2% w%IndicatorWidth% h1 NoActivate
        BoundingBoxes.Push({hwnd: WinExist(), name: IndBottomName})

        IndLeftName := "IndLeft" . A_Now . A_MSec
        Gui, %IndLeftName%:New, +AlwaysOnTop -MaximizeBox -MinimizeBox +LastFound +ToolWindow -Caption, %Name%_IndLeft
        Gui, %IndLeftName%:Color, %IndicatorColor%
        WinSet, Transparent, 200
        Gui, %IndLeftName%:Show, x%IndicatorX1% y%IndicatorY1% w1 h%IndicatorHeight% NoActivate
        BoundingBoxes.Push({hwnd: WinExist(), name: IndLeftName})

        IndRightName := "IndRight" . A_Now . A_MSec
        Gui, %IndRightName%:New, +AlwaysOnTop -MaximizeBox -MinimizeBox +LastFound +ToolWindow -Caption, %Name%_IndRight
        Gui, %IndRightName%:Color, %IndicatorColor%
        WinSet, Transparent, 200
        Gui, %IndRightName%:Show, x%IndicatorX2% y%IndicatorY1% w1 h%IndicatorHeight% NoActivate
        BoundingBoxes.Push({hwnd: WinExist(), name: IndRightName})
    }

    ClearBoundingBoxes() {
        global BoundingBoxes

        for index, boxInfo in BoundingBoxes {
            Gui, % boxInfo.name . ":Destroy"
        }
        BoundingBoxes := []
    }

    RemoveToolTip:
        ToolTip
    return

    RemoveToolTip3:
        ToolTip, , , , 3
    return

    RemoveToolTip4:
        ToolTip, , , , 4
    return

    InitializePatternCounter() {
        highestNumber := 0

        for patternName, patternValue in patterns {
            if (SubStr(patternName, 1, 4) = "heal") {
                numberPart := SubStr(patternName, 5)
                if numberPart is integer
                {
                    if (numberPart > highestNumber)
                        highestNumber := numberPart
                }
            }
        }

        patternCounter := highestNumber + 1
    }

    SavePattern(patternName, patternText, keyAssignment, isGroundTarget := false, groundX := "", groundY := "", needsPreCastKey := false, preCastKey := "") {
        global iniFile, patterns, patternKeys, healGroundTargetSkills, healGroundTargetCoords, healPressKeyBeforeCast, healPreCastKeys

        FileEncoding, UTF-8
        IniWrite, %patternText%, %iniFile%, Patterns, %patternName%
        IniWrite, %keyAssignment%, %iniFile%, PatternKeys, %patternName%

        ; Save ground target settings
        IniWrite, %isGroundTarget%, %iniFile%, HealGroundTarget, %patternName%
        if (isGroundTarget && groundX != "" && groundY != "") {
            coordString := groundX . "," . groundY
            IniWrite, %coordString%, %iniFile%, HealGroundCoords, %patternName%
        }

        ; Save pre-cast key settings
        IniWrite, %needsPreCastKey%, %iniFile%, HealPreCastEnabled, %patternName%
        if (needsPreCastKey && preCastKey != "") {
            IniWrite, %preCastKey%, %iniFile%, HealPreCastKeys, %patternName%
        }
        FileEncoding

        patterns[patternName] := patternText
        patternKeys[patternName] := keyAssignment
        healGroundTargetSkills[patternName] := isGroundTarget
        if (isGroundTarget && groundX != "" && groundY != "") {
            healGroundTargetCoords[patternName] := {x: groundX, y: groundY}
        }
        healPressKeyBeforeCast[patternName] := needsPreCastKey
        if (needsPreCastKey && preCastKey != "") {
            healPreCastKeys[patternName] := preCastKey
        }
    }

    ; Save pet buff patterns to INI file
    SavePetBuffPatterns() {
        global iniFile, gnollPatterns, deathTyrantPatterns

        FileEncoding, UTF-8

        ; Delete existing sections first to avoid stale data
        IniDelete, %iniFile%, GnollPatterns
        IniDelete, %iniFile%, DeathTyrantPatterns

        ; Save gnoll patterns
        for index, pattern in gnollPatterns {
            keyName := "Pattern" . index
            IniWrite, %pattern%, %iniFile%, GnollPatterns, %keyName%
        }

        ; Save death tyrant patterns
        for index, pattern in deathTyrantPatterns {
            keyName := "Pattern" . index
            IniWrite, %pattern%, %iniFile%, DeathTyrantPatterns, %keyName%
        }

        FileEncoding
    }

    ; Save pet buff timer intervals to INI file
    SavePetBuffTimers() {
        global iniFile, gnollBuffInterval, dtBuffInterval

        FileEncoding, UTF-8
        IniWrite, %gnollBuffInterval%, %iniFile%, PetBuffTimers, GnollInterval
        IniWrite, %dtBuffInterval%, %iniFile%, PetBuffTimers, DTInterval
        FileEncoding
    }

    ; Load pet buff timer intervals from INI file
    LoadPetBuffTimers() {
        global iniFile, gnollBuffInterval, dtBuffInterval

        ; Load gnoll interval (default 30 minutes = 1800000 ms)
        IniRead, loadedGnollInterval, %iniFile%, PetBuffTimers, GnollInterval, 1800000
        if (loadedGnollInterval >= 60000 && loadedGnollInterval <= 59940000) { ; 1 min to 999 min
            gnollBuffInterval := loadedGnollInterval
        }

        ; Load DT interval (default 60 minutes = 3600000 ms)
        IniRead, loadedDTInterval, %iniFile%, PetBuffTimers, DTInterval, 3600000
        if (loadedDTInterval >= 60000 && loadedDTInterval <= 59940000) { ; 1 min to 999 min
            dtBuffInterval := loadedDTInterval
        }
    }

    ; Update pet buff checkbox labels with current timer values
    UpdatePetBuffLabels() {
        global gnollBuffInterval, dtBuffInterval

        ; Calculate minutes from milliseconds
        gnollMins := Round(gnollBuffInterval / 60000)
        dtMins := Round(dtBuffInterval / 60000)

        ; Update the checkbox labels on the main GUI
        Gui, 1:Default
        GuiControl,, gnollbuff, Enable Gnoll Buff (%gnollMins% mins)
        GuiControl,, dtbuff, Enable Death Tyrant Buff (%dtMins% mins)
    }

    ; Load auto-dura settings from INI file
    LoadAutoDuraSettings() {
        global SettingsFile, autoDuraInterval

        ; Load interval (default 30 minutes)
        IniRead, loadedInterval, %SettingsFile%, AutoDura, Interval, 30
        if (loadedInterval >= 1 && loadedInterval <= 999) {
            autoDuraInterval := loadedInterval
        }

        ; Update GUI control
        GuiControl,, autoDuraIntervalEdit, %autoDuraInterval%
    }

    ; Load pet buff patterns from INI file
    LoadPetBuffPatterns() {
        global iniFile, gnollPatterns, deathTyrantPatterns

        ; Initialize with default patterns if arrays are empty
        defaultGnollPattern := "|<>9E9F85-0.66$32.nzsPGAzy4xbTwzTNrzaBkxyw0k6TC6Nhj270u3H74T4y237yNk1Xz6w0Fzxj08TyEw47zAj23zznk0ztyM0TzLk07zsTU1zysTUT7c"
        defaultDTPattern1 := "|<>E5A657-0.52$19.rTszTwPjz5vzurzVv0sTUxD0ya2ML0CHCDDj3azW0Tk0hk1bU1rk0nw0vDsxwzWk1z0000001"
        defaultDTPattern2 := "|<>*94$16.QbRbnqTiNvz7rwjznTrSztwTbwuTzfzrBzwDzkTzU"

        gnollPatterns := []
        deathTyrantPatterns := []

        ; Load gnoll patterns
        IniRead, gnollPatternSection, %iniFile%, GnollPatterns
        if (gnollPatternSection != "ERROR" && gnollPatternSection != "") {
            Loop, Parse, gnollPatternSection, `n
            {
                if (A_LoopField != "") {
                    equalsPos := InStr(A_LoopField, "=")
                    if (equalsPos > 0) {
                        patternText := SubStr(A_LoopField, equalsPos + 1)
                        gnollPatterns.Push(patternText)
                    }
                }
            }
        }

        ; If no patterns loaded, add default
        if (gnollPatterns.Length() = 0) {
            gnollPatterns.Push(defaultGnollPattern)
        }

        ; Load death tyrant patterns
        IniRead, dtPatternSection, %iniFile%, DeathTyrantPatterns
        if (dtPatternSection != "ERROR" && dtPatternSection != "") {
            Loop, Parse, dtPatternSection, `n
            {
                if (A_LoopField != "") {
                    equalsPos := InStr(A_LoopField, "=")
                    if (equalsPos > 0) {
                        patternText := SubStr(A_LoopField, equalsPos + 1)
                        deathTyrantPatterns.Push(patternText)
                    }
                }
            }
        }

        ; If no patterns loaded, add defaults
        if (deathTyrantPatterns.Length() = 0) {
            deathTyrantPatterns.Push(defaultDTPattern1)
            deathTyrantPatterns.Push(defaultDTPattern2)
        }
    }

    GetPattern(patternName) {
        if (patterns.HasKey(patternName))
            return patterns[patternName]
    return ""
}

LoadPattern(patternName) {
    IniRead, loadedPattern, %iniFile%, Patterns, %patternName%, %A_Space%
    if (loadedPattern != "") {
        patterns[patternName] := loadedPattern
    return loadedPattern
}
return ""
}

LoadAllPatterns() {
    ; Load patterns
    IniRead, patternNames, %iniFile%, Patterns
    if (patternNames != "ERROR") {
        Loop, Parse, patternNames, `n
        {
            if (A_LoopField != "") {
                ; Find first equals sign position
                equalsPos := InStr(A_LoopField, "=")
                if (equalsPos > 0) {
                    patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                    patternText := SubStr(A_LoopField, equalsPos + 1)
                    patterns[patternName] := patternText
                }
            }
        }
    }

    ; Load pattern keys
    IniRead, patternKeyNames, %iniFile%, PatternKeys
    if (patternKeyNames != "ERROR") {
        Loop, Parse, patternKeyNames, `n
        {
            if (A_LoopField != "") {
                ; Find first equals sign position
                equalsPos := InStr(A_LoopField, "=")
                if (equalsPos > 0) {
                    patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                    keyAssignment := SubStr(A_LoopField, equalsPos + 1)
                    patternKeys[patternName] := keyAssignment
                }
            }
        }
    }

    ; Load pattern custom names
    IniRead, patternNamesList, %iniFile%, PatternNames
    if (patternNamesList != "ERROR") {
        nameCount := 0
        Loop, Parse, patternNamesList, `n
        {
            if (A_LoopField != "") {
                ; Find first equals sign position
                equalsPos := InStr(A_LoopField, "=")
                if (equalsPos > 0) {
                    patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                    customName := SubStr(A_LoopField, equalsPos + 1)
                    patternNames[patternName] := customName
                    nameCount++
                }
            }
        }
        if (nameCount > 0) {
            UpdateHealerStatus("Loaded " . nameCount . " custom heal names from INI")
        }
    }

    patternCount := patterns.Count()
    if (patternCount > 0)
        UpdateHealerStatus("Loaded " . patternCount . " pattern(s) successfully.")

    ; Also show custom names count at startup
    nameCount := 0
    for patternName, customName in patternNames {
        if (patterns.HasKey(patternName) && SubStr(patternName, 1, 4) = "heal") {
            nameCount++
        }
    }
    if (nameCount > 0) {
        UpdateHealerStatus("Loaded " . nameCount . " custom heal names at startup")
    }

    ; Load heal ground target settings
    IniRead, healGroundTargetList, %iniFile%, HealGroundTarget
    if (healGroundTargetList != "ERROR") {
        Loop, Parse, healGroundTargetList, `n
        {
            if (A_LoopField != "") {
                equalsPos := InStr(A_LoopField, "=")
                if (equalsPos > 0) {
                    patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                    isGroundTarget := SubStr(A_LoopField, equalsPos + 1)
                    healGroundTargetSkills[patternName] := isGroundTarget
                }
            }
        }
    }

    ; Load heal ground target coordinates
    IniRead, healGroundCoordsList, %iniFile%, HealGroundCoords
    if (healGroundCoordsList != "ERROR") {
        Loop, Parse, healGroundCoordsList, `n
        {
            if (A_LoopField != "") {
                equalsPos := InStr(A_LoopField, "=")
                if (equalsPos > 0) {
                    patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                    coordString := SubStr(A_LoopField, equalsPos + 1)
                    coords := StrSplit(coordString, ",")
                    if (coords.Length() = 2) {
                        healGroundTargetCoords[patternName] := {x: coords[1], y: coords[2]}
                    }
                }
            }
        }
    }

    ; Load heal pre-cast key settings
    IniRead, healPreCastEnabledList, %iniFile%, HealPreCastEnabled
    if (healPreCastEnabledList != "ERROR") {
        Loop, Parse, healPreCastEnabledList, `n
        {
            if (A_LoopField != "") {
                equalsPos := InStr(A_LoopField, "=")
                if (equalsPos > 0) {
                    patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                    needsPreCast := SubStr(A_LoopField, equalsPos + 1)
                    healPressKeyBeforeCast[patternName] := needsPreCast
                }
            }
        }
    }

    ; Load heal pre-cast keys
    IniRead, healPreCastKeysList, %iniFile%, HealPreCastKeys
    if (healPreCastKeysList != "ERROR") {
        Loop, Parse, healPreCastKeysList, `n
        {
            if (A_LoopField != "") {
                equalsPos := InStr(A_LoopField, "=")
                if (equalsPos > 0) {
                    patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                    preCastKey := SubStr(A_LoopField, equalsPos + 1)
                    healPreCastKeys[patternName] := preCastKey
                }
            }
        }
    }
}

RefreshHealSkillsList() {
    ; This function now just triggers a priority list refresh
    ; since we're using the same approach as DPS tab
    RefreshHealPriorityList()
}

CreateHealKeyInputs() {
    global patterns, patternKeys

    healIndex := 1
    for patternName, patternText in patterns {
        if (SubStr(patternName, 1, 4) = "heal" && healIndex <= 3) {
            ; For now, just update status with available heals
            ; We'll handle key assignment through a different method
            healIndex++
        }
    }
}

AssignHealKeys:
    ; Show available heal skills and let user assign keys
    healList := "=== ASSIGN KEYS TO HEALING SKILLS ===`n`n"
    healCount := 0

    for patternName, patternText in patterns {
        if (SubStr(patternName, 1, 4) = "heal") {
            healCount++
            displayName := GetDisplayName(patternName)
            currentKey := patternKeys.HasKey(patternName) ? patternKeys[patternName] : "(none)"

                healList .= healCount . ". " . displayName . " [" . patternName . "]`n"
                healList .= " Current Key: " . currentKey . "`n`n"
            }
        }

        if (healCount = 0) {
            UpdateHealerStatus("No healing skills to assign keys to. Capture some skills first.")
            return
        }

        healList .= "`nEnter the number of the healing skill to assign a key to:"

        InputBox, healNumber, Assign Heal Key, %healList%, , 400, 300
        if (ErrorLevel)
            return

        ; Find the selected heal
        currentIndex := 1
        selectedHeal := ""
        for patternName, patternText in patterns {
            if (SubStr(patternName, 1, 4) = "heal") {
                if (currentIndex = healNumber) {
                    selectedHeal := patternName
                    break
                }
                currentIndex++
            }
        }

        if (selectedHeal = "") {
            UpdateHealerStatus("Invalid healing skill number selected.")
            return
        }

        ; Get key assignment
        selectedDisplayName := GetDisplayName(selectedHeal)
        currentKey := patternKeys.HasKey(selectedHeal) ? patternKeys[selectedHeal] : ""
            keyPrompt := "=== ASSIGN KEY ===`n`nHealing Skill: " . selectedDisplayName . "`nID: " . selectedHeal . "`nCurrent Key: " . currentKey . "`n`nEnter new key (examples: 1, 2, F1, F2, etc.):"
            InputBox, newKey, Assign Key to Healing Skill, %keyPrompt%, , 400, 200, , , , , %currentKey%
            if (ErrorLevel)
                return

            ; Save the assignment
            patternKeys[selectedHeal] := newKey
            SavePatternKey(selectedHeal, newKey)
            UpdateHealerStatus("Assigned key '" . newKey . "' to '" . selectedDisplayName . "' [" . selectedHeal . "] and saved to INI")
            RefreshHealPriorityList()
        return

        RenameHealSkills:
            if (patterns.Count() = 0) {
                UpdateHealerStatus("No healing skills to rename.")
                return
            }

            ; Build skill list and selection array in one pass
            healList := "=== RENAME HEALING SKILLS ===`n`n"
            skillArray := []

            for patternName, patternText in patterns {
                if (SubStr(patternName, 1, 4) = "heal") {
                    skillArray.Push(patternName)
                    displayName := GetDisplayName(patternName)
                    status := (displayName != patternName) ? "(Custom)" : "(Default)"
                        healList .= skillArray.Length() . ". " . displayName . " [" . patternName . "] " . status . "`n"
                    }
                }

                ; Create scrollable GUI instead of InputBox
                Gui, RenameHealSelect:New, +Resize, Rename Heal Skill
                Gui, RenameHealSelect:Add, Edit, x10 y10 w580 h320 ReadOnly VScroll, %healList%`n`nEnter skill number:
                Gui, RenameHealSelect:Add, Edit, x10 y340 w100 h20 vHealNumberInput
                Gui, RenameHealSelect:Add, Button, x120 y340 w60 h20 gRenameHealSelectOK, OK
                Gui, RenameHealSelect:Add, Button, x190 y340 w60 h20 gRenameHealSelectCancel, Cancel
                Gui, RenameHealSelect:Show, w600 h380
                return

                RenameHealSelectOK:
                    Gui, RenameHealSelect:Submit
                    healNumber := HealNumberInput
                    if (healNumber < 1 || healNumber > skillArray.Length()) {
                        UpdateHealerStatus("Invalid selection.")
                        return
                    }
                    Gui, RenameHealSelect:Destroy

                    selectedHeal := skillArray[healNumber]
                    currentDisplayName := GetDisplayName(selectedHeal)

                    InputBox, newName, Rename Heal Skill, Original: %selectedHeal%`nCurrent: %currentDisplayName%`n`nNew name:, , 400, 180, , , , , %currentDisplayName%
                    if (ErrorLevel || newName = "") {
                        if (!ErrorLevel) UpdateHealerStatus("Name cannot be empty.")
                            return
                    }

                    ; Update in-memory object directly
                    patternNames[selectedHeal] := newName
                    SavePatternName(selectedHeal, newName)
                    UpdateHealerStatus("Renamed '" . selectedHeal . "' to '" . newName . "'")

                    ; Force refresh with timer
                    SetTimer, ForceRefreshHeal, -50
                return

                RenameHealSelectCancel:
                    Gui, RenameHealSelect:Destroy
                return

                ModifyHealSkill:
                    if (patterns.Count() = 0) {
                        UpdateHealerStatus("No healing skills to modify.")
                        return
                    }

                    ; Build skill list with current modifier status
                    healList := "=== MODIFY HEALING SKILL ===`n`n"
                    skillArray := []

                    for patternName, patternText in patterns {
                        if (SubStr(patternName, 1, 4) = "heal") {
                            skillArray.Push(patternName)
                            displayName := GetDisplayName(patternName)

                            ; Show current modifier status
                            hasGroundTarget := healGroundTargetSkills.HasKey(patternName) && healGroundTargetSkills[patternName]
                            hasPreCast := healPressKeyBeforeCast.HasKey(patternName) && healPressKeyBeforeCast[patternName]

                            modStatus := ""
                            if (hasGroundTarget && hasPreCast)
                                modStatus := " [Click-After + Button-Before]"
                            else if (hasGroundTarget)
                                modStatus := " [Click-After]"
                            else if (hasPreCast)
                                modStatus := " [Button-Before]"
                            else
                                modStatus := " [No modifiers]"

                            healList .= skillArray.Length() . ". " . displayName . modStatus . "`n"
                        }
                    }

                    ; Create selection GUI
                    Gui, ModifyHealSelect:New, +Resize, Modify Healing Skill
                    Gui, ModifyHealSelect:Add, Edit, x10 y10 w580 h320 ReadOnly VScroll, %healList%`n`nEnter skill number to modify:
                    Gui, ModifyHealSelect:Add, Edit, x10 y340 w100 h20 vModifyHealNumberInput
                    Gui, ModifyHealSelect:Add, Button, x120 y340 w60 h20 gModifyHealSelectOK, OK
                    Gui, ModifyHealSelect:Add, Button, x190 y340 w60 h20 gModifyHealSelectCancel, Cancel
                    Gui, ModifyHealSelect:Show, w600 h380
                return

                ModifyHealSelectOK:
                    Gui, ModifyHealSelect:Submit
                    healNumber := ModifyHealNumberInput
                    if (healNumber < 1 || healNumber > skillArray.Length()) {
                        UpdateHealerStatus("Invalid selection.")
                        return
                    }
                    Gui, ModifyHealSelect:Destroy

                    selectedHeal := skillArray[healNumber]
                    displayName := GetDisplayName(selectedHeal)

                    ; Get current modifier states
                    currentGroundTarget := healGroundTargetSkills.HasKey(selectedHeal) && healGroundTargetSkills[selectedHeal]
                    currentPreCast := healPressKeyBeforeCast.HasKey(selectedHeal) && healPressKeyBeforeCast[selectedHeal]

                    ; Create modifier options GUI
                    Gui, ModifyHealOptions:New, , Modify Skill: %displayName%
                    Gui, ModifyHealOptions:Add, Text, x20 y20 w400, Select modifiers for: %displayName%
                    Gui, ModifyHealOptions:Add, Checkbox, x20 y50 w400 vModifyGroundTarget Checked%currentGroundTarget%, Click location AFTER skill cast (ground target)
                    Gui, ModifyHealOptions:Add, Checkbox, x20 y80 w400 vModifyPreCast Checked%currentPreCast%, Press button BEFORE skill cast
                    Gui, ModifyHealOptions:Add, Button, x120 y120 w80 h30 gApplyHealModifiers, Apply
                    Gui, ModifyHealOptions:Add, Button, x220 y120 w80 h30 gCancelHealModifiers, Cancel
                    Gui, ModifyHealOptions:Show, w450 h170
                return

                ModifyHealSelectCancel:
                    Gui, ModifyHealSelect:Destroy
                return

                ApplyHealModifiers:
                    Gui, ModifyHealOptions:Submit

                    ; Handle ground target modification
                    if (ModifyGroundTarget) {
                        ; If enabling ground target and it wasn't enabled before
                        if (!healGroundTargetSkills.HasKey(selectedHeal) || !healGroundTargetSkills[selectedHeal]) {
                            MsgBox, 0, Set Ground Target Location, Right-click on the location where the skill should be cast.`n`nPress OK first, then right-click the location.
                            UpdateHealerStatus("Waiting for right-click to set ground target location...")
                            KeyWait, RButton, D
                            MouseGetPos, groundX, groundY
                            ; Convert screen coords to window-relative coords for saving
                            WinGetPos, winX, winY,,, ahk_id %win1%
                            groundX := groundX - winX
                            groundY := groundY - winY

                            ; Save ground target settings
                            healGroundTargetSkills[selectedHeal] := true
                            coordString := groundX . "," . groundY
                            healGroundTargetCoords[selectedHeal] := {x: groundX, y: groundY}
                            FileEncoding, UTF-8
                            IniWrite, true, %iniFile%, HealGroundTarget, %selectedHeal%
                            IniWrite, %coordString%, %iniFile%, HealGroundCoords, %selectedHeal%
                            FileEncoding

                            ; Confirmation message
                            MsgBox, 64, Ground Target Set, Ground target location has been set successfully!`n`nRelative coordinates: %groundX%`, %groundY%
                        }
                    } else {
                        ; Remove ground target if unchecked
                        healGroundTargetSkills[selectedHeal] := false
                        healGroundTargetCoords.Delete(selectedHeal)
                        IniDelete, %iniFile%, HealGroundTarget, %selectedHeal%
                        IniDelete, %iniFile%, HealGroundCoords, %selectedHeal%
                    }

                    ; Handle pre-cast key modification
                    if (ModifyPreCast) {
                        ; If enabling pre-cast and it wasn't enabled before OR key needs updating
                        if (!healPressKeyBeforeCast.HasKey(selectedHeal) || !healPressKeyBeforeCast[selectedHeal] || !healPreCastKeys.HasKey(selectedHeal)) {
                            currentPreKey := healPreCastKeys.HasKey(selectedHeal) ? healPreCastKeys[selectedHeal] : ""
                                InputBox, preCastKey, Pre-Cast Key, Enter the key to press BEFORE the main skill key (e.g. Tab):, , 350, 150, , , , , %currentPreKey%
                                if (!ErrorLevel && preCastKey != "") {
                                    healPressKeyBeforeCast[selectedHeal] := true
                                    healPreCastKeys[selectedHeal] := preCastKey
                                    FileEncoding, UTF-8
                                    IniWrite, true, %iniFile%, HealPreCastEnabled, %selectedHeal%
                                    IniWrite, %preCastKey%, %iniFile%, HealPreCastKeys, %selectedHeal%
                                    FileEncoding
                                }
                            }
                        } else {
                            ; Remove pre-cast if unchecked
                            healPressKeyBeforeCast[selectedHeal] := false
                            healPreCastKeys.Delete(selectedHeal)
                            IniDelete, %iniFile%, HealPreCastEnabled, %selectedHeal%
                            IniDelete, %iniFile%, HealPreCastKeys, %selectedHeal%
                        }

                        ; Force refresh priority list with timer to ensure GUI has processed
                        UpdateHealerStatus("Updated modifiers for '" . displayName . "'")
                        Gui, ModifyHealOptions:Destroy
                        SetTimer, ForceRefreshHeal, -200
                        return

                        CancelHealModifiers:
                            Gui, ModifyHealOptions:Destroy
                        return

                        ReloadCustomNames() {
                            global patterns, patternNames, iniFile

                            ; Clear current names
                            patternNames := {}

                            ; Reload pattern custom names
                            IniRead, patternNamesList, %iniFile%, PatternNames
                            if (patternNamesList != "ERROR") {
                                nameCount := 0
                                Loop, Parse, patternNamesList, `n
                                {
                                    if (A_LoopField != "") {
                                        parts := StrSplit(A_LoopField, "=", " `t")
                                        if (parts.Length() >= 2) {
                                            patternName := parts[1]
                                            customName := parts[2]
                                            patternNames[patternName] := customName
                                            nameCount++
                                        }
                                    }
                                }
                            }
                        }

                        LoadAllHealKeys:
                            global patterns, patternKeys, iniFile

                            ; Load all key assignments from INI
                            keyLoadCount := 0

                            ; Read the PatternKeys section
                            IniRead, patternKeyNames, %iniFile%, PatternKeys
                            if (patternKeyNames != "ERROR") {
                                Loop, Parse, patternKeyNames, `n
                                {
                                    parts := StrSplit(A_LoopField, "=", " `t")
                                    if (parts.Length() >= 2) {
                                        patternName := parts[1]
                                        keyAssignment := parts[2]

                                        ; Only load if it's a heal pattern
                                        if (SubStr(patternName, 1, 4) = "heal") {
                                            patternKeys[patternName] := keyAssignment
                                            keyLoadCount++
                                        }
                                    }
                                }
                            }

                            UpdateHealerStatus("Loaded " . keyLoadCount . " heal key assignments from INI file")
                            RefreshHealSkillsList()
                        return

                        ShowHealKeysStatus:
                            statusMsg := "=== HEAL SKILLS STATUS ===`r`n`r`nINI: " . iniFile . "`r`n`r`n"

                            if (patterns.Count() = 0) {
                                statusMsg .= "No healing skills captured yet.`r`n"
                            } else {
                                healCount := 0
                                for patternName, patternText in patterns {
                                    if (SubStr(patternName, 1, 4) = "heal") {
                                        displayName := GetDisplayName(patternName)
                                        key := patternKeys.HasKey(patternName) ? patternKeys[patternName] : "Click"
                                            statusMsg .= ++healCount . ". " . displayName . " [" . patternName . "] - " . key . "`r`n"
                                        }
                                    }

                                    statusMsg .= "`r`n=== PRIORITY ORDER ===`r`n"
                                    for index, priorityPattern in healPriorities {
                                        if (patterns.HasKey(priorityPattern))
                                            statusMsg .= index . ". " . GetDisplayName(priorityPattern) . "`r`n"
                                    }
                                }

                                UpdateHealerStatus(statusMsg)
                                return

                                ShowSavedHeals:
                                    global patterns, patternNames, patternKeys

                                    ; Create comprehensive list of all saved healing skills
                                    healList := "=== ALL SAVED HEALING SKILLS ===`n`n"
                                    healCount := 0

                                    for patternName, patternText in patterns {
                                        if (SubStr(patternName, 1, 4) = "heal") {
                                            healCount++

                                            ; Get display name
                                            displayName := GetDisplayName(patternName)

                                            ; Get assigned key
                                            assignedKey := patternKeys.HasKey(patternName) ? patternKeys[patternName] : "(none)"

                                                ; Format: heal1 = Greater Heal [Key: 1]
                                                if (displayName != patternName) {
                                                    healList .= patternName . " = " . displayName . "`n"
                                                } else {
                                                    healList .= patternName . " (no custom name)`n"
                                                }
                                                healList .= " Key: " . assignedKey . "`n`n"
                                            }
                                        }

                                        if (healCount = 0) {
                                            healList .= "No healing skills have been captured yet.`n`n"
                                            healList .= "Use 'Add Healing Skill' to capture some healing skills first."
                                        } else {
                                            healList .= "Total: " . healCount . " healing skills saved`n`n"
                                            healList .= "• Use 'Rename Skills' to set custom names`n"
                                            healList .= "• Use 'Assign Heal Keys' to set keyboard shortcuts"
                                        }

                                        ; Show in a message box for easy viewing
                                        MsgBox, 0, Saved Healing Skills, %healList%
                                        return

                                        UpdatePatternKey:
                                            global patternKeys

                                            ; Get the control name that triggered this
                                            GuiControlGet, controlName, Focus

                                            ; Get pattern name from mapping
                                            patternName := HealControlMap_%controlName%

                                            ; Get the new key value
                                            GuiControlGet, newKey,, %controlName%

                                            ; Save the key assignment
                                            patternKeys[patternName] := newKey
                                            SavePatternKey(patternName, newKey)

                                            UpdateHealerStatus("Updated key for '" . patternName . "' to: " . newKey)
                                        return

                                        SavePatternKey(patternName, keyAssignment) {
                                            FileEncoding, UTF-8
                                            IniWrite, %keyAssignment%, %iniFile%, PatternKeys, %patternName%
                                            FileEncoding
                                        }

                                        GetDisplayName(patternName) {
                                            global patternNames

                                            ; Debug what's in patternNames
                                            if (patternNames.HasKey(patternName)) {
                                                customName := patternNames[patternName]
                                                if (customName != "") {
                                                    return customName
                                                }
                                            }
                                        return patternName ; fallback to original name
                                    }

                                    SavePatternName(patternName, customName) {
                                        global iniFile, patternNames

                                        ; Write to INI file
                                        FileEncoding, UTF-8
                                        IniWrite, %customName%, %iniFile%, PatternNames, %patternName%
                                        FileEncoding

                                        ; Update in-memory storage
                                        patternNames[patternName] := customName
                                    }

                                    UpdateHealerStatus(message) {
                                        global HealerStatusText

                                        ; Get current time
                                        FormatTime, timeStamp,, HH:mm:ss

                                        ; Add timestamp to message
                                        newMessage := "[" . timeStamp . "] " . message . "`r`n"

                                        ; Prepend to existing text (new messages at top)
                                        HealerStatusText := newMessage . HealerStatusText

                                        ; Keep only the first 15 lines to prevent overflow
                                        lines := StrSplit(HealerStatusText, "`r`n")
                                        if (lines.Length() > 15) {
                                            HealerStatusText := ""
                                            Loop, 15 {
                                                if (lines[A_Index] != "") {
                                                    HealerStatusText .= lines[A_Index] . "`r`n"
                                                }
                                            }
                                        }

                                        ; Update the GUI control (simple approach that works)
                                        GuiControl,, HealerStatusEdit, %HealerStatusText%
                                    }

                                    ; ; ========= KEYPRESSER FUNCTIONS =========

                                    StartStop1:
                                        Gui, Submit, NoHide

                                        KeyCombination1 := KeyCombinationEdit1
                                        KeyDelay1 := KeyDelayEdit1
                                        TimerInterval1 := TimerIntervalEdit1

                                        if (!IsRunning1) {
                                            if (win1 = "") {
                                                UpdateStatus1("Error: Select target window")
                                                return
                                            }
                                            if (KeyCombination1 = "") {
                                                UpdateStatus1("Error: Enter key sequence")
                                                return
                                            }

                                            KeySequence1 := StrSplit(KeyCombination1, "|")

                                            SetTimer, CheckExecutions, 50
                                            IsRunning1 := true
                                            GuiControl,, StartStop1, Stop1
                                            UpdateStatus1("Running: " . KeyCombination1)
                                            if (!SkipInitial1)
                                                Gosub, SendKeys1

                                            NextExecutionTime1 := A_TickCount + (TimerInterval1 * 60 * 1000)
                                        } else {
                                            IsRunning1 := false
                                            GuiControl,, StartStop1, Start1
                                            UpdateStatus1("Stopped")
                                            GuiControl,, CountdownText1, Next: --
                                        }
                                    return

                                    StartStop2:
                                        Gui, Submit, NoHide

                                        KeyCombination2 := KeyCombinationEdit2
                                        KeyDelay2 := KeyDelayEdit2
                                        TimerInterval2 := TimerIntervalEdit2

                                        if (!IsRunning2) {
                                            if (win1 = "") {
                                                UpdateStatus2("Error: Select target window")
                                                return
                                            }
                                            if (KeyCombination2 = "") {
                                                UpdateStatus2("Error: Enter key sequence")
                                                return
                                            }

                                            KeySequence2 := StrSplit(KeyCombination2, "|")

                                            SetTimer, CheckExecutions, 50
                                            IsRunning2 := true
                                            GuiControl,, StartStop2, Stop2
                                            UpdateStatus2("Running: " . KeyCombination2)
                                            if (!SkipInitial1)
                                                Gosub, SendKeys2

                                            NextExecutionTime2 := A_TickCount + (TimerInterval2 * 60 * 1000)
                                        } else {
                                            IsRunning2 := false
                                            GuiControl,, StartStop2, Start2
                                            UpdateStatus2("Stopped")
                                            GuiControl,, CountdownText2, Next: --
                                        }
                                    return

                                    StartStop3:
                                        Gui, Submit, NoHide

                                        KeyCombination3 := KeyCombinationEdit3
                                        KeyDelay3 := KeyDelayEdit3
                                        TimerInterval3 := TimerIntervalEdit3

                                        if (!IsRunning3) {
                                            if (win1 = "") {
                                                UpdateStatus3("Error: Select target window")
                                                return
                                            }
                                            if (KeyCombination3 = "") {
                                                UpdateStatus3("Error: Enter key sequence")
                                                return
                                            }

                                            KeySequence3 := StrSplit(KeyCombination3, "|")

                                            SetTimer, CheckExecutions, 50
                                            IsRunning3 := true
                                            GuiControl,, StartStop3, Stop3
                                            UpdateStatus3("Running: " . KeyCombination3)
                                            if (!SkipInitial1)
                                                Gosub, SendKeys3

                                            NextExecutionTime3 := A_TickCount + (TimerInterval3 * 60 * 1000)
                                        } else {
                                            IsRunning3 := false
                                            GuiControl,, StartStop3, Start3
                                            UpdateStatus3("Stopped")
                                            GuiControl,, CountdownText3, Next: --
                                        }
                                    return

                                    StopAll:
                                        if (IsRunning1) {
                                            IsRunning1 := false
                                            GuiControl,, StartStop1, Start1
                                            UpdateStatus1("Stopped")
                                            GuiControl,, CountdownText1, Next: --
                                        }
                                        if (IsRunning2) {
                                            IsRunning2 := false
                                            GuiControl,, StartStop2, Start2
                                            UpdateStatus2("Stopped")
                                            GuiControl,, CountdownText2, Next: --
                                        }
                                        if (IsRunning3) {
                                            IsRunning3 := false
                                            GuiControl,, StartStop3, Start3
                                            UpdateStatus3("Stopped")
                                            GuiControl,, CountdownText3, Next: --
                                        }
                                        SetTimer, CheckExecutions, Off
                                        StopWindowMonitoring()
                                    return

                                    Stop1:
                                        if (IsRunning1) {
                                            IsRunning1 := false
                                            GuiControl,, StartStop1, Start1
                                            UpdateStatus1("Stopped")
                                            GuiControl,, CountdownText1, Next: --
                                        }
                                    return

                                    Stop2:
                                        if (IsRunning2) {
                                            IsRunning2 := false
                                            GuiControl,, StartStop2, Start2
                                            UpdateStatus2("Stopped")
                                            GuiControl,, CountdownText2, Next: --
                                        }
                                    return

                                    Stop3:
                                        if (IsRunning3) {
                                            IsRunning3 := false
                                            GuiControl,, StartStop3, Start3
                                            UpdateStatus3("Stopped")
                                            GuiControl,, CountdownText3, Next: --
                                        }
                                    return

                                    StartAllTimers:
                                        Gui, Submit, NoHide

                                        ; Validate that window is selected
                                        if (win1 = "") {
                                            MsgBox, 48, Error, Please select a target window first!
                                            return
                                        }

                                        ; Get all settings from GUI
                                        KeyCombination1 := KeyCombinationEdit1
                                        KeyDelay1 := KeyDelayEdit1
                                        TimerInterval1 := TimerIntervalEdit1
                                        KeyCombination2 := KeyCombinationEdit2
                                        KeyDelay2 := KeyDelayEdit2
                                        TimerInterval2 := TimerIntervalEdit2
                                        KeyCombination3 := KeyCombinationEdit3
                                        KeyDelay3 := KeyDelayEdit3
                                        TimerInterval3 := TimerIntervalEdit3

                                        ; Validate that at least one sequence has keys defined
                                        if (KeyCombination1 = "" && KeyCombination2 = "" && KeyCombination3 = "") {
                                            MsgBox, 48, Error, Please configure at least one key sequence!
                                            return
                                        }

                                        ; Ask about pet buffs
                                        MsgBox, 4, Pet Buffs, Do you want to activate both pet buffs (DT and Gnoll)?
                                        IfMsgBox Yes
                                        {
                                            activatePetBuffs := true
                                        }
                                        else
                                        {
                                            activatePetBuffs := false
                                        }

                                        ; Activate Death Tyrant buff BEFORE Sequence 1 if requested
                                        if (activatePetBuffs && !dtbuff) {
                                            dtbuff := true
                                            GuiControl,, dtbuff, 1
                                            deathtyrant()
                                            SetTimer, deathtyrant, 3000000
                                            ToolTip, Death Tyrant buff activated!, 10, 10, 4
                                            Sleep, 2000
                                            ToolTip,,,,4
                                        }

                                        ; Start Sequence 1 if configured
                                        if (KeyCombination1 && !IsRunning1) {
                                            if (win1 = "") {
                                                UpdateStatus1("Error: Select target window")
                                                return
                                            }
                                            if (KeyCombination1 = "") {
                                                UpdateStatus1("Error: Enter key sequence")
                                                return
                                            }

                                            KeySequence1 := StrSplit(KeyCombination1, "|")

                                            SetTimer, CheckExecutions, 50
                                            IsRunning1 := true
                                            GuiControl,, StartStop1, Stop1
                                            UpdateStatus1("Running: " . KeyCombination1)
                                            if (!SkipInitial1)
                                                Gosub, SendKeys1

                                            NextExecutionTime1 := A_TickCount + (TimerInterval1 * 60 * 1000)

                                        }

                                        ; Start Sequence 2 if configured
                                        if (KeyCombination2 && !IsRunning2 ) {
                                            if (win1 = "") {
                                                UpdateStatus2("Error: Select target window")
                                                return
                                            }
                                            if (KeyCombination2 = "") {
                                                UpdateStatus2("Error: Enter key sequence")
                                                return
                                            }

                                            KeySequence2 := StrSplit(KeyCombination2, "|")

                                            SetTimer, CheckExecutions, 50
                                            IsRunning2 := true
                                            GuiControl,, StartStop2, Stop2
                                            UpdateStatus2("Running: " . KeyCombination2)
                                            if (!SkipInitial1)
                                                Gosub, SendKeys2

                                            NextExecutionTime2 := A_TickCount + (TimerInterval2 * 60 * 1000)
                                        }

                                        ; Start Sequence 3 if configured
                                        if (KeyCombination3 && !IsRunning3) {
                                            if (win1 = "") {
                                                UpdateStatus3("Error: Select target window")
                                                return
                                            }
                                            if (KeyCombination3 = "") {
                                                UpdateStatus3("Error: Enter key sequence")
                                                return
                                            }

                                            KeySequence3 := StrSplit(KeyCombination3, "|")

                                            SetTimer, CheckExecutions, 50
                                            IsRunning3 := true
                                            GuiControl,, StartStop3, Stop3
                                            UpdateStatus3("Running: " . KeyCombination3)
                                            if (!SkipInitial1)
                                                Gosub, SendKeys3

                                            NextExecutionTime3 := A_TickCount + (TimerInterval3 * 60 * 1000)
                                        }

                                        ; Activate Gnoll buff AFTER Sequence 3 (wait 35 seconds) if requested
                                        if (activatePetBuffs && !gnollbuff) {
                                            ToolTip, Waiting 35 seconds before Gnoll buff..., 10, 10, 4
                                            Sleep, 35000
                                            ToolTip,,,,4

                                            gnollbuff := true
                                            GuiControl,, gnollbuff, 1
                                            gnoll()
                                            SetTimer, gnoll, %gnollBuffInterval%
                                            ToolTip, Gnoll buff activated!, 10, 10, 4
                                            Sleep, 2000
                                            ToolTip,,,,4
                                        }

                                        ; Show completion message
                                        ToolTip, All configured timers started!, 10, 10, 4
                                        SetTimer, RemoveStartAllTooltip, -2000
                                    return

                                    RemoveStartAllTooltip:
                                        ToolTip,,,,4
                                    return

                                    SendKeys1:
                                        ; Check if Critical mode is enabled - pause until disabled
                                        while (CriticalModeEnabled) {
                                            UpdateStatus1("Paused - Critical Mode active")
                                            Sleep, 1000
                                        }

                                        ; If navigation is running, set flag instead of executing
                                        if ((NavIsTraveling || IsTraveling) && !force) {
                                            sequence1Needed := true
                                            UpdateStatus2("Buffing queued for waypoint")
                                            return 
                                        }

                                        IfWinNotExist, ahk_id %win1%
                                        {
                                            UpdateStatus1("Window closed - stopping")
                                            IsRunning1 := false
                                            GuiControl,, StartStop1, Start1
                                            GuiControl,, CountdownText1, Next: --
                                            return
                                        }

                                        ; Keypresser has lowest priority - yield to healing and DPS
                                        if (isSystemBusy) {
                                            ; Delay execution by 1 second if system is busy
                                            NextExecutionTime1 := A_TickCount + 1000
                                            UpdateStatus1("Delayed - DPS/Healing active")
                                            return
                                        }

                                        ; Set system busy for buff sequence
                                        isSystemBusy := true
                                        IF (NavIsTraveling)
                                        {
                                            PauseNavigationForBuff()
                                        }
                                        Loop % KeySequence1.Length()
                                        {
                                            CurrentKey := KeySequence1[A_Index]
                                            if (CurrentKey != "") {
                                                ; Check for modifier keys and handle them separately
                                                hasCtrl := InStr(CurrentKey, "^")
                                                hasAlt := InStr(CurrentKey, "!")
                                                hasShift := InStr(CurrentKey, "+")

                                                ; Extract the base key (remove modifiers)
                                                baseKey := CurrentKey
                                                if (hasCtrl)
                                                    baseKey := StrReplace(baseKey, "^", "")
                                                if (hasAlt)
                                                    baseKey := StrReplace(baseKey, "!", "")
                                                if (hasShift)
                                                    baseKey := StrReplace(baseKey, "+", "")

                                                ; Apply QWERTZ conversion if enabled
                                                baseKey := ConvertQwertyToQwertz(baseKey)

                                                ; Send modifier keys down
                                                if (hasCtrl)
                                                    ControlSend, , {Ctrl down}, ahk_id %win1%
                                                if (hasAlt)
                                                    ControlSend, , {Alt down}, ahk_id %win1%
                                                if (hasShift)
                                                    ControlSend, , {Shift down}, ahk_id %win1%

                                                ; Send the base key
                                                ControlSend, , {%baseKey% down}, ahk_id %win1%
                                                Sleep, 50
                                                ControlSend, , {%baseKey% up}, ahk_id %win1%

                                                ; Send modifier keys up (in reverse order)
                                                if (hasShift)
                                                    ControlSend, , {Shift up}, ahk_id %win1%
                                                if (hasAlt)
                                                    ControlSend, , {Alt up}, ahk_id %win1%
                                                if (hasCtrl)
                                                    ControlSend, , {Ctrl up}, ahk_id %win1%

                                                if (KeyDelay1 > 0 && A_Index < KeySequence1.Length()) {
                                                    DelayMS1 := KeyDelay1 * 1000
                                                    Sleep, %DelayMS1%
                                                }
                                            }
                                        }

                                        ; Release system busy flag
                                        isSystemBusy := false

                                        NextExecutionTime1 := A_TickCount + (TimerInterval1 * 60 * 1000)
                                        UpdateStatus1("Buffs executed - yielding to DPS/Heal")
                                        ; Resume navigation after sequence execution
                                        if (NavigationPausedForBuff) {
                                            ResumeNavigationAfterBuff()
                                        }
                                    return
                                    SendKeys2:
                                        ; Check if Critical mode is enabled - pause until disabled
                                        while (CriticalModeEnabled) {
                                            UpdateStatus2("Paused - Critical Mode active")
                                            Sleep, 1000
                                        }

                                        ; If navigation is running, set flag instead of executing
                                        if ((NavIsTraveling || IsTraveling) && !force) {
                                            sequence2Needed := true
                                            UpdateStatus2("Buffing queued for waypoint")
                                            return
                                        }

                                        IfWinNotExist, ahk_id %win1%
                                        {
                                            UpdateStatus2("Window closed - stopping")
                                            IsRunning2 := false
                                            GuiControl,, StartStop2, Start2
                                            GuiControl,, CountdownText2, Next: --
                                            return
                                        }

                                        ; Keypresser has lowest priority - yield to healing and DPS
                                        if (isSystemBusy) {
                                            ; Delay execution by 1 second if system is busy
                                            NextExecutionTime2 := A_TickCount + 1000
                                            UpdateStatus2("Delayed - DPS/Healing active")
                                            return
                                        }

                                        ; Set system busy for buff sequence
                                        isSystemBusy := true
                                        IF (NavIsTraveling)
                                        {
                                            PauseNavigationForBuff()
                                        }
                                        Loop % KeySequence2.Length()
                                        {
                                            CurrentKey := KeySequence2[A_Index]
                                            if (CurrentKey != "") {
                                                ; Check for modifier keys and handle them separately
                                                hasCtrl := InStr(CurrentKey, "^")
                                                hasAlt := InStr(CurrentKey, "!")
                                                hasShift := InStr(CurrentKey, "+")

                                                ; Extract the base key (remove modifiers)
                                                baseKey := CurrentKey
                                                if (hasCtrl)
                                                    baseKey := StrReplace(baseKey, "^", "")
                                                if (hasAlt)
                                                    baseKey := StrReplace(baseKey, "!", "")
                                                if (hasShift)
                                                    baseKey := StrReplace(baseKey, "+", "")

                                                ; Send modifier keys down
                                                if (hasCtrl)
                                                    ControlSend, , {Ctrl down}, ahk_id %win1%
                                                if (hasAlt)
                                                    ControlSend, , {Alt down}, ahk_id %win1%
                                                if (hasShift)
                                                    ControlSend, , {Shift down}, ahk_id %win1%

                                                ; Send the base key
                                                ControlSend, , {%baseKey% down}, ahk_id %win1%
                                                Sleep, 50
                                                ControlSend, , {%baseKey% up}, ahk_id %win1%

                                                ; Send modifier keys up (in reverse order)
                                                if (hasShift)
                                                    ControlSend, , {Shift up}, ahk_id %win1%
                                                if (hasAlt)
                                                    ControlSend, , {Alt up}, ahk_id %win1%
                                                if (hasCtrl)
                                                    ControlSend, , {Ctrl up}, ahk_id %win1%

                                                if (KeyDelay2 > 0 && A_Index < KeySequence2.Length()) {
                                                    DelayMS2 := KeyDelay2 * 1000
                                                    Sleep, %DelayMS2%
                                                }
                                            }
                                        }

                                        ; Release system busy flag
                                        isSystemBusy := false

                                        NextExecutionTime2 := A_TickCount + (TimerInterval2 * 60 * 1000)
                                        UpdateStatus2("Buffs executed - yielding to DPS/Heal")
                                        if (NavigationPausedForBuff) {
                                            ResumeNavigationAfterBuff()
                                        }
                                    return

                                    SendKeys3:
                                        ; Check if Critical mode is enabled - pause until disabled
                                        while (CriticalModeEnabled) {
                                            UpdateStatus3("Paused - Critical Mode active")
                                            Sleep, 1000
                                        }

                                        ; If navigation is running, set flag instead of executing
                                        if ((NavIsTraveling || IsTraveling) && !force) {
                                            sequence3Needed := true
                                            UpdateStatus3("Buffing queued for waypoint")
                                            return
                                        }

                                        IfWinNotExist, ahk_id %win1%
                                        {
                                            UpdateStatus3("Window closed - stopping")
                                            IsRunning3 := false
                                            GuiControl,, StartStop3, Start3
                                            GuiControl,, CountdownText3, Next: --
                                            return
                                        }

                                        ; Keypresser has lowest priority - yield to healing and DPS
                                        if (isSystemBusy) {
                                            ; Delay execution by 1 second if system is busy
                                            NextExecutionTime3 := A_TickCount + 1000
                                            UpdateStatus3("Delayed - DPS/Healing active")
                                            return
                                        }

                                        ; Set system busy for buff sequence
                                        isSystemBusy := true

                                        IF (NavIsTraveling)
                                        {
                                            PauseNavigationForBuff()
                                        }
                                        Loop % KeySequence3.Length()
                                        {
                                            CurrentKey := KeySequence3[A_Index]
                                            if (CurrentKey != "") {
                                                ; Check for modifier keys and handle them separately
                                                hasCtrl := InStr(CurrentKey, "^")
                                                hasAlt := InStr(CurrentKey, "!")
                                                hasShift := InStr(CurrentKey, "+")

                                                ; Extract the base key (remove modifiers)
                                                baseKey := CurrentKey
                                                if (hasCtrl)
                                                    baseKey := StrReplace(baseKey, "^", "")
                                                if (hasAlt)
                                                    baseKey := StrReplace(baseKey, "!", "")
                                                if (hasShift)
                                                    baseKey := StrReplace(baseKey, "+", "")

                                                ; Send modifier keys down
                                                if (hasCtrl)
                                                    ControlSend, , {Ctrl down}, ahk_id %win1%
                                                if (hasAlt)
                                                    ControlSend, , {Alt down}, ahk_id %win1%
                                                if (hasShift)
                                                    ControlSend, , {Shift down}, ahk_id %win1%

                                                ; Send the base key
                                                ControlSend, , {%baseKey% down}, ahk_id %win1%
                                                Sleep, 50
                                                ControlSend, , {%baseKey% up}, ahk_id %win1%

                                                ; Send modifier keys up (in reverse order)
                                                if (hasShift)
                                                    ControlSend, , {Shift up}, ahk_id %win1%
                                                if (hasAlt)
                                                    ControlSend, , {Alt up}, ahk_id %win1%
                                                if (hasCtrl)
                                                    ControlSend, , {Ctrl up}, ahk_id %win1%

                                                if (KeyDelay3 > 0 && A_Index < KeySequence3.Length()) {
                                                    DelayMS3 := KeyDelay3 * 1000
                                                    Sleep, %DelayMS3%
                                                }
                                            }
                                        }

                                        ; Release system busy flag
                                        isSystemBusy := false

                                        NextExecutionTime3 := A_TickCount + (TimerInterval3 * 60 * 1000)
                                        UpdateStatus3("Buffs executed - yielding to DPS/Heal")
                                        if (NavigationPausedForBuff) {
                                            ResumeNavigationAfterBuff()
                                        }
                                    return

                                    CheckExecutions:
                                        ; Check if Critical mode is enabled - pause execution timers
                                        if (CriticalModeEnabled) {
                                            return
                                        }
                                        CurrentTime := A_TickCount

                                        if (IsRunning1 && CurrentTime >= NextExecutionTime1) {
                                            Gosub, SendKeys1
                                        }

                                        if (IsRunning2 && CurrentTime >= NextExecutionTime2) {
                                            Gosub, SendKeys2
                                        }

                                        if (IsRunning3 && CurrentTime >= NextExecutionTime3) {
                                            Gosub, SendKeys3
                                        }

                                        if (IsRunning1) {
                                            TimeRemaining := NextExecutionTime1 - CurrentTime
                                            if (TimeRemaining <= 0) {
                                                MinutesLeft := 0
                                            } else {
                                                MinutesLeft := Round(TimeRemaining / 60000, 2)
                                            }
                                            GuiControl,, CountdownText1, Next: %MinutesLeft%m
                                        }

                                        if (IsRunning2) {
                                            TimeRemaining := NextExecutionTime2 - CurrentTime
                                            if (TimeRemaining <= 0) {
                                                MinutesLeft := 0
                                            } else {
                                                MinutesLeft := Round(TimeRemaining / 60000, 2)
                                            }
                                            GuiControl,, CountdownText2, Next: %MinutesLeft%m
                                        }

                                        if (IsRunning3) {
                                            TimeRemaining := NextExecutionTime3 - CurrentTime
                                            if (TimeRemaining <= 0) {
                                                MinutesLeft := 0
                                            } else {
                                                MinutesLeft := Round(TimeRemaining / 60000, 2)
                                            }
                                            GuiControl,, CountdownText3, Next: %MinutesLeft%m
                                        }

                                        if (!IsRunning1 && !IsRunning2 && !IsRunning3) {
                                            SetTimer, CheckExecutions, Off
                                        }
                                    return

                                    SaveKeypresserSettings:
                                        Gui, Submit, NoHide

                                        KeyCombination1 := KeyCombinationEdit1
                                        KeyDelay1 := KeyDelayEdit1
                                        TimerInterval1 := TimerIntervalEdit1
                                        KeyCombination2 := KeyCombinationEdit2
                                        KeyDelay2 := KeyDelayEdit2
                                        TimerInterval2 := TimerIntervalEdit2
                                        KeyCombination3 := KeyCombinationEdit3
                                        KeyDelay3 := KeyDelayEdit3
                                        TimerInterval3 := TimerIntervalEdit3

                                        FileEncoding, UTF-8

                                        IniWrite, %win1%, %SettingsFile%, Settings, win1

                                        IniWrite, %KeyCombination1%, %SettingsFile%, Sequence1, KeyCombination
                                        IniWrite, %KeyDelay1%, %SettingsFile%, Sequence1, KeyDelay
                                        IniWrite, %TimerInterval1%, %SettingsFile%, Sequence1, TimerInterval

                                        IniWrite, %KeyCombination2%, %SettingsFile%, Sequence2, KeyCombination
                                        IniWrite, %KeyDelay2%, %SettingsFile%, Sequence2, KeyDelay
                                        IniWrite, %TimerInterval2%, %SettingsFile%, Sequence2, TimerInterval

                                        IniWrite, %KeyCombination3%, %SettingsFile%, Sequence3, KeyCombination
                                        IniWrite, %KeyDelay3%, %SettingsFile%, Sequence3, KeyDelay
                                        IniWrite, %TimerInterval3%, %SettingsFile%, Sequence3, TimerInterval
                                        FileEncoding

                                        UpdateStatus1("Settings saved")
                                        UpdateStatus2("Settings saved")
                                        UpdateStatus3("Settings saved")
                                    return

                                    LoadKeypresserSettings:

                                        IniRead, win1, %SettingsFile%, Settings, win1, %A_Space%

                                        IniRead, KeyCombination1, %SettingsFile%, Sequence1, KeyCombination, %A_Space%
                                        IniRead, KeyDelay1, %SettingsFile%, Sequence1, KeyDelay, 0.1
                                        IniRead, TimerInterval1, %SettingsFile%, Sequence1, TimerInterval, 1

                                        IniRead, KeyCombination2, %SettingsFile%, Sequence2, KeyCombination, %A_Space%
                                        IniRead, KeyDelay2, %SettingsFile%, Sequence2, KeyDelay, 0.1
                                        IniRead, TimerInterval2, %SettingsFile%, Sequence2, TimerInterval, 2

                                        IniRead, KeyCombination3, %SettingsFile%, Sequence3, KeyCombination, %A_Space%
                                        IniRead, KeyDelay3, %SettingsFile%, Sequence3, KeyDelay, 0.1
                                        IniRead, TimerInterval3, %SettingsFile%, Sequence3, TimerInterval, 3

                                        ; Add these lines in LoadKeypresserSettings label
                                        IniRead, KeyCombination4, %SettingsFile%, Sequence4, KeyCombination, %A_Space%
                                        IniRead, KeyDelay4, %SettingsFile%, Sequence4, KeyDelay, 0.1
                                        IniRead, TimerInterval4, %SettingsFile%, Sequence4, TimerInterval, 4
                                        KeySequence4 := StrSplit(KeyCombination4, "|")

                                        IniRead, KeyCombination5, %SettingsFile%, Sequence5, KeyCombination, %A_Space%
                                        IniRead, KeyDelay5, %SettingsFile%, Sequence5, KeyDelay, 0.1
                                        IniRead, TimerInterval5, %SettingsFile%, Sequence5, TimerInterval, 5
                                        KeySequence5 := StrSplit(KeyCombination5, "|")

                                        IniRead, KeyCombination6, %SettingsFile%, Sequence6, KeyCombination, %A_Space%
                                        IniRead, KeyDelay6, %SettingsFile%, Sequence6, KeyDelay, 0.1
                                        IniRead, TimerInterval6, %SettingsFile%, Sequence6, TimerInterval, 6
                                        KeySequence6 := StrSplit(KeyCombination6, "|")

                                        if (win1 = "ERROR")
                                            win1 := ""
                                        if (KeyCombination1 = "ERROR")
                                            KeyCombination1 := ""
                                        if (KeyCombination2 = "ERROR")
                                            KeyCombination2 := ""
                                        if (KeyCombination3 = "ERROR")
                                            KeyCombination3 := ""
                                        if (KeyCombination4 = "ERROR")
                                            KeyCombination4 := ""
                                        if (KeyCombination5 = "ERROR")
                                            KeyCombination5 := ""
                                        if (KeyCombination6 = "ERROR")
                                            KeyCombination6 := ""

                                        GuiControl,, KeyCombinationEdit1, %KeyCombination1%
                                        GuiControl,, KeyDelayEdit1, %KeyDelay1%
                                        GuiControl,, TimerIntervalEdit1, %TimerInterval1%
                                        GuiControl,, KeyCombinationEdit2, %KeyCombination2%
                                        GuiControl,, KeyDelayEdit2, %KeyDelay2%
                                        GuiControl,, TimerIntervalEdit2, %TimerInterval2%
                                        GuiControl,, KeyCombinationEdit3, %KeyCombination3%
                                        GuiControl,, KeyDelayEdit3, %KeyDelay3%
                                        GuiControl,, TimerIntervalEdit3, %TimerInterval3%
                                        GuiControl,, KeyCombinationEdit4, %KeyCombination4%
                                        GuiControl,, KeyDelayEdit4, %KeyDelay4%
                                        GuiControl,, TimerIntervalEdit4, %TimerInterval4%
                                        GuiControl,, KeyCombinationEdit5, %KeyCombination5%
                                        GuiControl,, KeyDelayEdit5, %KeyDelay5%
                                        GuiControl,, TimerIntervalEdit5, %TimerInterval5%
                                        GuiControl,, KeyCombinationEdit6, %KeyCombination6%
                                        GuiControl,, KeyDelayEdit6, %KeyDelay6%
                                        GuiControl,, TimerIntervalEdit6, %TimerInterval6%
                                        UpdateStatus1("Settings loaded")
                                        UpdateStatus2("Settings loaded")
                                        UpdateStatus3("Settings loaded")
                                    return

                                    LoadPetBuffImageSettings:
                                        ; Load pet buff image patterns
                                        IniRead, gnollBuffImagePattern, %SettingsFile%, PetBuffImages, GnollBuffPattern, %A_Space%
                                        IniRead, dtBuffImagePattern, %SettingsFile%, PetBuffImages, DTBuffPattern, %A_Space%
                                        IniRead, customSummonPattern, %SettingsFile%, PetBuffImages, SummonPattern, %A_Space%
                                        IniRead, summonKeybind, %SettingsFile%, PetBuffImages, SummonKeybind, +=

                                        ; Handle ERROR values
                                        if (gnollBuffImagePattern = "ERROR")
                                            gnollBuffImagePattern := ""
                                        if (dtBuffImagePattern = "ERROR")
                                            dtBuffImagePattern := ""
                                        if (customSummonPattern = "ERROR")
                                            customSummonPattern := ""
                                        if (summonKeybind = "ERROR")
                                            summonKeybind := "+="
                                    return

                                    UpdateStatus1(Message) {
                                        GuiControl,, StatusText1, %Message%
                                    }

                                    UpdateStatus2(Message) {
                                        GuiControl,, StatusText2, %Message%
                                    }

                                    UpdateStatus3(Message) {
                                        GuiControl,, StatusText3, %Message%
                                    }

                                    ; ========= HEAL PRIORITY FUNCTIONS =========

                                    HealPrioritySelect:
                                    return

                                    MoveHealUp:
                                        ; Get the currently selected item index from the ListBox
                                        GuiControlGet, selectedText, , HealPriorityList
                                        selectedIndex := 0

                                        ; Parse the index from the text (format: "1. SkillName")
                                        if (selectedText != "") {
                                            RegExMatch(selectedText, "^(\d+)\.", match)
                                            selectedIndex := match1
                                        }

                                        ; Debug info
                                        UpdateHealerStatus("Debug: Selected text = '" . selectedText . "', Parsed index = " . selectedIndex . ", Total items = " . healPriorities.Length())

                                        if (selectedIndex <= 1 || selectedIndex > healPriorities.Length()) {
                                            UpdateHealerStatus("Cannot move item up. Select an item first or item is already at top.")
                                            return
                                        }

                                        ; Swap with previous item
                                        temp := healPriorities[selectedIndex]
                                        healPriorities[selectedIndex] := healPriorities[selectedIndex - 1]
                                        healPriorities[selectedIndex - 1] := temp

                                        SaveHealPriorities()
                                        RefreshHealPriorityList()

                                        ; Reselect the moved item
                                        GuiControl, Choose, HealPriorityList, % selectedIndex - 1

                                        UpdateHealerStatus("Moved heal skill up in priority.")
                                    return

                                    MoveHealDown:
                                        ; Get the currently selected item index from the ListBox
                                        GuiControlGet, selectedText, , HealPriorityList
                                        selectedIndex := 0

                                        ; Parse the index from the text (format: "1. SkillName")
                                        if (selectedText != "") {
                                            RegExMatch(selectedText, "^(\d+)\.", match)
                                            selectedIndex := match1
                                        }

                                        ; Debug info
                                        UpdateHealerStatus("Debug: Selected text = '" . selectedText . "', Parsed index = " . selectedIndex . ", Total items = " . healPriorities.Length())

                                        if (selectedIndex <= 0 || selectedIndex >= healPriorities.Length()) {
                                            UpdateHealerStatus("Cannot move item down. Select an item first or item is already at bottom.")
                                            return
                                        }

                                        ; Swap with next item
                                        temp := healPriorities[selectedIndex]
                                        healPriorities[selectedIndex] := healPriorities[selectedIndex + 1]
                                        healPriorities[selectedIndex + 1] := temp

                                        SaveHealPriorities()
                                        RefreshHealPriorityList()

                                        ; Reselect the moved item
                                        GuiControl, Choose, HealPriorityList, % selectedIndex + 1

                                        UpdateHealerStatus("Moved heal skill down in priority.")
                                    return

                                    RefreshHealList:
                                        RefreshHealPriorityList()
                                        UpdateHealerStatus("Heal priority list refreshed.")
                                    return

                                    RemoveFromHealPriority:
                                        ; Get the currently selected item index from the ListBox
                                        GuiControlGet, selectedText, , HealPriorityList
                                        selectedIndex := 0

                                        ; Parse the index from the text (format: "1. SkillName")
                                        if (selectedText != "") {
                                            RegExMatch(selectedText, "^(\d+)\.", match)
                                            selectedIndex := match1
                                        }

                                        if (selectedIndex <= 0 || selectedIndex > healPriorities.Length()) {
                                            UpdateHealerStatus("Select a heal skill to remove from priority.")
                                            return
                                        }

                                        removedSkill := healPriorities[selectedIndex]
                                        displayName := GetDisplayName(removedSkill)
                                        healPriorities.RemoveAt(selectedIndex)

                                        SaveHealPriorities()
                                        RefreshHealPriorityList()
                                        UpdateHealerStatus("Removed '" . displayName . "' from heal priority order (skill still saved).")
                                    return

                                    AddToHealPriority:
                                        ; Show available heal skills not in priority
                                        availableHeals := "=== ADD HEAL TO PRIORITY ===`n`n"
                                        availableCount := 0
                                        availableSkills := []

                                        for patternName, patternText in patterns {
                                            if (SubStr(patternName, 1, 4) = "heal") {
                                                ; Check if already in priority
                                                inPriority := false
                                                for index, priorityPattern in healPriorities {
                                                    if (priorityPattern = patternName) {
                                                        inPriority := true
                                                        break
                                                    }
                                                }

                                                if (!inPriority) {
                                                    availableCount++
                                                    availableSkills.Push(patternName)
                                                    displayName := GetDisplayName(patternName)
                                                    availableHeals .= availableCount . ". " . displayName . " [" . patternName . "]`n"
                                                }
                                            }
                                        }

                                        if (availableCount = 0) {
                                            UpdateHealerStatus("No heal skills available to add (all are already in priority or none saved).")
                                            return
                                        }

                                        availableHeals .= "`nEnter the number of the heal to add to priority:"

                                        InputBox, healNumber, Add Heal to Priority, %availableHeals%, , 400, 300
                                        if (ErrorLevel)
                                            return

                                        if (healNumber < 1 || healNumber > availableCount) {
                                            UpdateHealerStatus("Invalid heal number selected.")
                                            return
                                        }

                                        selectedSkill := availableSkills[healNumber]
                                        displayName := GetDisplayName(selectedSkill)

                                        ; Add to end of priority list
                                        healPriorities.Push(selectedSkill)
                                        SaveHealPriorities()
                                        RefreshHealPriorityList()
                                        UpdateHealerStatus("Added '" . displayName . "' to heal priority order.")
                                    return

                                    RefreshHealPriorityList() {
                                        global patterns, patternKeys, healPriorities
                                        global healGroundTargetSkills, healPressKeyBeforeCast

                                        ; Clear the listbox
                                        GuiControl,, HealPriorityList, |

                                        ; Add items in priority order
                                        itemCount := 0
                                        for index, priorityPattern in healPriorities {
                                            if (patterns.HasKey(priorityPattern) && SubStr(priorityPattern, 1, 4) = "heal") {
                                                itemCount++
                                                displayName := GetDisplayName(priorityPattern)
                                                keyInfo := patternKeys.HasKey(priorityPattern) && patternKeys[priorityPattern] != "" ? " (Key: " . patternKeys[priorityPattern] . ")" : " (Click)"

                                                    ; Add modifier indicators - check for true/1/"true"
                                                    modifiers := ""
                                                    hasGroundTarget := healGroundTargetSkills.HasKey(priorityPattern) && (healGroundTargetSkills[priorityPattern] = true || healGroundTargetSkills[priorityPattern] = 1 || healGroundTargetSkills[priorityPattern] = "true" || healGroundTargetSkills[priorityPattern] = "1")
                                                    hasPreCast := healPressKeyBeforeCast.HasKey(priorityPattern) && (healPressKeyBeforeCast[priorityPattern] = true || healPressKeyBeforeCast[priorityPattern] = 1 || healPressKeyBeforeCast[priorityPattern] = "true" || healPressKeyBeforeCast[priorityPattern] = "1")

                                                    if (hasGroundTarget && hasPreCast)
                                                        modifiers := " [CB]"
                                                    else if (hasGroundTarget)
                                                        modifiers := " [C]"
                                                    else if (hasPreCast)
                                                        modifiers := " [B]"

                                                    listItem := index . ". " . displayName . keyInfo . modifiers
                                                    GuiControl,, HealPriorityList, %listItem%
                                                }
                                            }

                                            ; Show count for debugging
                                            if (itemCount = 0 && healPriorities.Length() > 0) {
                                                UpdateHealerStatus("Warning: " . healPriorities.Length() . " priorities but 0 valid patterns found")
                                            }
                                        }

                                        SaveHealPriorities() {
                                            global iniFile, healPriorities

                                            ; Convert array to comma-separated string
                                            priorityString := ""
                                            for index, priorityPattern in healPriorities {
                                                if (index > 1)
                                                    priorityString .= ","
                                                priorityString .= priorityPattern
                                            }

                                            FileEncoding, UTF-8
                                            IniWrite, %priorityString%, %iniFile%, HealPriorities, Order
                                            FileEncoding
                                        }

                                        LoadHealPriorities() {
                                            global iniFile, healPriorities

                                            IniRead, priorityString, %iniFile%, HealPriorities, Order, %A_Space%
                                            if (priorityString != "" && priorityString != "ERROR") {
                                                healPriorities := StrSplit(priorityString, ",")
                                            }
                                        }

                                        SaveHealSettings() {
                                            global iniFile, healCheckInterval, healThresholdPercent

                                            FileEncoding, UTF-8
                                            IniWrite, %healCheckInterval%, %iniFile%, HealSettings, CheckInterval
                                            IniWrite, %healThresholdPercent%, %iniFile%, HealSettings, ThresholdPercent
                                            FileEncoding
                                        }

                                        LoadHealSettings() {
                                            global iniFile, healCheckInterval, healThresholdPercent

                                            IniRead, loadedInterval, %iniFile%, HealSettings, CheckInterval, 1000
                                            if (loadedInterval >= 25 && loadedInterval <= 10000) {
                                                healCheckInterval := loadedInterval
                                                GuiControl,, HealIntervalInput, %healCheckInterval%
                                            }

                                            IniRead, loadedThreshold, %iniFile%, HealSettings, ThresholdPercent, 95
                                            if (loadedThreshold >= 1 && loadedThreshold <= 100) {
                                                healThresholdPercent := loadedThreshold
                                                GuiControl,, HealThresholdInput, %healThresholdPercent%
                                            }
                                        }

                                        ; ========= DPS FUNCTIONS =========

                                        AddDPSSkill:
                                            UpdateDPSStatus("Press 1 when the skill to capture is visable on screen.")
                                            KeyWait, 1, D
                                            capturedText := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)
                                            Clipboard := capturedText
                                            patternName := "dps" . dpsCounter

                                            ; Prompt for custom name and key assignment
                                            InputBox, customName, Name DPS Skill, Enter a name for this DPS skill:, , 300, 130, , , , , %patternName%
                                                if (ErrorLevel)
                                                return

                                            if (customName = "")
                                                customName := patternName

                                            ; Ask if need to press key before cast
                                            MsgBox, 4, Press Key Before Cast?, Do you need to press a DIFFERENT key BEFORE the main skill key?`n`n(Example: Press Tab to swap weapon bar, then press the skill key)
                                            IfMsgBox, Yes
                                            {
                                                needsPreCastKey := true
                                                InputBox, preCastKey, Pre-Cast Key, Enter the key to press BEFORE the main skill key (e.g. Tab):, , 350, 150
                                                if (ErrorLevel)
                                                    preCastKey := ""
                                            }
                                            IfMsgBox, No
                                            {
                                                needsPreCastKey := false
                                                preCastKey := ""
                                            }

                                            InputBox, assignedKey, Assign Main Skill Key, Enter the MAIN key that casts this skill (e.g. 6):`n`nLeave empty to click with mouse., , 350, 150
                                            if (ErrorLevel)
                                                return

                                            ; Ask if ground-targeted skill
                                            MsgBox, 4, Ground Target Skill?, Is this a ground-targeted skill that requires clicking a location AFTER the key is pressed?
                                            IfMsgBox, Yes
                                            {
                                                isGroundTarget := true
                                                MsgBox, 0, Right-Click to Set Location, Right-click on the location where the skill should be cast.`n`nPress OK first, then right-click the location.
                                                UpdateDPSStatus("Waiting for right-click to set ground target location...")
                                                KeyWait, RButton, D
                                                MouseGetPos, groundX, groundY
                                                ; Convert screen coords to window-relative coords for saving
                                                WinGetPos, winX, winY,,, ahk_id %win1%
                                                groundX := groundX - winX
                                                groundY := groundY - winY
                                                UpdateDPSStatus("Ground target location set (relative): " . groundX . ", " . groundY)
                                            }
                                            IfMsgBox, No
                                            {
                                                isGroundTarget := false
                                                groundX := ""
                                                groundY := ""
                                            }

                                            SaveDPSPattern(patternName, capturedText, assignedKey, customName, isGroundTarget, groundX, groundY, needsPreCastKey, preCastKey)
                                            UpdateDPSStatus("DPS skill captured and saved as '" . customName . "' [" . patternName . "]")
                                            UpdateDPSStatus("DEBUG SAVE: PreCast enabled=" . needsPreCastKey . ", PreCast key=" . preCastKey . ", Ground=" . isGroundTarget)
                                            dpsCounter++

                                            ; Add to priority list at the end
                                            dpsPriorities.Push(patternName)
                                            SaveDPSPriorities()
                                            RefreshDPSPriorityList()
                                        return

                                        TestDPSSkills:
                                            if (dpsPatterns.Count() = 0) {
                                                UpdateDPSStatus("No DPS skills captured. Add some skills first.")
                                                return
                                            }

                                            UpdateDPSStatus("Testing DPS skills - searching for patterns on screen...")

                                            foundCount := 0
                                            totalCount := 0

                                            ; Test each DPS pattern
                                            for patternName, patternText in dpsPatterns {
                                                totalCount++
                                                displayName := GetDPSDisplayName(patternName)

                                                ; Search in the skill bar area - convert window-relative to screen coordinates
                                                WinGetPos, winX, winY,,, ahk_id %win1%
                                                screenX1 := winX + SkillBarX1
                                                screenY1 := winY + SkillBarY1
                                                screenX2 := winX + SkillBarX2
                                                screenY2 := winY + SkillBarY2
                                                if (ok := FindText(X, Y, screenX1, screenY1, screenX2, screenY2, 0, 0, patternText)) {
                                                    foundCount++
                                                    UpdateDPSStatus("✓ FOUND: " . displayName . " at coordinates: " . X . ", " . Y)

                                                    ; Highlight the found skill
                                                    Try {
                                                        For i, v in ok {
                                                            if (i <= 2)
                                                                FindText().MouseTip(ok[i].x, ok[i].y)
                                                        }
                                                    }
                                                } else {
                                                    UpdateDPSStatus("✗ Not found: " . displayName)
                                                }
                                            }

                                            UpdateDPSStatus("Test complete - Found " . foundCount . " out of " . totalCount . " DPS skills on screen.")
                                        return

                                        ClearDPSSkills:
                                            InputBox, patternToClear, Clear DPS Pattern, Enter the name of the DPS pattern to clear (leave empty to clear all):, , 300, 130
                                            if (ErrorLevel)
                                                return

                                            if (patternToClear = "") {
                                                dpsPatterns := {}
                                                dpsPatternKeys := {}
                                                dpsPatternNames := {}
                                                dpsPriorities := []
                                                IniDelete, %iniFile%, DPSPatterns
                                                IniDelete, %iniFile%, DPSPatternKeys
                                                IniDelete, %iniFile%, DPSPatternNames
                                                IniDelete, %iniFile%, DPSPriorities
                                                dpsCounter := 1
                                                RefreshDPSPriorityList()
                                                UpdateDPSStatus("All DPS patterns have been cleared.")
                                            } else {
                                                ; Check both pattern name and custom name
                                                patternToDelete := ""
                                                for dpsPat, dpsText in dpsPatterns {
                                                    displayName := GetDPSDisplayName(dpsPat)
                                                    if (dpsPat = patternToClear || displayName = patternToClear) {
                                                        patternToDelete := dpsPat
                                                        break
                                                    }
                                                }

                                                if (patternToDelete != "") {
                                                    dpsPatterns.Delete(patternToDelete)
                                                    dpsPatternKeys.Delete(patternToDelete)
                                                    dpsPatternNames.Delete(patternToDelete)

                                                    ; Remove from priority list
                                                    for index, priorityPattern in dpsPriorities {
                                                        if (priorityPattern = patternToDelete) {
                                                            dpsPriorities.RemoveAt(index)
                                                            break
                                                        }
                                                    }

                                                    IniDelete, %iniFile%, DPSPatterns, %patternToDelete%
                                                    IniDelete, %iniFile%, DPSPatternKeys, %patternToDelete%
                                                    IniDelete, %iniFile%, DPSPatternNames, %patternToDelete%
                                                    SaveDPSPriorities()
                                                    RefreshDPSPriorityList()
                                                    UpdateDPSStatus("DPS pattern '" . patternToClear . "' has been cleared.")
                                                } else {
                                                    UpdateDPSStatus("DPS pattern '" . patternToClear . "' not found.")
                                                }
                                            }
                                        return

                                        AssignDPSKeys:
                                            ; Show available DPS skills and let user assign keys
                                            dpsList := "=== ASSIGN KEYS TO DPS SKILLS ===`n`n"
                                            dpsCount := 0

                                            for patternName, patternText in dpsPatterns {
                                                dpsCount++
                                                displayName := GetDPSDisplayName(patternName)
                                                currentKey := dpsPatternKeys.HasKey(patternName) ? dpsPatternKeys[patternName] : "(none)"

                                                    dpsList .= dpsCount . ". " . displayName . " [" . patternName . "]`n"
                                                    dpsList .= " Current Key: " . currentKey . "`n`n"
                                                }

                                                if (dpsCount = 0) {
                                                    UpdateDPSStatus("No DPS skills to assign keys to. Capture some skills first.")
                                                return
                                            }

                                            dpsList .= "`nEnter the number of the DPS skill to assign a key to:"

                                            InputBox, dpsNumber, Assign DPS Key, %dpsList%, , 400, 300
                                            if (ErrorLevel)
                                                return

                                            ; Find the selected DPS skill
                                            currentIndex := 1
                                            selectedDPS := ""
                                            for patternName, patternText in dpsPatterns {
                                                if (currentIndex = dpsNumber) {
                                                    selectedDPS := patternName
                                                    break
                                                }
                                                currentIndex++
                                            }

                                            if (selectedDPS = "") {
                                                UpdateDPSStatus("Invalid DPS skill number selected.")
                                                return
                                            }

                                            ; Get key assignment
                                            selectedDisplayName := GetDPSDisplayName(selectedDPS)
                                            currentKey := dpsPatternKeys.HasKey(selectedDPS) ? dpsPatternKeys[selectedDPS] : ""
                                                keyPrompt := "=== ASSIGN KEY ===`n`nDPS Skill: " . selectedDisplayName . "`nID: " . selectedDPS . "`nCurrent Key: " . currentKey . "`n`nEnter new key (examples: 1, 2, F1, F2, etc.):"
                                                InputBox, newKey, Assign Key to DPS Skill, %keyPrompt%, , 400, 200, , , , , %currentKey%
                                                if (ErrorLevel)
                                                    return

                                                ; Save the assignment
                                                dpsPatternKeys[selectedDPS] := newKey
                                                SaveDPSPatternKey(selectedDPS, newKey)
                                                UpdateDPSStatus("Assigned key '" . newKey . "' to '" . selectedDisplayName . "' [" . selectedDPS . "] and saved to INI")
                                                RefreshDPSPriorityList()
                                            return

                                            RenameDPSSkills:
                                                if (dpsPatterns.Count() = 0) {
                                                    UpdateDPSStatus("No DPS skills to rename.")
                                                    return
                                                }

                                                ; Build skill list and selection array in one pass
                                                dpsList := "=== RENAME DPS SKILLS ===`n`n"
                                                skillArray := []

                                                for patternName, patternText in dpsPatterns {
                                                    skillArray.Push(patternName)
                                                    displayName := GetDPSDisplayName(patternName)
                                                    status := (displayName != patternName) ? "(Custom)" : "(Default)"
                                                        dpsList .= skillArray.Length() . ". " . displayName . " [" . patternName . "] " . status . "`n"
                                                    }

                                                    ; Create scrollable GUI instead of InputBox
                                                    Gui, RenameDPSSelect:New, +Resize, Rename DPS Skill
                                                    Gui, RenameDPSSelect:Add, Edit, x10 y10 w580 h320 ReadOnly VScroll, %dpsList%`n`nEnter skill number:
                                                    Gui, RenameDPSSelect:Add, Edit, x10 y340 w100 h20 vDPSNumberInput
                                                    Gui, RenameDPSSelect:Add, Button, x120 y340 w60 h20 gRenameDPSSelectOK, OK
                                                    Gui, RenameDPSSelect:Add, Button, x190 y340 w60 h20 gRenameDPSSelectCancel, Cancel
                                                    Gui, RenameDPSSelect:Show, w600 h380
                                                    return

                                                    RenameDPSSelectOK:
                                                        Gui, RenameDPSSelect:Submit
                                                        dpsNumber := DPSNumberInput
                                                        if (dpsNumber < 1 || dpsNumber > skillArray.Length()) {
                                                            UpdateDPSStatus("Invalid selection.")
                                                            return
                                                        }
                                                        Gui, RenameDPSSelect:Destroy

                                                        selectedDPS := skillArray[dpsNumber]
                                                        currentDisplayName := GetDPSDisplayName(selectedDPS)

                                                        InputBox, newName, Rename DPS Skill, Original: %selectedDPS%`nCurrent: %currentDisplayName%`n`nNew name:, , 400, 180, , , , , %currentDisplayName%
                                                        if (ErrorLevel || newName = "") {
                                                            if (!ErrorLevel) UpdateDPSStatus("Name cannot be empty.")
                                                                return
                                                        }

                                                        ; Update in-memory object directly
                                                        dpsPatternNames[selectedDPS] := newName
                                                        SaveDPSPatternName(selectedDPS, newName)
                                                        UpdateDPSStatus("Renamed '" . selectedDPS . "' to '" . newName . "'")

                                                        ; Force refresh with timer
                                                        SetTimer, ForceRefreshDPS, -50
                                                    return

                                                    RenameDPSSelectCancel:
                                                        Gui, RenameDPSSelect:Destroy
                                                    return

                                                    ModifyDPSSkill:
                                                        if (dpsPatterns.Count() = 0) {
                                                            UpdateDPSStatus("No DPS skills to modify.")
                                                            return
                                                        }

                                                        ; Build skill list with current modifier status
                                                        dpsList := "=== MODIFY DPS SKILL ===`n`n"
                                                        skillArray := []

                                                        for patternName, patternText in dpsPatterns {
                                                            skillArray.Push(patternName)
                                                            displayName := GetDPSDisplayName(patternName)

                                                            ; Show current modifier status
                                                            hasGroundTarget := dpsGroundTargetSkills.HasKey(patternName) && dpsGroundTargetSkills[patternName]
                                                            hasPreCast := dpsPressKeyBeforeCast.HasKey(patternName) && dpsPressKeyBeforeCast[patternName]

                                                            modStatus := ""
                                                            if (hasGroundTarget && hasPreCast)
                                                                modStatus := " [Click-After + Button-Before]"
                                                            else if (hasGroundTarget)
                                                                modStatus := " [Click-After]"
                                                            else if (hasPreCast)
                                                                modStatus := " [Button-Before]"
                                                            else
                                                                modStatus := " [No modifiers]"

                                                            dpsList .= skillArray.Length() . ". " . displayName . modStatus . "`n"
                                                        }

                                                        ; Create selection GUI
                                                        Gui, ModifyDPSSelect:New, +Resize, Modify DPS Skill
                                                        Gui, ModifyDPSSelect:Add, Edit, x10 y10 w580 h320 ReadOnly VScroll, %dpsList%`n`nEnter skill number to modify:
                                                        Gui, ModifyDPSSelect:Add, Edit, x10 y340 w100 h20 vModifyDPSNumberInput
                                                        Gui, ModifyDPSSelect:Add, Button, x120 y340 w60 h20 gModifyDPSSelectOK, OK
                                                        Gui, ModifyDPSSelect:Add, Button, x190 y340 w60 h20 gModifyDPSSelectCancel, Cancel
                                                        Gui, ModifyDPSSelect:Show, w600 h380
                                                    return

                                                    ModifyDPSSelectOK:
                                                        Gui, ModifyDPSSelect:Submit
                                                        dpsNumber := ModifyDPSNumberInput
                                                        if (dpsNumber < 1 || dpsNumber > skillArray.Length()) {
                                                            UpdateDPSStatus("Invalid selection.")
                                                            return
                                                        }
                                                        Gui, ModifyDPSSelect:Destroy

                                                        selectedDPS := skillArray[dpsNumber]
                                                        displayName := GetDPSDisplayName(selectedDPS)

                                                        ; Get current modifier states
                                                        currentGroundTarget := dpsGroundTargetSkills.HasKey(selectedDPS) && dpsGroundTargetSkills[selectedDPS]
                                                        currentPreCast := dpsPressKeyBeforeCast.HasKey(selectedDPS) && dpsPressKeyBeforeCast[selectedDPS]

                                                        ; Create modifier options GUI
                                                        Gui, ModifyDPSOptions:New, , Modify Skill: %displayName%
                                                        Gui, ModifyDPSOptions:Add, Text, x20 y20 w400, Select modifiers for: %displayName%
                                                        Gui, ModifyDPSOptions:Add, Checkbox, x20 y50 w400 vModifyDPSGroundTarget Checked%currentGroundTarget%, Click location AFTER skill cast (ground target)
                                                        Gui, ModifyDPSOptions:Add, Checkbox, x20 y80 w400 vModifyDPSPreCast Checked%currentPreCast%, Press button BEFORE skill cast
                                                        Gui, ModifyDPSOptions:Add, Button, x120 y120 w80 h30 gApplyDPSModifiers, Apply
                                                        Gui, ModifyDPSOptions:Add, Button, x220 y120 w80 h30 gCancelDPSModifiers, Cancel
                                                        Gui, ModifyDPSOptions:Show, w450 h170
                                                    return

                                                    ModifyDPSSelectCancel:
                                                        Gui, ModifyDPSSelect:Destroy
                                                    return

                                                    ApplyDPSModifiers:
                                                        Gui, ModifyDPSOptions:Submit

                                                        ; Handle ground target modification
                                                        if (ModifyDPSGroundTarget) {
                                                            ; If enabling ground target and it wasn't enabled before
                                                            if (!dpsGroundTargetSkills.HasKey(selectedDPS) || !dpsGroundTargetSkills[selectedDPS]) {
                                                                MsgBox, 0, Set Ground Target Location, Right-click on the location where the skill should be cast.`n`nPress OK first, then right-click the location.
                                                                UpdateDPSStatus("Waiting for right-click to set ground target location...")
                                                                KeyWait, RButton, D
                                                                MouseGetPos, groundX, groundY
                                                                ; Convert screen coords to window-relative coords for saving
                                                                WinGetPos, winX, winY,,, ahk_id %win1%
                                                                groundX := groundX - winX
                                                                groundY := groundY - winY

                                                                ; Save ground target settings
                                                                dpsGroundTargetSkills[selectedDPS] := true
                                                                coordString := groundX . "," . groundY
                                                                dpsGroundTargetCoords[selectedDPS] := {x: groundX, y: groundY}
                                                                FileEncoding, UTF-8
                                                                IniWrite, true, %iniFile%, DPSGroundTarget, %selectedDPS%
                                                                IniWrite, %coordString%, %iniFile%, DPSGroundCoords, %selectedDPS%
                                                                FileEncoding

                                                                ; Confirmation message
                                                                MsgBox, 64, Ground Target Set, Ground target location has been set successfully!`n`nRelative coordinates: %groundX%`, %groundY%
                                                            } else {
                                                                UpdateDPSStatus("Ground target already enabled for this skill - keeping existing location")
                                                            }
                                                        } else {
                                                            ; Remove ground target if unchecked
                                                            dpsGroundTargetSkills[selectedDPS] := false
                                                            dpsGroundTargetCoords.Delete(selectedDPS)
                                                            IniDelete, %iniFile%, DPSGroundTarget, %selectedDPS%
                                                            IniDelete, %iniFile%, DPSGroundCoords, %selectedDPS%
                                                        }

                                                        ; Handle pre-cast key modification
                                                        if (ModifyDPSPreCast) {
                                                            ; If enabling pre-cast and it wasn't enabled before OR key needs updating
                                                            if (!dpsPressKeyBeforeCast.HasKey(selectedDPS) || !dpsPressKeyBeforeCast[selectedDPS] || !dpsPreCastKeys.HasKey(selectedDPS)) {
                                                                currentPreKey := dpsPreCastKeys.HasKey(selectedDPS) ? dpsPreCastKeys[selectedDPS] : ""
                                                                    InputBox, preCastKey, Pre-Cast Key, Enter the key to press BEFORE the main skill key (e.g. Tab):, , 350, 150, , , , , %currentPreKey%
                                                                    if (!ErrorLevel && preCastKey != "") {
                                                                        dpsPressKeyBeforeCast[selectedDPS] := true
                                                                        dpsPreCastKeys[selectedDPS] := preCastKey
                                                                        FileEncoding, UTF-8
                                                                        IniWrite, true, %iniFile%, DPSPreCastEnabled, %selectedDPS%
                                                                        IniWrite, %preCastKey%, %iniFile%, DPSPreCastKeys, %selectedDPS%
                                                                        FileEncoding
                                                                    }
                                                                }
                                                            } else {
                                                                ; Remove pre-cast if unchecked
                                                                dpsPressKeyBeforeCast[selectedDPS] := false
                                                                dpsPreCastKeys.Delete(selectedDPS)
                                                                IniDelete, %iniFile%, DPSPreCastEnabled, %selectedDPS%
                                                                IniDelete, %iniFile%, DPSPreCastKeys, %selectedDPS%
                                                            }

                                                            ; Force refresh priority list with timer to ensure GUI has processed
                                                            UpdateDPSStatus("Updated modifiers for '" . displayName . "'")
                                                            Gui, ModifyDPSOptions:Destroy
                                                            SetTimer, ForceRefreshDPS, -200
                                                            return

                                                            CancelDPSModifiers:
                                                                Gui, ModifyDPSOptions:Destroy
                                                            return

                                                            ShowDPSSkills:
                                                                statusMsg := "=== DPS SKILLS STATUS ===`r`n`r`nINI: " . iniFile . "`r`n`r`n"

                                                                if (dpsPatterns.Count() = 0) {
                                                                    statusMsg .= "No DPS skills captured yet.`r`n"
                                                                } else {
                                                                    dpsCount := 0
                                                                    for patternName, patternText in dpsPatterns {
                                                                        displayName := GetDPSDisplayName(patternName)
                                                                        key := dpsPatternKeys.HasKey(patternName) ? dpsPatternKeys[patternName] : "Click"
                                                                            statusMsg .= ++dpsCount . ". " . displayName . " [" . patternName . "] - " . key . "`r`n"
                                                                        }

                                                                        statusMsg .= "`r`n=== PRIORITY ORDER ===`r`n"
                                                                        for index, priorityPattern in dpsPriorities {
                                                                            if (dpsPatterns.HasKey(priorityPattern))
                                                                                statusMsg .= index . ". " . GetDPSDisplayName(priorityPattern) . "`r`n"
                                                                        }
                                                                    }

                                                                    UpdateDPSStatus(statusMsg)
                                                                    return

                                                                    AddCCSkill:
                                                                        UpdateCCStatus("Press 1 when the skill to capture is visable on screen.")
                                                                        KeyWait, 1, D
                                                                        capturedText := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)
                                                                        Clipboard := capturedText
                                                                        patternName := "cc" . ccCounter

                                                                        ; Prompt for custom name and key assignment
                                                                        InputBox, customName, Name CC Skill, Enter a name for this CC skill:, , 300, 130, , , , , %patternName%
                                                                            if (ErrorLevel)
                                                                            return

                                                                        if (customName = "")
                                                                            customName := patternName

                                                                        InputBox, assignedKey, Assign Key, Enter a key for this skill (leave empty to click with mouse):, , 300, 130
                                                                            if (ErrorLevel)
                                                                            return

                                                                        ; Prompt for stun duration
                                                                        InputBox, stunDuration, Stun Duration, Enter the stun duration in milliseconds (e.g. 2000 for 2 seconds):, , 300, 130, , , , , 2000
                                                                            if (ErrorLevel)
                                                                            return

                                                                        if (stunDuration = "" || !RegExMatch(stunDuration, "^\d+$"))
                                                                            stunDuration := 2000

                                                                        SaveCCPattern(patternName, capturedText, assignedKey, customName, stunDuration)
                                                                        UpdateCCStatus("CC skill captured and saved as '" . customName . "' [" . patternName . "] with " . stunDuration . "ms stun")
                                                                        ccCounter++

                                                                        ; Add to priority list at the end
                                                                        ccPriorities.Push(patternName)
                                                                        SaveCCPriorities()
                                                                        RefreshCCPriorityList()
                                                                    return

                                                                    TestCCSkills:
                                                                        if (ccPatterns.Count() = 0) {
                                                                            UpdateCCStatus("No CC skills captured. Add some skills first.")
                                                                            return
                                                                        }

                                                                        UpdateCCStatus("Testing CC skills - searching for patterns on screen...")

                                                                        foundCount := 0
                                                                        totalCount := 0

                                                                        ; Test each CC pattern
                                                                        for patternName, patternText in ccPatterns {
                                                                            totalCount++
                                                                            displayName := GetCCDisplayName(patternName)

                                                                            ; Search in the skill bar area - convert window-relative to screen coordinates
                                                                            WinGetPos, winX, winY,,, ahk_id %win1%
                                                                            screenX1 := winX + SkillBarX1
                                                                            screenY1 := winY + SkillBarY1
                                                                            screenX2 := winX + SkillBarX2
                                                                            screenY2 := winY + SkillBarY2
                                                                            if (ok := FindText(X, Y, screenX1, screenY1, screenX2, screenY2, 0, 0, patternText)) {
                                                                                foundCount++
                                                                                UpdateCCStatus("✓ FOUND: " . displayName . " at coordinates: " . X . ", " . Y)

                                                                                ; Highlight the found skill
                                                                                Try {
                                                                                    For i, v in ok {
                                                                                        if (i <= 2)
                                                                                            FindText().MouseTip(ok[i].x, ok[i].y)
                                                                                    }
                                                                                }
                                                                            } else {
                                                                                UpdateCCStatus("✗ Not found: " . displayName)
                                                                            }
                                                                        }

                                                                        UpdateCCStatus("Test complete - Found " . foundCount . " out of " . totalCount . " CC skills on screen.")
                                                                    return

                                                                    ClearCCSkills:
                                                                        InputBox, patternToClear, Clear CC Pattern, Enter the name of the CC pattern to clear (leave empty to clear all):, , 300, 130
                                                                        if (ErrorLevel)
                                                                            return

                                                                        if (patternToClear = "") {
                                                                            ccPatterns := {}
                                                                            ccPatternKeys := {}
                                                                            ccPatternNames := {}
                                                                            ccPriorities := []
                                                                            IniDelete, %iniFile%, CCPatterns
                                                                            IniDelete, %iniFile%, CCPatternKeys
                                                                            IniDelete, %iniFile%, CCPatternNames
                                                                            IniDelete, %iniFile%, CCPriorities
                                                                            ccCounter := 1
                                                                            RefreshCCPriorityList()
                                                                            UpdateCCStatus("All CC patterns have been cleared.")
                                                                        } else {
                                                                            ; Check both pattern name and custom name
                                                                            patternToDelete := ""
                                                                            for ccPat, ccText in ccPatterns {
                                                                                displayName := GetCCDisplayName(ccPat)
                                                                                if (ccPat = patternToClear || displayName = patternToClear) {
                                                                                    patternToDelete := ccPat
                                                                                    break
                                                                                }
                                                                            }

                                                                            if (patternToDelete != "") {
                                                                                ccPatterns.Delete(patternToDelete)
                                                                                ccPatternKeys.Delete(patternToDelete)
                                                                                ccPatternNames.Delete(patternToDelete)

                                                                                ; Remove from priority list
                                                                                for index, priorityPattern in ccPriorities {
                                                                                    if (priorityPattern = patternToDelete) {
                                                                                        ccPriorities.RemoveAt(index)
                                                                                        break
                                                                                    }
                                                                                }

                                                                                IniDelete, %iniFile%, CCPatterns, %patternToDelete%
                                                                                IniDelete, %iniFile%, CCPatternKeys, %patternToDelete%
                                                                                IniDelete, %iniFile%, CCPatternNames, %patternToDelete%
                                                                                SaveCCPriorities()
                                                                                RefreshCCPriorityList()
                                                                                UpdateCCStatus("CC pattern '" . patternToClear . "' has been cleared.")
                                                                            } else {
                                                                                UpdateCCStatus("CC pattern '" . patternToClear . "' not found.")
                                                                            }
                                                                        }
                                                                    return

                                                                    AssignCCKeys:
                                                                        ; Show available CC skills and let user assign keys
                                                                        ccList := "=== ASSIGN KEYS TO CC SKILLS ===`n`n"
                                                                        ccCount := 0

                                                                        for patternName, patternText in ccPatterns {
                                                                            ccCount++
                                                                            displayName := GetCCDisplayName(patternName)
                                                                            currentKey := ccPatternKeys.HasKey(patternName) ? ccPatternKeys[patternName] : "(none)"

                                                                                ccList .= ccCount . ". " . displayName . " [" . patternName . "]`n"
                                                                                ccList .= " Current Key: " . currentKey . "`n`n"
                                                                            }

                                                                            if (ccCount = 0) {
                                                                                UpdateCCStatus("No CC skills to assign keys to. Capture some skills first.")
                                                                            return
                                                                        }

                                                                        ccList .= "`nEnter the number of the CC skill to assign a key to:"

                                                                        InputBox, ccNumber, Assign CC Key, %ccList%, , 400, 300
                                                                        if (ErrorLevel)
                                                                            return

                                                                        ; Find the selected CC skill
                                                                        currentIndex := 1
                                                                        selectedCC := ""
                                                                        for patternName, patternText in ccPatterns {
                                                                            if (currentIndex = ccNumber) {
                                                                                selectedCC := patternName
                                                                                break
                                                                            }
                                                                            currentIndex++
                                                                        }

                                                                        if (selectedCC = "") {
                                                                            UpdateCCStatus("Invalid CC skill number selected.")
                                                                            return
                                                                        }

                                                                        ; Get key assignment
                                                                        selectedDisplayName := GetCCDisplayName(selectedCC)
                                                                        currentKey := ccPatternKeys.HasKey(selectedCC) ? ccPatternKeys[selectedCC] : ""
                                                                            keyPrompt := "=== ASSIGN KEY ===`n`nCC Skill: " . selectedDisplayName . "`nID: " . selectedCC . "`nCurrent Key: " . currentKey . "`n`nEnter new key (examples: 1, 2, F1, F2, etc.):"
                                                                            InputBox, newKey, Assign Key to CC Skill, %keyPrompt%, , 400, 200, , , , , %currentKey%
                                                                            if (ErrorLevel)
                                                                                return

                                                                            ; Save the assignment
                                                                            ccPatternKeys[selectedCC] := newKey
                                                                            SaveCCPatternKey(selectedCC, newKey)
                                                                            UpdateCCStatus("Assigned key '" . newKey . "' to '" . selectedDisplayName . "' [" . selectedCC . "] and saved to INI")
                                                                            RefreshCCPriorityList()
                                                                        return

                                                                        RenameCCSkills:
                                                                            if (ccPatterns.Count() = 0) {
                                                                                UpdateCCStatus("No CC skills to rename.")
                                                                                return
                                                                            }

                                                                            ; Build skill list and selection array in one pass
                                                                            ccList := "=== RENAME CC SKILLS ===`n`n"
                                                                            skillArray := []

                                                                            for patternName, patternText in ccPatterns {
                                                                                skillArray.Push(patternName)
                                                                                displayName := GetCCDisplayName(patternName)
                                                                                status := (displayName != patternName) ? "(Custom)" : "(Default)"
                                                                                    ccList .= skillArray.Length() . ". " . displayName . " [" . patternName . "] " . status . "`n"
                                                                                }

                                                                                ; Create scrollable GUI instead of InputBox
                                                                                Gui, RenameCCSelect:New, +Resize, Rename CC Skill
                                                                                Gui, RenameCCSelect:Add, Edit, x10 y10 w580 h320 ReadOnly VScroll, %ccList%`n`nEnter skill number:
                                                                                Gui, RenameCCSelect:Add, Edit, x10 y340 w100 h20 vCCNumberInput
                                                                                Gui, RenameCCSelect:Add, Button, x120 y340 w60 h20 gRenameCCSelectOK, OK
                                                                                Gui, RenameCCSelect:Add, Button, x190 y340 w60 h20 gRenameCCSelectCancel, Cancel
                                                                                Gui, RenameCCSelect:Show, w600 h380
                                                                                return

                                                                                RenameCCSelectOK:
                                                                                    Gui, RenameCCSelect:Submit
                                                                                    ccNumber := CCNumberInput
                                                                                    if (ccNumber < 1 || ccNumber > skillArray.Length()) {
                                                                                        UpdateCCStatus("Invalid selection.")
                                                                                        return
                                                                                    }
                                                                                    Gui, RenameCCSelect:Destroy

                                                                                    selectedCC := skillArray[ccNumber]
                                                                                    currentDisplayName := GetCCDisplayName(selectedCC)

                                                                                    InputBox, newName, Rename CC Skill, Original: %selectedCC%`nCurrent: %currentDisplayName%`n`nNew name:, , 400, 180, , , , , %currentDisplayName%
                                                                                    if (ErrorLevel || newName = "") {
                                                                                        if (!ErrorLevel) UpdateCCStatus("Name cannot be empty.")
                                                                                            return
                                                                                    }

                                                                                    ; Update in-memory object directly
                                                                                    ccPatternNames[selectedCC] := newName
                                                                                    SaveCCPatternName(selectedCC, newName)
                                                                                    UpdateCCStatus("Renamed '" . selectedCC . "' to '" . newName . "'")

                                                                                    ; Force refresh with timer
                                                                                    SetTimer, ForceRefreshCC, -50
                                                                                return

                                                                                RenameCCSelectCancel:
                                                                                    Gui, RenameCCSelect:Destroy
                                                                                return

                                                                                ShowCCSkills:
                                                                                    statusMsg := "=== CC SKILLS STATUS ===`r`n`r`nINI: " . iniFile . "`r`n`r`n"

                                                                                    if (ccPatterns.Count() = 0) {
                                                                                        statusMsg .= "No CC skills captured yet.`r`n"
                                                                                    } else {
                                                                                        ccCount := 0
                                                                                        for patternName, patternText in ccPatterns {
                                                                                            displayName := GetCCDisplayName(patternName)
                                                                                            key := ccPatternKeys.HasKey(patternName) ? ccPatternKeys[patternName] : "Click"
                                                                                                statusMsg .= ++ccCount . ". " . displayName . " [" . patternName . "] - " . key . "`r`n"
                                                                                            }

                                                                                            statusMsg .= "`r`n=== PRIORITY ORDER ===`r`n"
                                                                                            for index, priorityPattern in ccPriorities {
                                                                                                if (ccPatterns.HasKey(priorityPattern))
                                                                                                    statusMsg .= index . ". " . GetCCDisplayName(priorityPattern) . "`r`n"
                                                                                            }
                                                                                        }

                                                                                        UpdateCCStatus(statusMsg)
                                                                                        return
                                                                                        StartDPSScript:
                                                                                            if (TargetGameWindow = "") {
                                                                                                UpdateDPSStatus("Please select a target window first using the Healer tab.")
                                                                                                return
                                                                                            }

                                                                                            if (dpsPatterns.Count() = 0) {
                                                                                                UpdateDPSStatus("No DPS skills captured. Add some skills first.")
                                                                                                return
                                                                                            }

                                                                                            ; If DPS + Heal Combo is enabled, stop standalone healer
                                                                                            if (healanddps) {
                                                                                                SetTimer, DynamicHealthCheck, Off
                                                                                                UpdateHealerStatus("Standalone healer stopped - DPS loop will handle healing")
                                                                                            }

                                                                                            isDpsRunning := true
                                                                                            SetTimer, DPSLoop, 50 ; Check every 300ms for better weaving  

                                                                                            if (healanddps) {
                                                                                                UpdateDPSStatus("DPS + Healing combo started. DPS loop will weave healing and DPS.")
                                                                                            } else {
                                                                                                UpdateDPSStatus("DPS script started. Will weave with healing and buffs using priority order.")
                                                                                            }
                                                                                        return

                                                                                        StopDPSScript:
                                                                                            isDpsRunning := false
                                                                                            SetTimer, DPSLoop, Off
                                                                                            UpdateDPSStatus("DPS script stopped.")
                                                                                        return

                                                                                        DPSLoop:
                                                                                            ; Check if Critical mode is enabled
                                                                                            if (CriticalModeEnabled) {
                                                                                                return
                                                                                            }
                                                                                            if (!isDpsRunning)
                                                                                            {
                                                                                                return
                                                                                            }
                                                                                            ; DPS has second priority - yield to healing
                                                                                            ; if (isSystemBusy) {
                                                                                            ;     ;ActivateGameWindow()
                                                                                            ;     return ; Skip this cycle if system is busy with healing
                                                                                            ; }
                                                                                            if (healanddps)
                                                                                            {
                                                                                                gosub, DynamicHealthCheck
                                                                                            }

                                                                                            ;Check DPS Navigation if enabled
                                                                                            if (dpsNavEnabled && dpsNavTargetX != "" && dpsNavTargetY != "") {
                                                                                                Loop {
                                                                                                    CheckDPSNavigation()
                                                                                                    GetNavCurrentCoordinates(currentX, currentY)
                                                                                                    if (Abs(currentX - dpsNavTargetX) <= dpsNavRadius && Abs(currentY - dpsNavTargetY) <= dpsNavRadius) {
                                                                                                        ControlSend,, {tab}, ahk_id %win1%
                                                                                                        break
                                                                                                    }
                                                                                                    Sleep, 100
                                                                                                }
                                                                                                if (arrived)
                                                                                                {
                                                                                                    ; SendMessageClick3(pylonPos1X, pylonPos1Y, win1)
                                                                                                    ; Sleep, 100
                                                                                                    ; SendMessageClick3(pylonPos2X, pylonPos2Y, win1)
                                                                                                    ; Sleep, 100
                                                                                                    ; SendMessageClick3(pylonPos2X, pylonPos2Y, win1)
                                                                                                    ; Sleep, 100
                                                                                                    ; SendMessageClick3(pylonPos2X, pylonPos2Y, win1)
                                                                                                    ; Sleep, 100
                                                                                                    ; decopetorplayertargetted:="|<>7D7D7D-0.90$71.000000000000000000000000000000000000000000000000S0000G00S0U0W0000U00a1012xvqzgLV5zU25+4c+Id2OI04DsEHofz7jc08QEUgdJU8ME0F8FZNGN0EEU0wSxuSoXkUxk00000000000000000000000000000000000000000000000000000000000E"

                                                                                                    ; decopetorplayertargetted.="|<>*86$56.zzzzzzzzzzzzzzzzzzzzzzzzzzzzzyTzzzrjvzz3zzzzlwTzUTxyRyCDzk3m8WTl7zs0QFF7y3zw03081zlzy00zkTzsDz00TyDzwFzU0DzrzyCDk07zzzz7lw03zzzzvyzU1y000zzzw0zzzzzzzzcTzzzzzzzxDzzzzzzzzbzzzzzzzzzzzzzzzzy"

                                                                                                    ; if (ok:=FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, decopetorplayertargetted))
                                                                                                    ; {
                                                                                                    sendmessage, 0x100, ox1b, 0, , ahk_id %win1% ; esc_KEYDOWN
                                                                                                    Sleep, 50
                                                                                                    sendmessage, 0x101, ox1b, 0, , ahk_id %win1% ; esc_KEYUP
                                                                                                    sendmessage, 0x100, ox1b, 0, , ahk_id %win1% ; esc_KEYDOWN
                                                                                                    Sleep, 50
                                                                                                    sendmessage, 0x101, ox1b, 0, , ahk_id %win1% ; esc_KEYUP

                                                                                                    ;}
                                                                                                    arrived := false
                                                                                                }

                                                                                            }

                                                                                            TryCastDPSSkills()
                                                                                            ; Add a check to ensure dpsandheal is properly updated when checkbox changes
                                                                                            sleep, 75
                                                                                            ; Release system busy flag
                                                                                            TryCastCC()
                                                                                            ;isSystemBusy := false
                                                                                        return
                                                                                        TryCastDPSSkillsold() {
                                                                                            global dpsPatterns, dpsPatternKeys, dpsPriorities
                                                                                            global SkillBarX1, SkillBarY1, SkillBarX2, SkillBarY2, isDpsRunning
                                                                                            global SequentialDPSEnabled, CurrentSequentialIndex

                                                                                            if (SequentialDPSEnabled) {
                                                                                                ; Sequential mode - ONLY try the current skill in order, don't skip
                                                                                                if (CurrentSequentialIndex > dpsPriorities.MaxIndex()) {
                                                                                                    CurrentSequentialIndex := 1 ; Loop back to first skill
                                                                                                }

                                                                                                priorityPattern := dpsPriorities[CurrentSequentialIndex]

                                                                                                if (!dpsPatterns.HasKey(priorityPattern)) {
                                                                                                    ; If pattern doesn't exist, skip to next but don't cast anything
                                                                                                    CurrentSequentialIndex++
                                                                                                    return false
                                                                                                }

                                                                                                patternText := dpsPatterns[priorityPattern]

                                                                                                ; Convert window-relative coordinates to screen coordinates
                                                                                                WinGetPos, winX, winY,,, ahk_id %win1%

                                                                                                ; Validate window position first
                                                                                                if (winX = "" || winY = "" || winX < 0 || winY < 0) {
                                                                                                    return false
                                                                                                }

                                                                                                global screenX1 := winX + SkillBarX1
                                                                                                global screenY1 := winY + SkillBarY1
                                                                                                global screenX2 := winX + SkillBarX2
                                                                                                global screenY2 := winY + SkillBarY2

                                                                                                global dpsSkill := FindText(X, Y, screenX1, screenY1, screenX2, screenY2, 0, 0, patternText)

                                                                                                if (dpsSkill) {
                                                                                                    ; ONLY cast if we found the exact skill we're looking for
                                                                                                    displayName := GetDPSDisplayName(priorityPattern)
                                                                                                    hasKey := dpsPatternKeys.HasKey(priorityPattern) && dpsPatternKeys[priorityPattern] != ""
                                                                                                    skillCastSuccessfully := false

                                                                                                    if (hasKey) {
                                                                                                        keyToPress := dpsPatternKeys[priorityPattern]

                                                                                                        ; Check for modifier keys
                                                                                                        hasCtrl := InStr(keyToPress, "^")
                                                                                                        hasAlt := InStr(keyToPress, "!")
                                                                                                        hasShift := InStr(keyToPress, "+")

                                                                                                        ; Extract the base key (remove modifiers)
                                                                                                        baseKey := keyToPress
                                                                                                        if (hasCtrl)
                                                                                                            baseKey := StrReplace(baseKey, "^")
                                                                                                        if (hasAlt)
                                                                                                            baseKey := StrReplace(baseKey, "!")
                                                                                                        if (hasShift)
                                                                                                            baseKey := StrReplace(baseKey, "+")

                                                                                                        ; Send modifier keys down
                                                                                                        if (hasCtrl)
                                                                                                            ControlSend,, {Ctrl down}, ahk_id %win1%
                                                                                                        if (hasAlt)
                                                                                                            ControlSend,, {Alt down}, ahk_id %win1%
                                                                                                        if (hasShift)
                                                                                                            ControlSend,, {Shift down}, ahk_id %win1%

                                                                                                        ; Send the base key
                                                                                                        ControlSend,, {%baseKey% down}, ahk_id %win1%
                                                                                                        Sleep, 50
                                                                                                        ControlSend,, {%baseKey% up}, ahk_id %win1%

                                                                                                        ; Release modifiers (reverse order)
                                                                                                        if (hasShift)
                                                                                                            ControlSend,, {Shift up}, ahk_id %win1%
                                                                                                        if (hasAlt)
                                                                                                            ControlSend,, {Alt up}, ahk_id %win1%
                                                                                                        if (hasCtrl)
                                                                                                            ControlSend,, {Ctrl up}, ahk_id %win1%

                                                                                                        skillCastSuccessfully := true

                                                                                                    } else {
                                                                                                        if (IsObject(dpsSkill) && dpsSkill.MaxIndex() >= 1) {
                                                                                                            X := dpsSkill.1.x
                                                                                                            Y := dpsSkill.1.y

                                                                                                            if (X > 0 && Y > 0 && X < A_ScreenWidth && Y < A_ScreenHeight) {
                                                                                                                ToolTip, Sequential DPS Click at %X%`, %Y%, , , 1
                                                                                                                SendMessageClick(X, Y)
                                                                                                                skillCastSuccessfully := true
                                                                                                            }
                                                                                                        }
                                                                                                    }

                                                                                                    if (skillCastSuccessfully) {
                                                                                                        method := hasKey ? "key: " . dpsPatternKeys[priorityPattern] : "clicking"
                                                                                                        prefix := isDpsRunning ? "" : "TEST: "
                                                                                                            UpdateDPSStatus(prefix . "Sequential: Used " . displayName . " (" . CurrentSequentialIndex . "/" . dpsPriorities.MaxIndex() . ") with " . method)

                                                                                                            CurrentSequentialIndex++ ; ONLY move to next skill AFTER successful cast
                                                                                                            Sleep, 150
                                                                                                        return true
                                                                                                    }
                                                                                                } else {
                                                                                                    ; Skill not available - DO NOT move to next skill, just return false and wait
                                                                                                    ; This means we'll keep looking for the same skill on the next call
                                                                                                    displayName := GetDPSDisplayName(priorityPattern)
                                                                                                    if (!isDpsRunning) {
                                                                                                        UpdateDPSStatus("Sequential: Waiting for " . displayName . " (" . CurrentSequentialIndex . "/" . dpsPriorities.MaxIndex() . ")")
                                                                                                    }
                                                                                                    return false ; Don't cast anything, don't advance index
                                                                                                }

                                                                                                return false

                                                                                            } else {
                                                                                                ; Original availability-based mode (unchanged)
                                                                                                for index, priorityPattern in dpsPriorities {
                                                                                                    if (!dpsPatterns.HasKey(priorityPattern))
                                                                                                        continue

                                                                                                    patternText := dpsPatterns[priorityPattern]
                                                                                                    ; Convert window-relative coordinates to screen coordinates
                                                                                                    WinGetPos, winX, winY,,, ahk_id %win1%

                                                                                                    ; Validate window position first
                                                                                                    if (winX = "" || winY = "" || winX < 0 || winY < 0) {
                                                                                                        return false
                                                                                                    }

                                                                                                    global screenX1 := winX + SkillBarX1
                                                                                                    global screenY1 := winY + SkillBarY1
                                                                                                    global screenX2 := winX + SkillBarX2
                                                                                                    global screenY2 := winY + SkillBarY2

                                                                                                    global dpsSkill := FindText(X, Y, screenX1, screenY1, screenX2, screenY2, 0, 0, patternText)

                                                                                                    if (dpsSkill) {
                                                                                                        displayName := GetDPSDisplayName(priorityPattern)
                                                                                                        hasKey := dpsPatternKeys.HasKey(priorityPattern) && dpsPatternKeys[priorityPattern] != ""

                                                                                                        ; Execute skill with spam protection
                                                                                                        spamCount := 0
                                                                                                        skillCastSuccessfully := false

                                                                                                        Loop, 5 { ; Max 5 attempts
                                                                                                            spamCount++

                                                                                                            if (hasKey) {
                                                                                                                keyToPress := dpsPatternKeys[priorityPattern]

                                                                                                                ; Check for modifier keys
                                                                                                                hasCtrl := InStr(keyToPress, "^")
                                                                                                                hasAlt := InStr(keyToPress, "!")
                                                                                                                hasShift := InStr(keyToPress, "+")

                                                                                                                ; Extract the base key (remove modifiers)
                                                                                                                baseKey := keyToPress
                                                                                                                if (hasCtrl)
                                                                                                                    baseKey := StrReplace(baseKey, "^")
                                                                                                                if (hasAlt)
                                                                                                                    baseKey := StrReplace(baseKey, "!")
                                                                                                                if (hasShift)
                                                                                                                    baseKey := StrReplace(baseKey, "+")

                                                                                                                ; Send modifier keys down
                                                                                                                if (hasCtrl)
                                                                                                                    ControlSend,, {Ctrl down}, ahk_id %win1%
                                                                                                                if (hasAlt)
                                                                                                                    ControlSend,, {Alt down}, ahk_id %win1%
                                                                                                                if (hasShift)
                                                                                                                    ControlSend,, {Shift down}, ahk_id %win1%

                                                                                                                ; Send the base key
                                                                                                                ControlSend,, {%baseKey% down}, ahk_id %win1%
                                                                                                                Sleep, 50
                                                                                                                ControlSend,, {%baseKey% up}, ahk_id %win1%

                                                                                                                ; Release modifiers (reverse order)
                                                                                                                if (hasShift)
                                                                                                                    ControlSend,, {Shift up}, ahk_id %win1%
                                                                                                                if (hasAlt)
                                                                                                                    ControlSend,, {Alt up}, ahk_id %win1%
                                                                                                                if (hasCtrl)
                                                                                                                    ControlSend,, {Ctrl up}, ahk_id %win1%

                                                                                                                skillCastSuccessfully := true

                                                                                                            } else {
                                                                                                                if (IsObject(dpsSkill) && dpsSkill.MaxIndex() >= 1) {
                                                                                                                    X := dpsSkill.1.x
                                                                                                                    Y := dpsSkill.1.y

                                                                                                                    if (X > 0 && Y > 0 && X < A_ScreenWidth && Y < A_ScreenHeight) {
                                                                                                                        ToolTip, DPS Click at %X%`, %Y%, , , 1
                                                                                                                        SendMessageClick(X, Y)
                                                                                                                        skillCastSuccessfully := true
                                                                                                                    } else {
                                                                                                                        break
                                                                                                                    }
                                                                                                                } else {
                                                                                                                    break
                                                                                                                }
                                                                                                            }

                                                                                                            ; Recheck availability (search full screen width for 4K monitors)
                                                                                                            Sleep, 125
                                                                                                            recheckSkill := FindText(X, Y, 0, screenY1, A_ScreenWidth, screenY2, 0, 0, patternText)
                                                                                                            if (!recheckSkill) {
                                                                                                                break
                                                                                                            }
                                                                                                        }

                                                                                                        if (skillCastSuccessfully) {
                                                                                                        method := hasKey ? "key: " . dpsPatternKeys[priorityPattern] : "clicking"
                                                                                                        prefix := isDpsRunning ? "" : "TEST: "
                                                                                                            UpdateDPSStatus(prefix . "Used " . displayName . " with " . method . " (" . spamCount . "x)")
                                                                                                            Sleep, 150
                                                                                                        return true
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            if (!isDpsRunning)
                                                                                                UpdateDPSStatus("No DPS skills found on screen.")
                                                                                            return false
                                                                                        }
                                                                                    }
                                                                                    SequentialDPSMode:
                                                                                        Gui, Submit, NoHide
                                                                                        SequentialDPSEnabled := SequentialDPSMode
                                                                                        if (SequentialDPSEnabled) {
                                                                                            UpdateDPSStatus("Sequential DPS Mode: ENABLED - Skills will cast in priority order only")
                                                                                            CurrentSequentialIndex := 1 ; Reset to first skill
                                                                                        } else {
                                                                                            UpdateDPSStatus("Sequential DPS Mode: DISABLED - Normal availability-based casting")
                                                                                        }
                                                                                    return

                                                                                    MeleeAttackToggle:
                                                                                        Gui, Submit, NoHide
                                                                                        if (meleeAttackEnabled) {
                                                                                            GuiControl, Show, MeleeKeyLabel
                                                                                            GuiControl, Show, meleeAttackKey
                                                                                            UpdateDPSStatus("Melee Attack: ENABLED - Will send melee key after each successful skill cast")
                                                                                        } else {
                                                                                            GuiControl, Hide, MeleeKeyLabel
                                                                                            GuiControl, Hide, meleeAttackKey
                                                                                            UpdateDPSStatus("Melee Attack: DISABLED")
                                                                                        }
                                                                                        ; Save to INI
                                                                                        IniWrite, %meleeAttackEnabled%, %SettingsFile%, Settings, meleeAttackEnabled
                                                                                    return

                                                                                    meleeKeyChanged:
                                                                                        Gui, Submit, NoHide
                                                                                        ; Save to INI
                                                                                        IniWrite, %meleeAttackKey%, %SettingsFile%, Settings, meleeAttackKey
                                                                                        if (meleeAttackKey != "")
                                                                                            UpdateDPSStatus("melee attack key set to: " . meleeAttackKey)
                                                                                    return
                                                                                    UseRefreshScroll:
                                                                                        if (refreshscrollEnabled) {
                                                                                            ; Simulate refresh scroll key press
                                                                                            if (refreshKey != "") {
                                                                                                ; Check for modifier keys
                                                                                                hasCtrl := InStr(refreshKey, "^")
                                                                                                hasAlt := InStr(refreshKey, "!")
                                                                                                hasShift := InStr(refreshKey, "+")

                                                                                                ; Extract the base key (remove modifiers)
                                                                                                baseKey := refreshKey
                                                                                                if (hasCtrl)
                                                                                                    baseKey := StrReplace(baseKey, "^")
                                                                                                if (hasAlt)
                                                                                                    baseKey := StrReplace(baseKey, "!")
                                                                                                if (hasShift)
                                                                                                    baseKey := StrReplace(baseKey, "+")

                                                                                                ; Send modifier keys down
                                                                                                if (hasCtrl)
                                                                                                    ControlSend,, {Ctrl down}, ahk_id %win1%
                                                                                                if (hasAlt)
                                                                                                    ControlSend,, {Alt down}, ahk_id %win1%
                                                                                                if (hasShift)
                                                                                                    ControlSend,, {Shift down}, ahk_id %win1%

                                                                                                ; Send the base key
                                                                                                ControlSend,, {%baseKey% down}, ahk_id %win1%
                                                                                                Sleep, 50
                                                                                                ControlSend,, {%baseKey% up}, ahk_id %win1%

                                                                                                ; Release modifiers (reverse order)
                                                                                                if (hasShift)
                                                                                                    ControlSend,, {Shift up}, ahk_id %win1%
                                                                                                if (hasAlt)
                                                                                                    ControlSend,, {Alt up}, ahk_id %win1%
                                                                                                if (hasCtrl)
                                                                                                    ControlSend,, {Ctrl up}, ahk_id %win1%

                                                                                            }
                                                                                            refreshScrollEndTime := A_TickCount + 3600000
                                                                                        }

                                                                                    UpdateRefreshScrollTimer:
                                                                                        remaining := refreshScrollEndTime - A_TickCount
                                                                                        if (remaining < 0)
                                                                                            remaining := 0
                                                                                        hours := Floor(remaining / 3600000)
                                                                                        minutes := Floor(Mod(remaining, 3600000) / 60000)
                                                                                        seconds := Floor(Mod(remaining, 60000) / 1000)
                                                                                        GuiControl,, refreshScrollTimer, % "Time left: " . Format("{:02}:{:02}:{:02}", hours, minutes, seconds)
                                                                                    return

                                                                                    return
                                                                                    refreshscrollToggle:
                                                                                        Gui, Submit, NoHide
                                                                                        if (refreshscrollEnabled) {
                                                                                            GuiControl, Show, refreshKeyLabel
                                                                                            GuiControl, Show, refreshKey
                                                                                            Gosub, userefreshscroll
                                                                                            refreshScrollEndTime := A_TickCount + 3600000
                                                                                            SetTimer, UpdateRefreshScrollTimer, 1000
                                                                                            SetTimer, userefreshscroll, 3600000
                                                                                        } else {
                                                                                            GuiControl, Hide, refreshKeyLabel
                                                                                            GuiControl, Hide, refreshKey
                                                                                            SetTimer, UpdateRefreshScrollTimer, Off
                                                                                            SetTimer, userefreshscroll, Off
                                                                                            GuiControl,, refreshScrollTimer, Time left: --:--:--
                                                                                        }
                                                                                        IniWrite, %refreshscrollEnabled%, %SettingsFile%, Settings, refreshscrollEnabled
                                                                                    return

                                                                                    refreshKeyChanged:
                                                                                        Gui, Submit, NoHide
                                                                                        ; Save to INI
                                                                                        IniWrite, %refreshKey%, %SettingsFile%, Settings, refreshKey
                                                                                        if (refreshKey != "")
                                                                                            UpdateDPSStatus("Refresh key set to: " . refreshKey)
                                                                                    return

                                                                                    ; DPS Priority Management
                                                                                    DPSPrioritySelect:
                                                                                    return

                                                                                    MoveDPSUp:
                                                                                        ; Get the currently selected item index from the ListBox
                                                                                        GuiControlGet, selectedText, , DPSPriorityList
                                                                                        selectedIndex := 0

                                                                                        ; Parse the index from the text (format: "1. SkillName")
                                                                                        if (selectedText != "") {
                                                                                            RegExMatch(selectedText, "^(\d+)\.", match)
                                                                                            selectedIndex := match1
                                                                                        }

                                                                                        ; Debug info
                                                                                        UpdateDPSStatus("Debug: Selected text = '" . selectedText . "', Parsed index = " . selectedIndex . ", Total items = " . dpsPriorities.Length())

                                                                                        if (selectedIndex <= 1 || selectedIndex > dpsPriorities.Length()) {
                                                                                            UpdateDPSStatus("Cannot move item up. Select an item first or item is already at top.")
                                                                                            return
                                                                                        }

                                                                                        ; Swap with previous item
                                                                                        temp := dpsPriorities[selectedIndex]
                                                                                        dpsPriorities[selectedIndex] := dpsPriorities[selectedIndex - 1]
                                                                                        dpsPriorities[selectedIndex - 1] := temp

                                                                                        SaveDPSPriorities()
                                                                                        RefreshDPSPriorityList()

                                                                                        ; Reselect the moved item
                                                                                        GuiControl, Choose, DPSPriorityList, % selectedIndex - 1

                                                                                        UpdateDPSStatus("Moved DPS skill up in priority.")
                                                                                    return

                                                                                    MoveDPSDown:
                                                                                        ; Get the currently selected item index from the ListBox
                                                                                        GuiControlGet, selectedText, , DPSPriorityList
                                                                                        selectedIndex := 0

                                                                                        ; Parse the index from the text (format: "1. SkillName")
                                                                                        if (selectedText != "") {
                                                                                            RegExMatch(selectedText, "^(\d+)\.", match)
                                                                                            selectedIndex := match1
                                                                                        }

                                                                                        ; Debug info
                                                                                        UpdateDPSStatus("Debug: Selected text = '" . selectedText . "', Parsed index = " . selectedIndex . ", Total items = " . dpsPriorities.Length())

                                                                                        if (selectedIndex <= 0 || selectedIndex >= dpsPriorities.Length()) {
                                                                                            UpdateDPSStatus("Cannot move item down. Select an item first or item is already at bottom.")
                                                                                            return
                                                                                        }

                                                                                        ; Swap with next item
                                                                                        temp := dpsPriorities[selectedIndex]
                                                                                        dpsPriorities[selectedIndex] := dpsPriorities[selectedIndex + 1]
                                                                                        dpsPriorities[selectedIndex + 1] := temp

                                                                                        SaveDPSPriorities()
                                                                                        RefreshDPSPriorityList()

                                                                                        ; Reselect the moved item
                                                                                        GuiControl, Choose, DPSPriorityList, % selectedIndex + 1

                                                                                        UpdateDPSStatus("Moved DPS skill down in priority.")
                                                                                    return

                                                                                    RefreshDPSList:
                                                                                        RefreshDPSPriorityList()
                                                                                        UpdateDPSStatus("DPS priority list refreshed.")
                                                                                    return

                                                                                    RemoveFromDPSPriority:
                                                                                        ; Get the currently selected item index from the ListBox
                                                                                        GuiControlGet, selectedText, , DPSPriorityList
                                                                                        selectedIndex := 0

                                                                                        ; Parse the index from the text (format: "1. SkillName")
                                                                                        if (selectedText != "") {
                                                                                            RegExMatch(selectedText, "^(\d+)\.", match)
                                                                                            selectedIndex := match1
                                                                                        }

                                                                                        if (selectedIndex <= 0 || selectedIndex > dpsPriorities.Length()) {
                                                                                            UpdateDPSStatus("Select a DPS skill to remove from priority.")
                                                                                            return
                                                                                        }

                                                                                        removedSkill := dpsPriorities[selectedIndex]
                                                                                        displayName := GetDPSDisplayName(removedSkill)
                                                                                        dpsPriorities.RemoveAt(selectedIndex)

                                                                                        SaveDPSPriorities()
                                                                                        RefreshDPSPriorityList()
                                                                                        UpdateDPSStatus("Removed '" . displayName . "' from DPS priority order (skill still saved).")
                                                                                    return

                                                                                    AddToDPSPriority:
                                                                                        ; Show available DPS skills not in priority
                                                                                        availableDPS := "=== ADD DPS SKILL TO PRIORITY ===`n`n"
                                                                                        availableCount := 0
                                                                                        availableSkills := []

                                                                                        for patternName, patternText in dpsPatterns {
                                                                                            ; Check if already in priority
                                                                                            inPriority := false
                                                                                            for index, priorityPattern in dpsPriorities {
                                                                                                if (priorityPattern = patternName) {
                                                                                                    inPriority := true
                                                                                                    break
                                                                                                }
                                                                                            }

                                                                                            if (!inPriority) {
                                                                                                availableCount++
                                                                                                availableSkills.Push(patternName)
                                                                                                displayName := GetDPSDisplayName(patternName)
                                                                                                availableDPS .= availableCount . ". " . displayName . " [" . patternName . "]`n"
                                                                                            }
                                                                                        }

                                                                                        if (availableCount = 0) {
                                                                                            UpdateDPSStatus("No DPS skills available to add (all are already in priority or none saved).")
                                                                                            return
                                                                                        }

                                                                                        availableDPS .= "`nEnter the number of the DPS skill to add to priority:"

                                                                                        InputBox, dpsNumber, Add DPS Skill to Priority, %availableDPS%, , 400, 300
                                                                                        if (ErrorLevel)
                                                                                            return

                                                                                        if (dpsNumber < 1 || dpsNumber > availableCount) {
                                                                                            UpdateDPSStatus("Invalid DPS skill number selected.")
                                                                                            return
                                                                                        }

                                                                                        selectedSkill := availableSkills[dpsNumber]
                                                                                        displayName := GetDPSDisplayName(selectedSkill)

                                                                                        ; Add to end of priority list
                                                                                        dpsPriorities.Push(selectedSkill)
                                                                                        SaveDPSPriorities()
                                                                                        RefreshDPSPriorityList()
                                                                                        UpdateDPSStatus("Added '" . displayName . "' to DPS priority order.")
                                                                                    return

                                                                                    RefreshDPSPriorityList() {
                                                                                        global dpsPatterns, dpsPatternNames, dpsPatternKeys, dpsPriorities
                                                                                        global dpsGroundTargetSkills, dpsPressKeyBeforeCast

                                                                                        ; Clear the listbox completely
                                                                                        GuiControl,, DPSPriorityList, |

                                                                                        ; Force rebuild the list
                                                                                        newList := ""
                                                                                        itemCount := 0
                                                                                        for index, priorityPattern in dpsPriorities {
                                                                                            if (dpsPatterns.HasKey(priorityPattern)) {
                                                                                                itemCount++
                                                                                                ; Force get fresh display name
                                                                                                displayName := dpsPatternNames.HasKey(priorityPattern) && dpsPatternNames[priorityPattern] != "" ? dpsPatternNames[priorityPattern] : priorityPattern
                                                                                                keyInfo := dpsPatternKeys.HasKey(priorityPattern) && dpsPatternKeys[priorityPattern] != "" ? " (Key: " . dpsPatternKeys[priorityPattern] . ")" : " (Click)"

                                                                                                    ; Add modifier indicators - check for true/1/"true"
                                                                                                    modifiers := ""
                                                                                                    hasGroundTarget := dpsGroundTargetSkills.HasKey(priorityPattern) && (dpsGroundTargetSkills[priorityPattern] = true || dpsGroundTargetSkills[priorityPattern] = 1 || dpsGroundTargetSkills[priorityPattern] = "true" || dpsGroundTargetSkills[priorityPattern] = "1")
                                                                                                    hasPreCast := dpsPressKeyBeforeCast.HasKey(priorityPattern) && (dpsPressKeyBeforeCast[priorityPattern] = true || dpsPressKeyBeforeCast[priorityPattern] = 1 || dpsPressKeyBeforeCast[priorityPattern] = "true" || dpsPressKeyBeforeCast[priorityPattern] = "1")

                                                                                                    if (hasGroundTarget && hasPreCast)
                                                                                                        modifiers := " [CB]"
                                                                                                    else if (hasGroundTarget)
                                                                                                        modifiers := " [C]"
                                                                                                    else if (hasPreCast)
                                                                                                        modifiers := " [B]"

                                                                                                    listItem := index . ". " . displayName . keyInfo . modifiers
                                                                                                    if (newList != "")
                                                                                                        newList .= "|"
                                                                                                    newList .= listItem
                                                                                                }
                                                                                            }

                                                                                            ; Set the entire list at once
                                                                                            GuiControl,, DPSPriorityList, %newList%

                                                                                            ; Show count for debugging
                                                                                            if (itemCount = 0 && dpsPriorities.Length() > 0) {
                                                                                                UpdateDPSStatus("Warning: " . dpsPriorities.Length() . " priorities but 0 valid patterns found")
                                                                                            }
                                                                                        }

                                                                                        ; DPS Helper Functions
                                                                                        SaveDPSPattern(patternName, patternText, keyAssignment, customName, isGroundTarget := false, groundX := "", groundY := "", needsPreCastKey := false, preCastKey := "") {
                                                                                            global iniFile, dpsPatterns, dpsPatternKeys, dpsPatternNames, dpsGroundTargetSkills, dpsGroundTargetCoords, dpsPressKeyBeforeCast, dpsPreCastKeys

                                                                                            FileEncoding, UTF-8
                                                                                            IniWrite, %patternText%, %iniFile%, DPSPatterns, %patternName%
                                                                                            IniWrite, %keyAssignment%, %iniFile%, DPSPatternKeys, %patternName%
                                                                                            IniWrite, %customName%, %iniFile%, DPSPatternNames, %patternName%

                                                                                            ; Save ground target settings
                                                                                            IniWrite, %isGroundTarget%, %iniFile%, DPSGroundTarget, %patternName%
                                                                                            if (isGroundTarget && groundX != "" && groundY != "") {
                                                                                                coordString := groundX . "," . groundY
                                                                                                IniWrite, %coordString%, %iniFile%, DPSGroundCoords, %patternName%
                                                                                            }

                                                                                            ; Save pre-cast key settings
                                                                                            IniWrite, %needsPreCastKey%, %iniFile%, DPSPreCastEnabled, %patternName%
                                                                                            if (needsPreCastKey && preCastKey != "") {
                                                                                                IniWrite, %preCastKey%, %iniFile%, DPSPreCastKeys, %patternName%
                                                                                            }
                                                                                            FileEncoding

                                                                                            dpsPatterns[patternName] := patternText
                                                                                            dpsPatternKeys[patternName] := keyAssignment
                                                                                            dpsPatternNames[patternName] := customName
                                                                                            dpsGroundTargetSkills[patternName] := isGroundTarget
                                                                                            if (isGroundTarget && groundX != "" && groundY != "") {
                                                                                                dpsGroundTargetCoords[patternName] := {x: groundX, y: groundY}
                                                                                            }
                                                                                            dpsPressKeyBeforeCast[patternName] := needsPreCastKey
                                                                                            if (needsPreCastKey && preCastKey != "") {
                                                                                                dpsPreCastKeys[patternName] := preCastKey
                                                                                            }
                                                                                        }

                                                                                        SaveDPSPatternKey(patternName, keyAssignment) {
                                                                                            global iniFile, dpsPatternKeys

                                                                                            FileEncoding, UTF-8
                                                                                            IniWrite, %keyAssignment%, %iniFile%, DPSPatternKeys, %patternName%
                                                                                            FileEncoding
                                                                                            dpsPatternKeys[patternName] := keyAssignment
                                                                                        }

                                                                                        SaveDPSPatternName(patternName, customName) {
                                                                                            global iniFile, dpsPatternNames

                                                                                            FileEncoding, UTF-8
                                                                                            IniWrite, %customName%, %iniFile%, DPSPatternNames, %patternName%
                                                                                            FileEncoding
                                                                                            dpsPatternNames[patternName] := customName
                                                                                        }

                                                                                        SaveDPSPriorities() {
                                                                                            global iniFile, dpsPriorities

                                                                                            ; Convert array to comma-separated string
                                                                                            priorityString := ""
                                                                                            for index, priorityPattern in dpsPriorities {
                                                                                                if (index > 1)
                                                                                                    priorityString .= ","
                                                                                                priorityString .= priorityPattern
                                                                                            }

                                                                                            FileEncoding, UTF-8
                                                                                            IniWrite, %priorityString%, %iniFile%, DPSPriorities, Order
                                                                                            FileEncoding
                                                                                        }

                                                                                        LoadDPSPriorities() {
                                                                                            global iniFile, dpsPriorities

                                                                                            IniRead, priorityString, %iniFile%, DPSPriorities, Order, %A_Space%
                                                                                            if (priorityString != "" && priorityString != "ERROR") {
                                                                                                dpsPriorities := StrSplit(priorityString, ",")
                                                                                            }
                                                                                        }

                                                                                        GetDPSDisplayName(patternName) {
                                                                                            global dpsPatternNames

                                                                                            if (dpsPatternNames.HasKey(patternName) && dpsPatternNames[patternName] != "")
                                                                                                return dpsPatternNames[patternName]
                                                                                            return patternName
                                                                                        }

                                                                                        LoadAllDPSPatterns() {
                                                                                            global iniFile, dpsPatterns, dpsPatternKeys, dpsPatternNames, dpsGroundTargetSkills, dpsGroundTargetCoords, dpsPressKeyBeforeCast, dpsPreCastKeys

                                                                                            ; Load DPS patterns
                                                                                            IniRead, dpsPatternsList, %iniFile%, DPSPatterns
                                                                                            if (dpsPatternsList != "ERROR") {
                                                                                                Loop, Parse, dpsPatternsList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        ; Find first equals sign position
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            patternText := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            dpsPatterns[patternName] := patternText
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Load DPS pattern keys
                                                                                            IniRead, dpsPatternKeysList, %iniFile%, DPSPatternKeys
                                                                                            if (dpsPatternKeysList != "ERROR") {
                                                                                                Loop, Parse, dpsPatternKeysList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        ; Find first equals sign position
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            keyAssignment := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            dpsPatternKeys[patternName] := keyAssignment
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Load DPS pattern names
                                                                                            IniRead, dpsPatternNamesList, %iniFile%, DPSPatternNames
                                                                                            if (dpsPatternNamesList != "ERROR") {
                                                                                                Loop, Parse, dpsPatternNamesList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        ; Find first equals sign position
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            customName := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            dpsPatternNames[patternName] := customName
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Load ground target settings
                                                                                            IniRead, dpsGroundTargetList, %iniFile%, DPSGroundTarget
                                                                                            if (dpsGroundTargetList != "ERROR") {
                                                                                                Loop, Parse, dpsGroundTargetList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            isGroundTarget := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            dpsGroundTargetSkills[patternName] := isGroundTarget
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Load ground target coordinates
                                                                                            IniRead, dpsGroundCoordsList, %iniFile%, DPSGroundCoords
                                                                                            if (dpsGroundCoordsList != "ERROR") {
                                                                                                Loop, Parse, dpsGroundCoordsList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            coordString := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            coords := StrSplit(coordString, ",")
                                                                                                            if (coords.Length() = 2) {
                                                                                                                dpsGroundTargetCoords[patternName] := {x: coords[1], y: coords[2]}
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Load pre-cast key enabled settings
                                                                                            IniRead, dpsPreCastEnabledList, %iniFile%, DPSPreCastEnabled
                                                                                            if (dpsPreCastEnabledList != "ERROR") {
                                                                                                Loop, Parse, dpsPreCastEnabledList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            needsPreCast := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            dpsPressKeyBeforeCast[patternName] := needsPreCast
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Load pre-cast keys
                                                                                            IniRead, dpsPreCastKeysList, %iniFile%, DPSPreCastKeys
                                                                                            if (dpsPreCastKeysList != "ERROR") {
                                                                                                Loop, Parse, dpsPreCastKeysList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            preCastKey := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            dpsPreCastKeys[patternName] := preCastKey
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Initialize DPS counter
                                                                                            InitializeDPSCounter()

                                                                                            dpsCount := dpsPatterns.Count()
                                                                                            if (dpsCount > 0) {
                                                                                                UpdateDPSStatus("Loaded " . dpsCount . " DPS pattern(s) successfully.")
                                                                                            }
                                                                                        }

                                                                                        InitializeDPSCounter() {
                                                                                            global dpsPatterns, dpsCounter

                                                                                            highestNumber := 0
                                                                                            for patternName, patternValue in dpsPatterns {
                                                                                                if (SubStr(patternName, 1, 3) = "dps") {
                                                                                                    numberPart := SubStr(patternName, 4)
                                                                                                    if numberPart is integer
                                                                                                    {
                                                                                                        if (numberPart > highestNumber)
                                                                                                            highestNumber := numberPart
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            dpsCounter := highestNumber + 1
                                                                                        }

                                                                                        ReloadDPSCustomNames() {
                                                                                            global iniFile, dpsPatternNames

                                                                                            ; Don't clear - just reload what's in the INI
                                                                                            FileEncoding, UTF-8
                                                                                            IniRead, dpsPatternNamesList, %iniFile%, DPSPatternNames
                                                                                            FileEncoding
                                                                                            if (dpsPatternNamesList != "ERROR") {
                                                                                                Loop, Parse, dpsPatternNamesList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        ; Find first equals sign position
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            customName := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            dpsPatternNames[patternName] := customName
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }

                                                                                        UpdateDPSStatus(message) {
                                                                                            global

                                                                                            ; Get current time
                                                                                            FormatTime, TimeString, , yyyy-MM-dd HH:mm:ss
                                                                                            statusMessage := "[" . TimeString . "] " . message

                                                                                            ; Get current content and add new message at top
                                                                                            GuiControlGet, currentContent, , DPSStatusEdit
                                                                                            if (currentContent != "") {
                                                                                                newContent := statusMessage . "`r`n" . currentContent
                                                                                            } else {
                                                                                                newContent := statusMessage
                                                                                            }

                                                                                            ; Update the edit control
                                                                                            GuiControl,, DPSStatusEdit, %newContent%

                                                                                            ; Scroll to top (new messages are now at top)
                                                                                            SendMessage, 0x0115, 6, 0, , ahk_id %DPSStatusEdit% ; WM_VSCROLL, SB_TOP
                                                                                        }
                                                                                        ;  ========= CC Helper Functions =========
                                                                                        SaveCCPattern(patternName, patternText, keyAssignment, customName, stunDuration) {
                                                                                            global iniFile, ccPatterns, ccPatternKeys, ccPatternNames, ccStunDurations

                                                                                            FileEncoding, UTF-8
                                                                                            IniWrite, %patternText%, %iniFile%, CCPatterns, %patternName%
                                                                                            IniWrite, %keyAssignment%, %iniFile%, CCPatternKeys, %patternName%
                                                                                            IniWrite, %customName%, %iniFile%, CCPatternNames, %patternName%
                                                                                            IniWrite, %stunDuration%, %iniFile%, CCStunDurations, %patternName%
                                                                                            FileEncoding

                                                                                            ccPatterns[patternName] := patternText
                                                                                            ccPatternKeys[patternName] := keyAssignment
                                                                                            ccPatternNames[patternName] := customName
                                                                                            ccStunDurations[patternName] := stunDuration
                                                                                        }

                                                                                        SaveCCPatternKey(patternName, keyAssignment) {
                                                                                            global iniFile, ccPatternKeys

                                                                                            FileEncoding, UTF-8
                                                                                            IniWrite, %keyAssignment%, %iniFile%, CCPatternKeys, %patternName%
                                                                                            FileEncoding
                                                                                            ccPatternKeys[patternName] := keyAssignment
                                                                                        }

                                                                                        SaveCCPatternName(patternName, customName) {
                                                                                            global iniFile, ccPatternNames

                                                                                            FileEncoding, UTF-8
                                                                                            IniWrite, %customName%, %iniFile%, CCPatternNames, %patternName%
                                                                                            FileEncoding
                                                                                            ccPatternNames[patternName] := customName
                                                                                        }
                                                                                        RefreshCCPriorityList() {
                                                                                            ; Clear the listbox completely
                                                                                            GuiControl,, CCPriorityList, |

                                                                                            ; Force rebuild the list
                                                                                            newList := ""
                                                                                            itemCount := 0
                                                                                            for index, priorityPattern in ccPriorities {
                                                                                                if (ccPatterns.HasKey(priorityPattern)) {
                                                                                                    itemCount++
                                                                                                    ; Force get fresh display name
                                                                                                    displayName := ccPatternNames.HasKey(priorityPattern) && ccPatternNames[priorityPattern] != "" ? ccPatternNames[priorityPattern] : priorityPattern
                                                                                                keyInfo := ccPatternKeys.HasKey(priorityPattern) && ccPatternKeys[priorityPattern] != "" ? " (Key: " . ccPatternKeys[priorityPattern] . ")" : " (Click)"
                                                                                                    listItem := index . ". " . displayName . keyInfo
                                                                                                    if (newList != "")
                                                                                                        newList .= "|"
                                                                                                    newList .= listItem
                                                                                                }
                                                                                            }

                                                                                            ; Set the entire list at once
                                                                                            GuiControl,, CCPriorityList, %newList%

                                                                                            ; Show count for debugging
                                                                                            if (itemCount = 0 && ccPriorities.Length() > 0) {
                                                                                                UpdateCCStatus("Warning: " . ccPriorities.Length() . " priorities but 0 valid patterns found")
                                                                                            }
                                                                                        }

                                                                                        SaveCCPriorities() {
                                                                                            global iniFile, ccPriorities

                                                                                            ; Convert array to comma-separated string
                                                                                            priorityString := ""
                                                                                            for index, priorityPattern in ccPriorities {
                                                                                                if (index > 1)
                                                                                                    priorityString .= ","
                                                                                                priorityString .= priorityPattern
                                                                                            }

                                                                                            FileEncoding, UTF-8
                                                                                            IniWrite, %priorityString%, %iniFile%, CCPriorities, Order
                                                                                            FileEncoding
                                                                                        }

                                                                                        LoadCCPriorities() {
                                                                                            global iniFile, ccPriorities

                                                                                            IniRead, priorityString, %iniFile%, CCPriorities, Order, %A_Space%
                                                                                            if (priorityString != "" && priorityString != "ERROR") {
                                                                                                ccPriorities := StrSplit(priorityString, ",")
                                                                                            }
                                                                                        }

                                                                                        GetCCDisplayName(patternName) {
                                                                                            global ccPatternNames

                                                                                            if (ccPatternNames.HasKey(patternName) && ccPatternNames[patternName] != "")
                                                                                                return ccPatternNames[patternName]
                                                                                            return patternName
                                                                                        }

                                                                                        LoadAllCCPatterns() {
                                                                                            global iniFile, ccPatterns, ccPatternKeys, ccPatternNames, ccStunDurations

                                                                                            ; Load CC patterns
                                                                                            IniRead, ccPatternsList, %iniFile%, CCPatterns
                                                                                            if (ccPatternsList != "ERROR") {
                                                                                                Loop, Parse, ccPatternsList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        ; Find first equals sign position
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            patternText := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            ccPatterns[patternName] := patternText
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Load CC pattern keys
                                                                                            IniRead, ccPatternKeysList, %iniFile%, CCPatternKeys
                                                                                            if (ccPatternKeysList != "ERROR") {
                                                                                                Loop, Parse, ccPatternKeysList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        ; Find first equals sign position
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            keyAssignment := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            ccPatternKeys[patternName] := keyAssignment
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Load CC pattern names
                                                                                            IniRead, ccPatternNamesList, %iniFile%, CCPatternNames
                                                                                            if (ccPatternNamesList != "ERROR") {
                                                                                                Loop, Parse, ccPatternNamesList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        ; Find first equals sign position
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            customName := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            ccPatternNames[patternName] := customName
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Load CC stun durations
                                                                                            IniRead, ccStunDurationsList, %iniFile%, CCStunDurations
                                                                                            if (ccStunDurationsList != "ERROR") {
                                                                                                Loop, Parse, ccStunDurationsList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        ; Find first equals sign position
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            stunDuration := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            ccStunDurations[patternName] := stunDuration
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Initialize CC counter
                                                                                            InitializeCCCounter()

                                                                                            ccCount := ccPatterns.Count()
                                                                                            if (ccCount > 0) {
                                                                                                UpdateCCStatus("Loaded " . ccCount . " CC pattern(s) successfully.")
                                                                                            }
                                                                                        }

                                                                                        InitializeCCCounter() {
                                                                                            global ccPatterns, ccCounter

                                                                                            highestNumber := 0
                                                                                            for patternName, patternValue in ccPatterns {
                                                                                                if (SubStr(patternName, 1, 3) = "cc") {
                                                                                                    numberPart := SubStr(patternName, 4)
                                                                                                    if numberPart is integer
                                                                                                    {
                                                                                                        if (numberPart > highestNumber)
                                                                                                            highestNumber := numberPart
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ccCounter := highestNumber + 1
                                                                                        }

                                                                                        ReloadCCCustomNames() {
                                                                                            global iniFile, ccPatternNames

                                                                                            ; Don't clear - just reload what's in the INI
                                                                                            FileEncoding, UTF-8
                                                                                            IniRead, ccPatternNamesList, %iniFile%, CCPatternNames
                                                                                            FileEncoding
                                                                                            if (ccPatternNamesList != "ERROR") {
                                                                                                Loop, Parse, ccPatternNamesList, `n
                                                                                                {
                                                                                                    if (A_LoopField != "") {
                                                                                                        ; Find first equals sign position
                                                                                                        equalsPos := InStr(A_LoopField, "=")
                                                                                                        if (equalsPos > 0) {
                                                                                                            patternName := SubStr(A_LoopField, 1, equalsPos - 1)
                                                                                                            customName := SubStr(A_LoopField, equalsPos + 1)
                                                                                                            ccPatternNames[patternName] := customName
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        UpdateCCStatus(message) {
                                                                                            global

                                                                                            ; Get current time
                                                                                            FormatTime, TimeString, , yyyy-MM-dd HH:mm:ss
                                                                                            statusMessage := "[" . TimeString . "] " . message

                                                                                            ; Get current content and add new message at top
                                                                                            GuiControlGet, currentContent, , CCStatusEdit
                                                                                            if (currentContent != "") {
                                                                                                newContent := statusMessage . "`r`n" . currentContent
                                                                                            } else {
                                                                                                newContent := statusMessage
                                                                                            }

                                                                                            ; Update the edit control
                                                                                            GuiControl,, CCStatusEdit, %newContent%

                                                                                            ; Scroll to top (new messages are now at top)
                                                                                            SendMessage, 0x0115, 6, 0, , ahk_id %CCStatusEdit% ; WM_VSCROLL, SB_TOP
                                                                                        }

                                                                                        TryCastCC() {
                                                                                            global ccPatterns, ccPatternKeys, ccPriorities, ccStunDurations
                                                                                            global SkillBarX1, SkillBarY1, SkillBarX2, SkillBarY2, isCcRunning, ccOnCooldown

                                                                                            ; Skip if on cooldown
                                                                                            if (ccOnCooldown)
                                                                                                return false

                                                                                            for index, priorityPattern in ccPriorities {
                                                                                                if (!ccPatterns.HasKey(priorityPattern))
                                                                                                    continue

                                                                                                patternText := ccPatterns[priorityPattern]

                                                                                                ; Convert window-relative coords to screen coords
                                                                                                WinGetPos, winX, winY,,, ahk_id %win1%
                                                                                                screenX1 := winX + SkillBarX1
                                                                                                screenY1 := winY + SkillBarY1
                                                                                                screenX2 := winX + SkillBarX2
                                                                                                screenY2 := winY + SkillBarY2

                                                                                                ; For 4K monitors, search entire screen width but constrain to skill bar height
                                                                                                ccSkill := FindText(X, Y, 0, screenY1, A_ScreenWidth, screenY2, 0, 0, patternText)

                                                                                                if (ccSkill) {
                                                                                                    displayName := GetDPSDisplayName(priorityPattern) ; rename if you have a CC-specific display name
                                                                                                    hasKey := ccPatternKeys.HasKey(priorityPattern) && ccPatternKeys[priorityPattern] != ""

                                                                                                    ; Execute skill with spam protection
                                                                                                    spamCount := 0
                                                                                                    success := false
                                                                                                    Loop, 5 { ; Max 5 attempts
                                                                                                        spamCount++

                                                                                                        if (hasKey) {
                                                                                                            keyToPress := ccPatternKeys[priorityPattern]

                                                                                                            ; Check for modifier keys
                                                                                                            hasCtrl := InStr(keyToPress, "^")
                                                                                                            hasAlt := InStr(keyToPress, "!")
                                                                                                            hasShift := InStr(keyToPress, "+")

                                                                                                            ; Extract the base key
                                                                                                            baseKey := StrReplace(keyToPress, "^", "")
                                                                                                            baseKey := StrReplace(baseKey, "!", "")
                                                                                                            baseKey := StrReplace(baseKey, "+", "")

                                                                                                            ; Apply QWERTZ conversion if enabled
                                                                                                            baseKey := ConvertQwertyToQwertz(baseKey)

                                                                                                            ; Send modifier keys down
                                                                                                            if (hasCtrl)
                                                                                                                ControlSend,, {Ctrl down}, ahk_id %win1%
                                                                                                            if (hasAlt)
                                                                                                                ControlSend,, {Alt down}, ahk_id %win1%
                                                                                                            if (hasShift)
                                                                                                                ControlSend,, {Shift down}, ahk_id %win1%

                                                                                                            ; Send the base key
                                                                                                            ControlSend,, {%baseKey% down}, ahk_id %win1%
                                                                                                            Sleep, 50
                                                                                                            ControlSend,, {%baseKey% up}, ahk_id %win1%

                                                                                                            ; Release modifiers
                                                                                                            if (hasShift)
                                                                                                                ControlSend,, {Shift up}, ahk_id %win1%
                                                                                                            if (hasAlt)
                                                                                                                ControlSend,, {Alt up}, ahk_id %win1%
                                                                                                            if (hasCtrl)
                                                                                                                ControlSend,, {Ctrl up}, ahk_id %win1%

                                                                                                        } else {
                                                                                                            ; Only click if coords exist
                                                                                                            if (IsObject(ccSkill) && ccSkill.MaxIndex() >= 1) {
                                                                                                                X := ccSkill.1.x
                                                                                                                Y := ccSkill.1.y
                                                                                                                SendMessageClick(X, Y)
                                                                                                            } else {
                                                                                                                ;UpdateCCStatus("⚠ No CC coords available, skipping click.")
                                                                                                            }
                                                                                                        }

                                                                                                        ; Recheck availability (search full screen width for 4K monitors)
                                                                                                        Sleep, 125
                                                                                                        if (!FindText(X, Y, 0, screenY1, A_ScreenWidth, screenY2, 0, 0, patternText)) {
                                                                                                            success := true
                                                                                                            break
                                                                                                        }
                                                                                                    }

                                                                                                    ; If after 5 tries the image is still there → don’t click (avoid 0,0 jump)
                                                                                                    if (!success) {
                                                                                                        ;UpdateCCStatus("⚠ Pattern did not disappear after " . spamCount . " attempts, skipping.")
                                                                                                    }

                                                                                                    ; Status message
                                                                                                method := hasKey ? "key: " . ccPatternKeys[priorityPattern] : "clicking"
                                                                                                prefix := isCcRunning ? "" : "TEST: "
                                                                                                    ;UpdateCCStatus(prefix . "Used " . displayName . " with " . method . " (" . spamCount . "x)")

                                                                                                    ; Set cooldown based on stun duration
                                                                                                    if (ccStunDurations.HasKey(priorityPattern)) {
                                                                                                        stunDurationMs := ccStunDurations[priorityPattern]
                                                                                                        if (stunDurationMs > 0) {
                                                                                                            ccOnCooldown := true
                                                                                                            stunDurationSec := stunDurationMs / 1000.0
                                                                                                            UpdateCCStatus(prefix . "Used " . displayName . " with " . method . " - CC on cooldown for " . stunDurationSec . "s")
                                                                                                            SetTimer, ResetCCCooldown, -%stunDurationMs%
                                                                                                        }
                                                                                                    }

                                                                                                    SendMeleeAttack() ; Send melee attack after successful CC skill cast
                                                                                                    Sleep, 150
                                                                                                return true
                                                                                            }
                                                                                        }

                                                                                        if (!isCcRunning)
                                                                                            UpdateCCStatus("No CC skills found on screen.")
                                                                                        return false
                                                                                    }

                                                                                    ResetCCCooldown:
                                                                                        ccOnCooldown := false
                                                                                        UpdateCCStatus("CC cooldown expired - ready to cast again")
                                                                                    return

                                                                                    TryCastCCSkills() {
                                                                                    return TryCastCC()
                                                                                }

                                                                                ; ========= MELEE ATTACK HELPER FUNCTION =========
                                                                                SendMeleeAttack() {
                                                                                    global meleeAttackEnabled, meleeAttackKey, win1

                                                                                    if ((meleeAttackEnabled = 1 || meleeAttackEnabled = "1" || meleeAttackEnabled = true) && meleeAttackKey != "" && meleeAttackKey != " ") {
                                                                                        Random, attackCount, 2, 5

                                                                                        ; Check for modifier keys
                                                                                        hasCtrl := InStr(meleeAttackKey, "^")
                                                                                        hasAlt := InStr(meleeAttackKey, "!")
                                                                                        hasShift := InStr(meleeAttackKey, "+")

                                                                                        ; Extract the base key
                                                                                        baseKey := meleeAttackKey
                                                                                        if (hasCtrl)
                                                                                            baseKey := StrReplace(baseKey, "^")
                                                                                        if (hasAlt)
                                                                                            baseKey := StrReplace(baseKey, "!")
                                                                                        if (hasShift)
                                                                                            baseKey := StrReplace(baseKey, "+")

                                                                                        Sleep, 50
                                                                                        Loop, %attackCount% {
                                                                                            ; Send modifiers down
                                                                                            if (hasCtrl)
                                                                                                ControlSend,, {Ctrl down}, ahk_id %win1%
                                                                                            if (hasAlt)
                                                                                                ControlSend,, {Alt down}, ahk_id %win1%
                                                                                            if (hasShift)
                                                                                                ControlSend,, {Shift down}, ahk_id %win1%

                                                                                            ; Send base key
                                                                                            ControlSend,, {%baseKey% down}, ahk_id %win1%
                                                                                            Sleep, 25
                                                                                            ControlSend,, {%baseKey% up}, ahk_id %win1%

                                                                                            ; Release modifiers
                                                                                            if (hasShift)
                                                                                                ControlSend,, {Shift up}, ahk_id %win1%
                                                                                            if (hasAlt)
                                                                                                ControlSend,, {Alt up}, ahk_id %win1%
                                                                                            if (hasCtrl)
                                                                                                ControlSend,, {Ctrl up}, ahk_id %win1%

                                                                                            Sleep, 25
                                                                                        }
                                                                                    }
                                                                                    return
                                                                                }

                                                                                ; ========= DPS SKILL CASTING FUNCTION =========
                                                                                TryCastDPSSkills() {
                                                                                    global dpsPatterns, dpsPatternKeys, dpsPriorities
                                                                                    global dpsGroundTargetSkills, dpsGroundTargetCoords, dpsPressKeyBeforeCast, dpsPreCastKeys
                                                                                    global SkillBarX1, SkillBarY1, SkillBarX2, SkillBarY2, isDpsRunning
                                                                                    global SequentialDPSEnabled, CurrentSequentialIndex

                                                                                    if (SequentialDPSEnabled) {
                                                                                        ; Sequential mode - cast skills only in order, don't skip if not found
                                                                                        if (CurrentSequentialIndex > dpsPriorities.MaxIndex()) {
                                                                                            CurrentSequentialIndex := 1 ; Loop back to first skill
                                                                                        }

                                                                                        priorityPattern := dpsPriorities[CurrentSequentialIndex]

                                                                                        if (!dpsPatterns.HasKey(priorityPattern)) {
                                                                                            ; If pattern doesn't exist, move to next skill but don't cast anything
                                                                                            CurrentSequentialIndex++
                                                                                            return false
                                                                                        }

                                                                                        patternText := dpsPatterns[priorityPattern]

                                                                                        ; Convert window-relative coordinates to screen coordinates
                                                                                        WinGetPos, winX, winY,,, ahk_id %win1%

                                                                                        ; Validate window position first
                                                                                        if (winX = "" || winY = "" || winX < 0 || winY < 0) {
                                                                                            return false
                                                                                        }

                                                                                        screenX1 := winX + SkillBarX1
                                                                                        screenY1 := winY + SkillBarY1
                                                                                        screenX2 := winX + SkillBarX2
                                                                                        screenY2 := winY + SkillBarY2

                                                                                        ; Debug: Show search area once at start
                                                                                        if (!isDpsRunning && A_Index = 1) {
                                                                                            UpdateDPSStatus("Searching FULL WIDTH: [0," . screenY1 . "] to [" . A_ScreenWidth . "," . screenY2 . "] | WinPos: " . winX . "," . winY)
                                                                                        }

                                                                                        ; For 4K monitors, search entire screen width but constrain to skill bar height
                                                                                        dpsSkill := FindText(X, Y, 0, screenY1, A_ScreenWidth, screenY2, 0, 0, patternText)

                                                                                        if (dpsSkill) {
                                                                                            ; Cast the skill we found
                                                                                            displayName := GetDPSDisplayName(priorityPattern)
                                                                                            hasKey := dpsPatternKeys.HasKey(priorityPattern) && dpsPatternKeys[priorityPattern] != ""
                                                                                            skillCastSuccessfully := false

                                                                                            ; Check for pre-cast key
                                                                                            if (dpsPressKeyBeforeCast.HasKey(priorityPattern) && (dpsPressKeyBeforeCast[priorityPattern] = true || dpsPressKeyBeforeCast[priorityPattern] = "1" || dpsPressKeyBeforeCast[priorityPattern] = "true") && dpsPreCastKeys.HasKey(priorityPattern) && dpsPreCastKeys[priorityPattern] != "") {
                                                                                                preCastKey := dpsPreCastKeys[priorityPattern]
                                                                                                ControlSend,, {%preCastKey% down}, ahk_id %win1%
                                                                                                Sleep, 50
                                                                                                ControlSend,, {%preCastKey% up}, ahk_id %win1%
                                                                                                Sleep, 100
                                                                                            }

                                                                                            if (hasKey) {
                                                                                                keyToPress := dpsPatternKeys[priorityPattern]

                                                                                                ; Check for modifier keys
                                                                                                hasCtrl := InStr(keyToPress, "^")
                                                                                                hasAlt := InStr(keyToPress, "!")
                                                                                                hasShift := InStr(keyToPress, "+")

                                                                                                ; Extract the base key (remove modifiers)
                                                                                                baseKey := keyToPress
                                                                                                if (hasCtrl)
                                                                                                    baseKey := StrReplace(baseKey, "^")
                                                                                                if (hasAlt)
                                                                                                    baseKey := StrReplace(baseKey, "!")
                                                                                                if (hasShift)
                                                                                                    baseKey := StrReplace(baseKey, "+")

                                                                                                ; Apply QWERTZ conversion if enabled
                                                                                                baseKey := ConvertQwertyToQwertz(baseKey)

                                                                                                ; Send modifier keys down
                                                                                                if (hasCtrl)
                                                                                                    ControlSend,, {Ctrl down}, ahk_id %win1%
                                                                                                if (hasAlt)
                                                                                                    ControlSend,, {Alt down}, ahk_id %win1%
                                                                                                if (hasShift)
                                                                                                    ControlSend,, {Shift down}, ahk_id %win1%

                                                                                                ; Send the base key
                                                                                                ControlSend,, {%baseKey% down}, ahk_id %win1%
                                                                                                Sleep, 50
                                                                                                ControlSend,, {%baseKey% up}, ahk_id %win1%

                                                                                                ; Release modifiers (reverse order)
                                                                                                if (hasShift)
                                                                                                    ControlSend,, {Shift up}, ahk_id %win1%
                                                                                                if (hasAlt)
                                                                                                    ControlSend,, {Alt up}, ahk_id %win1%
                                                                                                if (hasCtrl)
                                                                                                    ControlSend,, {Ctrl up}, ahk_id %win1%

                                                                                                skillCastSuccessfully := true

                                                                                            } else {
                                                                                                if (IsObject(dpsSkill) && dpsSkill.MaxIndex() >= 1) {
                                                                                                    X := dpsSkill.1.x
                                                                                                    Y := dpsSkill.1.y

                                                                                                    ; Validate coordinates before clicking
                                                                                                    if (X > 0 && Y > 0 && X < A_ScreenWidth && Y < A_ScreenHeight) {
                                                                                                        SendMessageClick(X, Y)
                                                                                                        skillCastSuccessfully := true
                                                                                                    }
                                                                                                }
                                                                                            }

                                                                                            ; Handle ground targeting if enabled
                                                                                            if (skillCastSuccessfully && dpsGroundTargetSkills.HasKey(priorityPattern) && (dpsGroundTargetSkills[priorityPattern] = true || dpsGroundTargetSkills[priorityPattern] = "1" || dpsGroundTargetSkills[priorityPattern] = "true") && dpsGroundTargetCoords.HasKey(priorityPattern)) {
                                                                                                Sleep, 150
                                                                                                groundCoords := dpsGroundTargetCoords[priorityPattern]
                                                                                                ; Add randomization to coordinates (±20 pixels)
                                                                                                Random, randX, -20, 20
                                                                                                Random, randY, -20, 20
                                                                                                relX := groundCoords.x + randX
                                                                                                relY := groundCoords.y + randY
                                                                                                ; Move mouse to ground target location
                                                                                                lParamMove := (relY << 16) | (relX & 0xFFFF)
                                                                                                SendMessage, 0x200, 0, lParamMove,, ahk_id %win1% ; WM_MOUSEMOVE
                                                                                                Sleep, 50
                                                                                                ; Click at ground target location
                                                                                                lParam := (relY << 16) | (relX & 0xFFFF)
                                                                                                SendMessage, 0x201, 0x0001, lParam,, ahk_id %win1% ; WM_LBUTTONDOWN
                                                                                                Sleep, 50
                                                                                                SendMessage, 0x202, 0, lParam,, ahk_id %win1% ; WM_LBUTTONUP
                                                                                                Sleep, 100
                                                                                            }

                                                                                            ; Press Tab after skill cast (only if pre-cast key was used)
                                                                                            if (skillCastSuccessfully && dpsPressKeyBeforeCast.HasKey(priorityPattern) && (dpsPressKeyBeforeCast[priorityPattern] = true || dpsPressKeyBeforeCast[priorityPattern] = "1" || dpsPressKeyBeforeCast[priorityPattern] = "true") && dpsPreCastKeys.HasKey(priorityPattern) && dpsPreCastKeys[priorityPattern] != "") {
                                                                                                ControlSend,, {Tab down}, ahk_id %win1%
                                                                                                Sleep, 50
                                                                                                ControlSend,, {Tab up}, ahk_id %win1%
                                                                                                Sleep, 100
                                                                                            } if (skillCastSuccessfully) {
                                                                                                method := hasKey ? "key: " . dpsPatternKeys[priorityPattern] : "clicking"
                                                                                                prefix := isDpsRunning ? "" : "TEST: "
                                                                                                    UpdateDPSStatus(prefix . "Sequential: Used " . displayName . " (" . CurrentSequentialIndex . "/" . dpsPriorities.MaxIndex() . ") with " . method)

                                                                                                    SendMeleeAttack() ; Send melee attack after successful DPS skill cast
                                                                                                    CurrentSequentialIndex++ ; Move to next skill AFTER successful cast
                                                                                                    Sleep, 150
                                                                                                return true
                                                                                            }
                                                                                        } else {
                                                                                            ; Skill not found - in sequential mode, we don't cast anything and don't advance
                                                                                            displayName := GetDPSDisplayName(priorityPattern)
                                                                                            if (!isDpsRunning) {
                                                                                                UpdateDPSStatus("Sequential: Waiting for " . displayName . " (" . CurrentSequentialIndex . "/" . dpsPriorities.MaxIndex() . ")")
                                                                                            }
                                                                                            return false ; Don't cast anything, don't advance index
                                                                                        }

                                                                                        return false

                                                                                    } else {
                                                                                        ; Non-sequential mode - cast next available skill immediately
                                                                                        for index, priorityPattern in dpsPriorities {
                                                                                            if (!dpsPatterns.HasKey(priorityPattern))
                                                                                                continue

                                                                                            patternText := dpsPatterns[priorityPattern]

                                                                                            ; Convert window-relative coordinates to screen coordinates
                                                                                            WinGetPos, winX, winY,,, ahk_id %win1%

                                                                                            ; Validate window position first
                                                                                            if (winX = "" || winY = "" || winX < 0 || winY < 0) {
                                                                                                return false
                                                                                            }

                                                                                            screenX1 := winX + SkillBarX1
                                                                                            screenY1 := winY + SkillBarY1
                                                                                            screenX2 := winX + SkillBarX2
                                                                                            screenY2 := winY + SkillBarY2

                                                                                            ; For 4K monitors, search entire screen width but constrain to skill bar height
                                                                                            dpsSkill := FindText(X, Y, 0, screenY1, A_ScreenWidth, screenY2, 0, 0, patternText)

                                                                                            if (dpsSkill) {
                                                                                                displayName := GetDPSDisplayName(priorityPattern)
                                                                                                hasKey := dpsPatternKeys.HasKey(priorityPattern) && dpsPatternKeys[priorityPattern] != ""

                                                                                                ; Execute skill with spam protection
                                                                                                spamCount := 0
                                                                                                skillCastSuccessfully := false

                                                                                                Loop, 5 { ; Max 5 attempts
                                                                                                    spamCount++

                                                                                                    ; Check for pre-cast key
                                                                                                    if (spamCount = 1 && dpsPressKeyBeforeCast.HasKey(priorityPattern) && (dpsPressKeyBeforeCast[priorityPattern] = true || dpsPressKeyBeforeCast[priorityPattern] = "1" || dpsPressKeyBeforeCast[priorityPattern] = "true") && dpsPreCastKeys.HasKey(priorityPattern) && dpsPreCastKeys[priorityPattern] != "") {
                                                                                                        preCastKey := dpsPreCastKeys[priorityPattern]
                                                                                                        ControlSend,, {%preCastKey% down}, ahk_id %win1%
                                                                                                        Sleep, 50
                                                                                                        ControlSend,, {%preCastKey% up}, ahk_id %win1%
                                                                                                        Sleep, 100
                                                                                                    }

                                                                                                    if (hasKey) {
                                                                                                        keyToPress := dpsPatternKeys[priorityPattern]

                                                                                                        ; Check for modifier keys
                                                                                                        hasCtrl := InStr(keyToPress, "^")
                                                                                                        hasAlt := InStr(keyToPress, "!")
                                                                                                        hasShift := InStr(keyToPress, "+")

                                                                                                        ; Extract the base key (remove modifiers)
                                                                                                        baseKey := keyToPress
                                                                                                        if (hasCtrl)
                                                                                                            baseKey := StrReplace(baseKey, "^")
                                                                                                        if (hasAlt)
                                                                                                            baseKey := StrReplace(baseKey, "!")
                                                                                                        if (hasShift)
                                                                                                            baseKey := StrReplace(baseKey, "+")

                                                                                                        ; Apply QWERTZ conversion if enabled
                                                                                                        baseKey := ConvertQwertyToQwertz(baseKey)

                                                                                                        ; Send modifier keys down
                                                                                                        if (hasCtrl)
                                                                                                            ControlSend,, {Ctrl down}, ahk_id %win1%
                                                                                                        if (hasAlt)
                                                                                                            ControlSend,, {Alt down}, ahk_id %win1%
                                                                                                        if (hasShift)
                                                                                                            ControlSend,, {Shift down}, ahk_id %win1%

                                                                                                        ; Send the base key
                                                                                                        ControlSend,, {%baseKey% down}, ahk_id %win1%
                                                                                                        Sleep, 50
                                                                                                        ControlSend,, {%baseKey% up}, ahk_id %win1%

                                                                                                        ; Release modifiers (reverse order)
                                                                                                        if (hasShift)
                                                                                                            ControlSend,, {Shift up}, ahk_id %win1%
                                                                                                        if (hasAlt)
                                                                                                            ControlSend,, {Alt up}, ahk_id %win1%
                                                                                                        if (hasCtrl)
                                                                                                            ControlSend,, {Ctrl up}, ahk_id %win1%

                                                                                                        skillCastSuccessfully := true

                                                                                                    } else {
                                                                                                        if (IsObject(dpsSkill) && dpsSkill.MaxIndex() >= 1) {
                                                                                                            X := dpsSkill.1.x
                                                                                                            Y := dpsSkill.1.y

                                                                                                            if (X > 0 && Y > 0 && X < A_ScreenWidth && Y < A_ScreenHeight) {
                                                                                                                SendMessageClick(X, Y)
                                                                                                                skillCastSuccessfully := true
                                                                                                            } else {
                                                                                                                break
                                                                                                            }
                                                                                                        } else {
                                                                                                            break
                                                                                                        }
                                                                                                    }

                                                                                                    ; Handle ground targeting if enabled (only on first cast)
                                                                                                    if (spamCount = 1 && skillCastSuccessfully && dpsGroundTargetSkills.HasKey(priorityPattern) && (dpsGroundTargetSkills[priorityPattern] = true || dpsGroundTargetSkills[priorityPattern] = "1" || dpsGroundTargetSkills[priorityPattern] = "true") && dpsGroundTargetCoords.HasKey(priorityPattern)) {
                                                                                                        Sleep, 150
                                                                                                        groundCoords := dpsGroundTargetCoords[priorityPattern]
                                                                                                        ; Add randomization to coordinates (±20 pixels)
                                                                                                        Random, randX, -20, 20
                                                                                                        Random, randY, -20, 20
                                                                                                        relX := groundCoords.x + randX
                                                                                                        relY := groundCoords.y + randY
                                                                                                        ; Move mouse to ground target location
                                                                                                        lParamMove := (relY << 16) | (relX & 0xFFFF)
                                                                                                        SendMessage, 0x200, 0, lParamMove,, ahk_id %win1% ; WM_MOUSEMOVE
                                                                                                        Sleep, 50
                                                                                                        ; Click at ground target location
                                                                                                        lParam := (relY << 16) | (relX & 0xFFFF)
                                                                                                        SendMessage, 0x201, 0x0001, lParam,, ahk_id %win1% ; WM_LBUTTONDOWN
                                                                                                        Sleep, 50
                                                                                                        SendMessage, 0x202, 0, lParam,, ahk_id %win1% ; WM_LBUTTONUP
                                                                                                        Sleep, 100
                                                                                                    }

                                                                                                    ; Press Tab after skill cast (only on first cast and if pre-cast key was used)
                                                                                                    if (spamCount = 1 && skillCastSuccessfully && dpsPressKeyBeforeCast.HasKey(priorityPattern) && (dpsPressKeyBeforeCast[priorityPattern] = true || dpsPressKeyBeforeCast[priorityPattern] = "1" || dpsPressKeyBeforeCast[priorityPattern] = "true") && dpsPreCastKeys.HasKey(priorityPattern) && dpsPreCastKeys[priorityPattern] != "") {
                                                                                                        ControlSend,, {Tab down}, ahk_id %win1%
                                                                                                        Sleep, 50
                                                                                                        ControlSend,, {Tab up}, ahk_id %win1%
                                                                                                        Sleep, 100
                                                                                                    } ; Recheck availability (search full screen width for 4K monitors)
                                                                                                    Sleep, 125
                                                                                                    recheckSkill := FindText(X, Y, 0, screenY1, A_ScreenWidth, screenY2, 0, 0, patternText)
                                                                                                    if (!recheckSkill) {
                                                                                                        break
                                                                                                    }
                                                                                                }

                                                                                                if (skillCastSuccessfully) {
                                                                                                method := hasKey ? "key: " . dpsPatternKeys[priorityPattern] : "clicking"
                                                                                                prefix := isDpsRunning ? "" : "TEST: "
                                                                                                    UpdateDPSStatus(prefix . "Used " . displayName . " with " . method . " (" . spamCount . "x)")
                                                                                                    SendMeleeAttack() ; Send melee attack after successful DPS skill cast
                                                                                                    Sleep, 150
                                                                                                return true
                                                                                            }
                                                                                        }
                                                                                    }

                                                                                    if (!isDpsRunning)
                                                                                        UpdateDPSStatus("No DPS skills found on screen.")
                                                                                    return false
                                                                                }
                                                                            }

                                                                            ; CC Priority Management
                                                                            CCPrioritySelect:
                                                                            return

                                                                            MoveCCUp:
                                                                                ; Get the currently selected item index from the ListBox
                                                                                GuiControlGet, selectedText, , CCPriorityList
                                                                                selectedIndex := 0

                                                                                ; Parse the index from the text (format: "1. SkillName")
                                                                                if (selectedText != "") {
                                                                                    RegExMatch(selectedText, "^(\d+)\.", match)
                                                                                    selectedIndex := match1
                                                                                }

                                                                                ; Debug info
                                                                                UpdateCCStatus("Debug: Selected text = '" . selectedText . "', Parsed index = " . selectedIndex . ", Total items = " . ccPriorities.Length())

                                                                                if (selectedIndex <= 1 || selectedIndex > ccPriorities.Length()) {
                                                                                    UpdateCCStatus("Cannot move item up. Select an item first or item is already at top.")
                                                                                    return
                                                                                }

                                                                                ; Swap with previous item
                                                                                temp := ccPriorities[selectedIndex]
                                                                                ccPriorities[selectedIndex] := ccPriorities[selectedIndex - 1]
                                                                                ccPriorities[selectedIndex - 1] := temp

                                                                                SaveCCPriorities()
                                                                                RefreshCCPriorityList()

                                                                                ; Reselect the moved item
                                                                                GuiControl, Choose, CCPriorityList, % selectedIndex - 1

                                                                                UpdateCCStatus("Moved CC skill up in priority.")
                                                                            return

                                                                            MoveCCDown:
                                                                                ; Get the currently selected item index from the ListBox
                                                                                GuiControlGet, selectedText, , CCPriorityList
                                                                                selectedIndex := 0

                                                                                ; Parse the index from the text (format: "1. SkillName")
                                                                                if (selectedText != "") {
                                                                                    RegExMatch(selectedText, "^(\d+)\.", match)
                                                                                    selectedIndex := match1
                                                                                }

                                                                                ; Debug info
                                                                                UpdateCCStatus("Debug: Selected text = '" . selectedText . "', Parsed index = " . selectedIndex . ", Total items = " . ccPriorities.Length())

                                                                                if (selectedIndex <= 0 || selectedIndex >= ccPriorities.Length()) {
                                                                                    UpdateCCStatus("Cannot move item down. Select an item first or item is already at bottom.")
                                                                                    return
                                                                                }

                                                                                ; Swap with next item
                                                                                temp := ccPriorities[selectedIndex]
                                                                                ccPriorities[selectedIndex] := ccPriorities[selectedIndex + 1]
                                                                                ccPriorities[selectedIndex + 1] := temp

                                                                                SaveCCPriorities()
                                                                                RefreshCCPriorityList()

                                                                                ; Reselect the moved item
                                                                                GuiControl, Choose, CCPriorityList, % selectedIndex + 1

                                                                                UpdateCCStatus("Moved CC skill down in priority.")
                                                                            return

                                                                            RefreshCCList:
                                                                                RefreshCCPriorityList()
                                                                                UpdateCCStatus("CC priority list refreshed.")
                                                                            return

                                                                            RemoveFromCCPriority:
                                                                                ; Get the currently selected item index from the ListBox
                                                                                GuiControlGet, selectedText, , CCPriorityList
                                                                                selectedIndex := 0

                                                                                ; Parse the index from the text (format: "1. SkillName")
                                                                                if (selectedText != "") {
                                                                                    RegExMatch(selectedText, "^(\d+)\.", match)
                                                                                    selectedIndex := match1
                                                                                }

                                                                                if (selectedIndex <= 0 || selectedIndex > ccPriorities.Length()) {
                                                                                    UpdateCCStatus("Select a CC skill to remove from priority.")
                                                                                    return
                                                                                }

                                                                                removedSkill := ccPriorities[selectedIndex]
                                                                                displayName := GetCCDisplayName(removedSkill)
                                                                                ccPriorities.RemoveAt(selectedIndex)

                                                                                SaveCCPriorities()
                                                                                RefreshCCPriorityList()
                                                                                UpdateCCStatus("Removed '" . displayName . "' from CC priority order (skill still saved).")
                                                                            return

                                                                            AddToCCPriority:
                                                                                ; Show available CC skills not in priority
                                                                                availableCC := "=== ADD CC SKILL TO PRIORITY ===`n`n"
                                                                                availableCount := 0
                                                                                availableSkills := []

                                                                                for patternName, patternText in ccPatterns {
                                                                                    ; Check if already in priority
                                                                                    inPriority := false
                                                                                    for index, priorityPattern in ccPriorities {
                                                                                        if (priorityPattern = patternName) {
                                                                                            inPriority := true
                                                                                            break
                                                                                        }
                                                                                    }

                                                                                    if (!inPriority) {
                                                                                        availableCount++
                                                                                        availableSkills.Push(patternName)
                                                                                        displayName := GetCCDisplayName(patternName)
                                                                                        availableCC .= availableCount . ". " . displayName . " [" . patternName . "]`n"
                                                                                    }
                                                                                }

                                                                                if (availableCount = 0) {
                                                                                    UpdateCCStatus("No CC skills available to add (all are already in priority or none saved).")
                                                                                    return
                                                                                }

                                                                                availableCC .= "`nEnter the number of the CC skill to add to priority:"

                                                                                InputBox, ccNumber, Add CC Skill to Priority, %availableCC%, , 400, 300
                                                                                if (ErrorLevel)
                                                                                    return

                                                                                if (ccNumber < 1 || ccNumber > availableCount) {
                                                                                    UpdateCCStatus("Invalid CC skill number selected.")
                                                                                    return
                                                                                }

                                                                                selectedSkill := availableSkills[ccNumber]
                                                                                displayName := GetCCDisplayName(selectedSkill)

                                                                                ; Add to end of priority list
                                                                                ccPriorities.Push(selectedSkill)
                                                                                SaveCCPriorities()
                                                                                RefreshCCPriorityList()
                                                                                UpdateCCStatus("Added '" . displayName . "' to CC priority order.")
                                                                            return

                                                                            ; ========= QWERTY TO QWERTZ CONVERSION =========
                                                                            ; Function to convert QWERTY keys to QWERTZ keys
                                                                            ConvertQwertyToQwertz(key) {
                                                                                global qwertzModeEnabled

                                                                                ; If QWERTZ mode is not enabled, return the original key
                                                                                if (!qwertzModeEnabled)
                                                                                    return key

                                                                                ; Define conversion map for QWERTY→QWERTZ
                                                                                ; Letter swaps: Y↔Z
                                                                                if (key = "y")
                                                                                    return "z"
                                                                                else if (key = "Y")
                                                                                    return "Z"
                                                                                else if (key = "z")
                                                                                    return "y"
                                                                                else if (key = "Z")
                                                                                    return "Y"

                                                                                ; Special character mappings (QWERTY → QWERTZ)
                                                                                ; Note: These are the shifted/unshifted positions
                                                                                else if (key = "-") ; QWERTY minus
                                                                                    return "ß" ; QWERTZ ß (sharp s)
                                                                                else if (key = "=") ; QWERTY equals  
                                                                                    return "´" ; QWERTZ acute accent
                                                                                else if (key = "[") ; QWERTY left bracket
                                                                                    return "ü" ; QWERTZ ü
                                                                                else if (key = "]") ; QWERTY right bracket
                                                                                    return "+" ; QWERTZ plus
                                                                                else if (key = ";")        ; QWERTY semicolon
                                                                                    return "ö" ; QWERTZ ö
                                                                                else if (key = "'") ; QWERTY apostrophe
                                                                                    return "ä" ; QWERTZ ä
                                                                                else if (key = "/") ; QWERTY forward slash
                                                                                    return "#" ; QWERTZ hash

                                                                                ; Shifted special characters (when user types Shift+key)
                                                                                else if (key = "_") ; QWERTY underscore (Shift+-)
                                                                                    return "?" ; QWERTZ question mark (Shift+ß)
                                                                                else if (key = "{") ; QWERTY left brace (Shift+[)
                                                                                    return "Ü" ; QWERTZ Ü (Shift+ü)
                                                                                else if (key = "}") ; QWERTY right brace (Shift+])
                                                                                    return "*" ; QWERTZ asterisk (Shift++)
                                                                                else if (key = ":") ; QWERTY colon (Shift+;)
                                                                                    return "Ö" ; QWERTZ Ö (Shift+ö)

                                                                                ; Return original key if no conversion needed
                                                                            return key
                                                                        }

                                                                        ; Checkbox handler for QWERTZ mode
                                                                        qwertzmode:
                                                                            Gui, Submit, NoHide
                                                                            qwertzModeEnabled := qwertzmode
                                                                            ; Save setting to INI file
                                                                            IniWrite, %qwertzModeEnabled%, %iniFile%, Settings, QWERTZMode
                                                                        statusText := qwertzModeEnabled ? "QWERTZ key conversion enabled" : "QWERTZ key conversion disabled"
                                                                            ToolTip, %statusText%, 100, 100
                                                                            SetTimer, ClearToolTip, 2000
                                                                        return

                                                                        ClearToolTip:
                                                                            ToolTip
                                                                            SetTimer, ClearToolTip, Off
                                                                        return

                                                                        ; ========= SHARED FUNCTIONS =========
                                                                        CloseApp:
                                                                            SetTimer, CheckExecutions, Off
                                                                            SetTimer, CheckHealth, Off
                                                                            SetTimer, DPSLoop, Off
                                                                            ClearBoundingBoxes()
                                                                        ExitApp
                                                                        return

                                                                        CheckWindowExists:
                                                                            ; Only check if at least one sequence is running
                                                                            if (!IsRunning1 && !IsRunning2 && !IsRunning3)
                                                                                return

                                                                            ; Check if the target window still exists
                                                                            IfWinNotExist, ahk_id %win1%
                                                                            {
                                                                                ; Window no longer exists, pause all running sequences
                                                                                windowWasClosed := true

                                                                                if (IsRunning1) {
                                                                                    IsRunning1 := false
                                                                                    GuiControl,, StartStop1, Start1
                                                                                    GuiControl,, CountdownText1, Next: --
                                                                                    UpdateStatus1("Window closed - paused")
                                                                                }
                                                                                if (IsRunning2) {
                                                                                    IsRunning2 := false
                                                                                    GuiControl,, StartStop2, Start2
                                                                                    GuiControl,, CountdownText2, Next: --
                                                                                    UpdateStatus2("Window closed - paused")
                                                                                }
                                                                                if (IsRunning3) {
                                                                                    IsRunning3 := false
                                                                                    GuiControl,, StartStop3, Start3
                                                                                    GuiControl,, CountdownText3, Next: --
                                                                                    UpdateStatus3("Window closed - paused")
                                                                                }

                                                                                ; Stop the main execution timer
                                                                                SetTimer, CheckExecutions, Off

                                                                                ; Show notification
                                                                                TrayTip, Window Monitor, Target window was closed. All sequences paused., 5, 2
                                                                            }
                                                                        return

                                                                        ; Add this function to start the window monitoring timer
                                                                        StartWindowMonitoring() {
                                                                            SetTimer, CheckWindowExists, 2000 ; Check every 2 seconds
                                                                        }

                                                                        ; Add this function to stop the window monitoring timer
                                                                        StopWindowMonitoring() {
                                                                            SetTimer, CheckWindowExists, Off
                                                                        }
                                                                        ; Hotkeys for script control

                                                                        ; ========= TEMPLAR FUNCTIONS =========
                                                                        ; ValidateTemplarTargetCount:
                                                                        ;     Gui, Submit, NoHide
                                                                        ;     if (TemplarTargetCountEdit < 1)
                                                                        ;     {
                                                                        ;         TemplarTargetCountEdit := 1
                                                                        ;         GuiControl,, TemplarTargetCountEdit, 1
                                                                        ;     }
                                                                        ;     else if (TemplarTargetCountEdit > 20)
                                                                        ;     {
                                                                        ;         TemplarTargetCountEdit := 20
                                                                        ;         GuiControl,, TemplarTargetCountEdit, 20
                                                                        ;     }
                                                                        ;     TemplarTargetCount := TemplarTargetCountEdit
                                                                        ; return

                                                                        ; SetTemplarPoints:
                                                                        ;     Gui, Submit, NoHide
                                                                        ;     TemplarTargetCount := TemplarTargetCountEdit

                                                                        ;     if (win2 = "") {
                                                                        ;         UpdateTemplarStatus("Please select Templar window first.")
                                                                        ;         return
                                                                        ;     }

                                                                        ;     ; Clear existing coordinates
                                                                        ;     TemplarTargetCoords := []

                                                                        ;     ; Hide GUI temporarily
                                                                        ;     Gui, Hide

                                                                        ;     MsgBox, 4, Set Templar Points, Click OK then Right-click on %TemplarTargetCount% target locations.`n`nPress ESC to cancel.
                                                                        ;     IfMsgBox No
                                                                        ;     {
                                                                        ;         Gui, Show
                                                                        ;         return
                                                                        ;     }

                                                                        ;     ; Capture coordinates for each target
                                                                        ;     Loop, %TemplarTargetCount% {
                                                                        ;         currentTarget := A_Index
                                                                        ;         ToolTip, Left-click on Target %currentTarget% of %TemplarTargetCount%, 100, 100

                                                                        ;         ; Wait for left click
                                                                        ;         KeyWait, rButton, D
                                                                        ;         MouseGetPos, TargetX, TargetY

                                                                        ;         ; Store coordinates
                                                                        ;         TemplarTargetCoords.Push({X: TargetX, Y: TargetY})

                                                                        ;         KeyWait, rButton
                                                                        ;         Sleep, 200
                                                                        ;     }

                                                                        ;     ToolTip

                                                                        ;     ; Show summary
                                                                        ;     summaryText := "Captured " . TemplarTargetCount . " target points:`n`n"
                                                                        ;     For index, coords in TemplarTargetCoords {
                                                                        ;         summaryText .= "Target " . index . ": (" . coords.X . ", " . coords.Y . ")`n"
                                                                        ;     }

                                                                        ;     MsgBox, 64, Points Captured, %summaryText%

                                                                        ;     ; Show GUI again
                                                                        ;     Gui, Show

                                                                        ;     UpdateTemplarStatus("Captured " . TemplarTargetCount . " target coordinates successfully.")
                                                                        ; return

                                                                        ; SaveHolygroundHotkey:
                                                                        ;     SaveTemplarSettings()
                                                                        ;     UpdateTemplarStatus("Templar settings saved to INI")
                                                                        ; return

                                                                        ; StartTemplarScript:
                                                                        ;     if (win2 = "") {
                                                                        ;         UpdateTemplarStatus("Please select Templar window first.")
                                                                        ;         return
                                                                        ;     }

                                                                        ;     if (TemplarTargetCoords.Length() = 0) {
                                                                        ;         UpdateTemplarStatus("Please set target points first.")
                                                                        ;         return
                                                                        ;     }

                                                                        ;     if (HolygroundHotkey = "") {
                                                                        ;         UpdateTemplarStatus("Please set Holyground hotkey first.")
                                                                        ;         return
                                                                        ;     }

                                                                        ;     ; Start the Templar script
                                                                        ;     SetTimer, TemplarLoop, 100
                                                                        ;     UpdateTemplarStatus("Templar script started - clicking targets and casting Holyground")
                                                                        ; return

                                                                        ; StopTemplarScript:
                                                                        ;     SetTimer, TemplarLoop, Off
                                                                        ;     UpdateTemplarStatus("Templar script stopped.")
                                                                        ; return

                                                                        ; SendHolygroundHotkey() {
                                                                        ;     global HolygroundHotkey, win2

                                                                        ;     if (HolygroundHotkey = "" || win2 = "")
                                                                        ;         return

                                                                        ;     ; Check for modifier keys and handle them separately
                                                                        ;     hasCtrl := InStr(HolygroundHotkey, "^")
                                                                        ;     hasAlt := InStr(HolygroundHotkey, "!")
                                                                        ;     hasShift := InStr(HolygroundHotkey, "+")

                                                                        ;     ; Extract the base key (remove modifiers)
                                                                        ;     baseKey := HolygroundHotkey
                                                                        ;     if (hasCtrl)
                                                                        ;         baseKey := StrReplace(baseKey, "^", "")
                                                                        ;     if (hasAlt)
                                                                        ;         baseKey := StrReplace(baseKey, "!", "")
                                                                        ;     if (hasShift)
                                                                        ;         baseKey := StrReplace(baseKey, "+", "")

                                                                        ;     ; Send modifier keys down
                                                                        ;     if (hasCtrl)
                                                                        ;         ControlSend, , {Ctrl down}, ahk_id %win1%
                                                                        ;     if (hasAlt)
                                                                        ;         ControlSend, , {Alt down}, ahk_id %win1%
                                                                        ;     if (hasShift)
                                                                        ;         ControlSend, , {Shift down}, ahk_id %win1%

                                                                        ;     ; Send the base key
                                                                        ;     ControlSend, , {%baseKey% down}, ahk_id %win1%
                                                                        ;     Sleep, 50
                                                                        ;     ControlSend, , {%baseKey% up}, ahk_id %win1%

                                                                        ;     ; Send modifier keys up (in reverse order)
                                                                        ;     if (hasShift)
                                                                        ;         ControlSend, , {Shift up}, ahk_id %win1%
                                                                        ;     if (hasAlt)
                                                                        ;         ControlSend, , {Alt up}, ahk_id %win1%
                                                                        ;     if (hasCtrl)
                                                                        ;         ControlSend, , {Ctrl up}, ahk_id %win1%
                                                                        ; }

                                                                        ; UpdateTemplarStatus(message) {
                                                                        ;     global

                                                                        ;     ; Get current time
                                                                        ;     FormatTime, timeStamp,, HH:mm:ss

                                                                        ;     ; Add timestamp to message
                                                                        ;     newMessage := "[" . timeStamp . "] " . message . "`r`n"

                                                                        ;     ; Get current content and add new message
                                                                        ;     GuiControlGet, currentContent, , TemplarStatusEdit
                                                                        ;     if (currentContent != "") {
                                                                        ;         newContent := currentContent . newMessage
                                                                        ;     } else {
                                                                        ;         newContent := newMessage
                                                                        ;     }

                                                                        ;     ; Keep only the last 15 lines to prevent overflow
                                                                        ;     lines := StrSplit(newContent, "`r`n")
                                                                        ;     if (lines.Length() > 15) {
                                                                        ;         newContent := ""
                                                                        ;         Loop % Min(15, lines.Length()) {
                                                                        ;             if (lines[lines.Length() - 15 + A_Index] != "") {
                                                                        ;                 newContent .= lines[lines.Length() - 15 + A_Index] . "`r`n"
                                                                        ;             }
                                                                        ;         }
                                                                        ;     }

                                                                        ;     ; Update the GUI control
                                                                        ;     GuiControl,, TemplarStatusEdit, %newContent%
                                                                        ; }

                                                                        ; SaveTemplarSettings() {
                                                                        ;     global iniFile, HolygroundHotkey, RandomXVariation, RandomYVariation, MinDelay, MaxDelay

                                                                        ;     Gui, Submit, NoHide
                                                                        ;     RandomXVariation := RandomXVariationEdit
                                                                        ;     RandomYVariation := RandomYVariationEdit
                                                                        ;     MinDelay := MinDelayEdit
                                                                        ;     MaxDelay := MaxDelayEdit

                                                                        ;     ; Validate that min is not greater than max
                                                                        ;     if (MinDelay > MaxDelay) {
                                                                        ;         temp := MinDelay
                                                                        ;         MinDelay := MaxDelay
                                                                        ;         MaxDelay := temp
                                                                        ;         GuiControl,, MinDelayEdit, %MinDelay%
                                                                        ;         GuiControl,, MaxDelayEdit, %MaxDelay%
                                                                        ;         UpdateTemplarStatus("Swapped min/max delay values (min was greater than max)")
                                                                        ;     }

                                                                        ;     FileEncoding, UTF-8
                                                                        ;     IniWrite, %HolygroundHotkey%, %iniFile%, TemplarSettings, HolygroundHotkey
                                                                        ;     IniWrite, %RandomXVariation%, %iniFile%, TemplarSettings, RandomXVariation
                                                                        ;     IniWrite, %RandomYVariation%, %iniFile%, TemplarSettings, RandomYVariation
                                                                        ;     IniWrite, %MinDelay%, %iniFile%, TemplarSettings, MinDelay
                                                                        ;     IniWrite, %MaxDelay%, %iniFile%, TemplarSettings, MaxDelay
                                                                        ;     FileEncoding
                                                                        ; }

                                                                        ; LoadTemplarSettings() {
                                                                        ;     global iniFile, HolygroundHotkey, RandomXVariation, RandomYVariation, MinDelay, MaxDelay

                                                                        ;     IniRead, loadedHotkey, %iniFile%, TemplarSettings, HolygroundHotkey, %A_Space%
                                                                        ;     if (loadedHotkey != "ERROR" && loadedHotkey != "") {
                                                                        ;         HolygroundHotkey := loadedHotkey
                                                                        ;         GuiControl,, HolygroundHotkeyEdit, %HolygroundHotkey%
                                                                        ;     }

                                                                        ;     IniRead, loadedXVar, %iniFile%, TemplarSettings, RandomXVariation, 5
                                                                        ;     if (loadedXVar != "ERROR") {
                                                                        ;         RandomXVariation := loadedXVar
                                                                        ;         GuiControl,, RandomXVariationEdit, %RandomXVariation%
                                                                        ;     }

                                                                        ;     IniRead, loadedYVar, %iniFile%, TemplarSettings, RandomYVariation, 5
                                                                        ;     if (loadedYVar != "ERROR") {
                                                                        ;         RandomYVariation := loadedYVar
                                                                        ;         GuiControl,, RandomYVariationEdit, %RandomYVariation%
                                                                        ;     }

                                                                        ;     IniRead, loadedMinDelay, %iniFile%, TemplarSettings, MinDelay, 80
                                                                        ;     if (loadedMinDelay != "ERROR") {
                                                                        ;         MinDelay := loadedMinDelay
                                                                        ;         GuiControl,, MinDelayEdit, %MinDelay%
                                                                        ;     }

                                                                        ;     IniRead, loadedMaxDelay, %iniFile%, TemplarSettings, MaxDelay, 150
                                                                        ;     if (loadedMaxDelay != "ERROR") {
                                                                        ;         MaxDelay := loadedMaxDelay
                                                                        ;         GuiControl,, MaxDelayEdit, %MaxDelay%
                                                                        ;     }
                                                                        ; }

                                                                        ; TemplarLoop:
                                                                        ;     ; Check if window still exists
                                                                        ;     IfWinNotExist, ahk_id %win2%
                                                                        ;     {
                                                                        ;         UpdateTemplarStatus("Templar window closed - stopping script")
                                                                        ;         SetTimer, TemplarLoop, Off
                                                                        ;         return
                                                                        ;     }

                                                                        ;     ; Get current settings from GUI
                                                                        ;     Gui, Submit, NoHide
                                                                        ;     currentXVar := RandomXVariationEdit
                                                                        ;     currentYVar := RandomYVariationEdit
                                                                        ;     currentMinDelay := MinDelayEdit
                                                                        ;     currentMaxDelay := MaxDelayEdit

                                                                        ;     ; Validate delay values
                                                                        ;     if (currentMinDelay > currentMaxDelay) {
                                                                        ;         temp := currentMinDelay
                                                                        ;         currentMinDelay := currentMaxDelay
                                                                        ;         currentMaxDelay := temp
                                                                        ;     }

                                                                        ;     ; Activate the window first
                                                                        ;     WinActivate, ahk_id %win2%
                                                                        ;     Random, activateDelay, 20, 50
                                                                        ;     Sleep, %activateDelay%

                                                                        ;     ; Click on each target and cast Holyground
                                                                        ;     For index, coords in TemplarTargetCoords {
                                                                        ;         ; Extract base coordinates
                                                                        ;         baseX := coords.X
                                                                        ;         baseY := coords.Y

                                                                        ;         ; Add random variation
                                                                        ;         Random, xOffset, -%currentXVar%, %currentXVar%
                                                                        ;         Random, yOffset, -%currentYVar%, %currentYVar%

                                                                        ;         targetX := baseX + xOffset
                                                                        ;         targetY := baseY + yOffset
                                                                        ;         ; Random delay between click and spell cast
                                                                        ;         Random, clickDelay, 30, 80
                                                                        ;         ; Cast Holyground using the hotkey
                                                                        ;         SendHolygroundHotkey()
                                                                        ;         ; Move mouse to randomized target location and click
                                                                        ;         MouseMove, %targetX%, %targetY%, 0
                                                                        ;         Sleep, %clickDelay%
                                                                        ;         Click

                                                                        ;         ; Use the custom random delay range
                                                                        ;         Random, targetDelay, %currentMinDelay%, %currentMaxDelay%
                                                                        ;         Sleep, %targetDelay%
                                                                        ;     }
                                                                        ; return

                                                                        capchacheck:
                                                                            {

                                                                                confirm:="|<highlighted>DCEAFC-323232$33.D00o0200400ESxpjw2IYd8UUUZ92444d8EGUZ91vo4d8U"
                                                                                confirm.="|<>DFE4E8-323232$32.S01c0800E023rihz0Z9+G0EEGYW444d8UZ1+G7jEGYW"
                                                                                confirm.="|<>D3D8DE-323232$41.DU01800k006001000A0020wyxRzs214Wm8k0294YEE04288UU084EF100E8UW1wwUF148"

                                                                                capchaguardactivatedmessage:="|<>FD4039-323232$97.000E000000000000020800Ak000U00E001040080000E00801Rtmts414wds7XbEKWF14220W1F40+2+9E80U100F0c204150cI0E8UUcYI10W0W4o2080EEIE+0U10F8+944284+954E8c8aBsNm1o1souVc7HXF4U000000000000000E000000000000000U"
                                                                                capchaguardactivatedmessage.="|<>E22E2F-323232$70.0001000000040104006M000E040E00U0001wywxww20WSIw+944E882854FcIEF1UXcUoFmVE14m22WNE6+544G88+954McYEF8UkcYIFuwAt4u0wSREw20000000000080000000000U"
                                                                                capchaguardactivatedmessage.="|<>E63C37-0.90$69.000000E0000200020200000U000E0E000001wTbXnwT0E100G4EUEU420802E20240U0100G2E0E0A20c0WEG020EUE5U0G0E0E0420g02EW4200U8504G000E2400000E0000000000200000000000E00000000U"

                                                                                capcha:="|<>*62$43.szzzzjzs7zxzrztzzyzvzxy224460zxQiyvwTsiKTQsDkL/DiELnfZbr3dtZqvvVa22365m3zzTzzzzzzjzzzzzzrzzzzk"
                                                                                capchaguardtargetted:="|<>FFFFFF-323232$71.C00002000w00W002040024022004080084040QKQQK70E14M14mF4mF0U29E094W14217YEU3m9428w218X18YG84G842F94HAYF8Yk48WFkOKAQF6U7UwE00U00000000001000000000002000000001"
                                                                                capchaconfirm:="|<>DFE3E9-323232$33.D00o0200400ESxpjw2IYd8UUUZ92444d8EGUZ91vo4d8U"
                                                                                capchaquestionwindowopen:="|<>FFFFFF-323232$37.C00000cU0000M8sgACA0WN98a018Y4H07YG3tUYG910cWN4YWHUoWACA"
                                                                                if (FindText(X, Y, 0, 0, 1919, 1030, 0, 0, capchaguardactivatedmessage, , 0))
                                                                                {
                                                                                    sleep, 50
                                                                                    ;MsgBox, found message
                                                                                    Loop,
                                                                                    {
                                                                                        ;MsgBox, looping
                                                                                        (FindText(AX, AY, 0, 0, 1919, 1030, 0, 0, confirm))
                                                                                        {
                                                                                            ;Critical, on
                                                                                            ;WinActivate, ahk_id %win1%                   
                                                                                            ; settimer, DPSLoop, off
                                                                                            ; SetTimer, essences, off
                                                                                            ; SetTimer, buffdaddystone, off
                                                                                            ;  SetTimer, buffpetscroll, off
                                                                                            settimer, checkweight, off
                                                                                            ; SetTimer, snapshot, off
                                                                                            sleep, 100
                                                                                            SendMessageClick(AX, AY)

                                                                                            if (!ok:=FindText(X, Y, 0, 0, 1919, 1030, 0, 0, capchaguardactivatedmessage, , 0))
                                                                                            {
                                                                                                break
                                                                                            }
                                                                                        }

                                                                                    }

                                                                                    Gosub, PylonClicker
                                                                                    return
                                                                                }
                                                                                ;MsgBox, returned
                                                                                return
                                                                            }

                                                                        PylonClicker:
                                                                            ; Click the pylon location once per second
                                                                            sleep, 750
                                                                            Loop, {

                                                                                ; Check for any question patterns
                                                                                ht:="|<>FBFF47-323232$20.TU0zw0Tb0T1k7lw1gT031k0kAwDXD3tk0zw0By03U"
                                                                                ht.="|<>FFFF00-323232$20.TU0zw0Tb0T1k7lw1gT031k0kAwDXD3tk0zw0By03U"
                                                                                ht.="|<>FFFF00-323232$25.600z700zzUMQzkAADM60CATs76DwD30kD1UMD0kA70M07yA03zU"
                                                                                ht.="|<>FFFF00-323232$20.TU0zw0Tb0Tkk7kQ1g7037U0nkwBsD3Q00zw0Dz03U"
                                                                                ht.="|<>FBFF47-0.90$26.TU03jw00vb30Skkk7UQA3s7Ttq7byNXkACNs33zQ0kzzw00Pz006U"
                                                                                ht.="|<>FFFF00-323232$26.TU03jw00vb30Skkk7UQA3s7Ttq7byNXkACNs33zQ0kzzw00Pz006U"
                                                                                ht.="|<>FFFF00-323232$26.TU0Tjw0Dzb33bkkkkkQA0Q7Ts77by7XkA3ls31sQ0kQDw0Dzz03zU"
                                                                                ht.="|<>FFFF00-323232$26.3U0TUs0DwS33b7Uk1nsA1xqTsTNby1yMA0Dz33XzkktkM0Dw601yU"
                                                                                ht.="|<>FBFF47-323232$26.3U0TUs0DwS33b7Uk1nsA1xqTsTNby1yMA0Dz33XzkktkM0Dw601yU"
                                                                                ht.="|<>FFFF00-323232$70.llk1U001zX03Db060007zA0AyQ0M000MQ00vvbvtwT1UnQTjizjjtw67AviqviMvbETwlwTTXtXyQ1zX7lxwzaDtU60AC7rnyMk60M0lwTTCtXiM1U37ksszrjtU60AvXXVzST60M0r7U"
                                                                                ht.="|<>FFFF00-323232$26.kC0My706BnU1UQtwynwzjgSCtX7XyMkkzaAAA1X33iMkkzbgA7lvU"
                                                                                ht.="|<>FFFF00-323232$25.Dk00Dw00DD0073bnzVnvzUNprkAskM6MMC7AA7ba7RzX3yTVUyU"
                                                                                ht.="|<>FFFF00-323232$65.TlU01U0k001zn00301U003ba0060300077AwyATDbszjUPnyNzTTtzjsz7QniMtnrDtwDtbwlnb63nwTnDtX3ADVbsk6M37CMTbAtrAvaCQkzyNnyNzDTtVjslnslwSTX3U"
                                                                                ht.="|<>FBFF47-323232$63.Dk060000003z00k000000ww0600000073Xxwz7wMMysQzjjwzn3Dy1bQlnbCMNrkAk6CQtn3Da1a0lVa6MNzsQk6CQtn73zbbQlnbCRtrTszbjwznzDty3swz7wDsy000000k00000000060000000000k0004"
                                                                                ht.="|<>FFFF00-323232$63.Dk060000003z00k000000ww0600000073Xxwz7wMMysQzjjwzn3Dy1bQlnbCMNrkAk6CQtn3Da1a0lVa6MNzsQk6CQtn73zbbQlnbCRtrTszbjwznzDty3swz7wDsy000000k00000000060000000000k0004"
                                                                                ht.="|<>FBFF47-323232$38.TlU000DyM0003bU0000stbnszjUNxzDxz6RRnrDtb7wskSNVzADVaMM33wta7QkzyNVzABz6MDX3U"
                                                                                ht.="|<>FFFF00-323232$38.TlU000DyM0003bU0000stbnszjUNxzDxz6RRnrDtb7wskSNVzADVaMM33wta7QkzyNVzABz6MDX3U"
                                                                                ht.="|<>FFFF00-323232$19.wC7yDXw7kS3MD3i7Vr3llVszswTwSQ7DC3bb1nk01y03z01w"
                                                                                ht.="|<>FFFF00-323232$20.xzXzTwz673lUkwMQD7z3lzswMSD61XlUswTyD7z3k00z00zk0DU"
                                                                                ht.="|<>FBFF47-323232$20.xzXzTwz67XlUswMCD61XlUMwMCD63XlVswTwD7y3k00z00zk0DU"
                                                                                ht.="|<>FFFF00-323232$21.xzXrjySlVsqA76lUsqA36lUMqA76lUsqAD6lzkqDw6k00rU0Sw03o"
                                                                                ht.="|<>FFFF00-323232$20.wTnzDyz7bXlkswQ0D603lU0wQ0D73XltswDyD1z3k00z00zk0DU"

                                                                                ; Check if any question pattern is found
                                                                                if (FindText(QX, QY, 0, 0, 1919, 1030, 0, 0, ht)) {

                                                                                    ; Stop clicking and solve captcha

                                                                                    SolveCaptcha()
                                                                                    ; Restart clicking after solving
                                                                                    return
                                                                                } else {
                                                                                    ; Convert window-relative coordinates to screen coordinates
                                                                                    WinGetPos, winX, winY,,, ahk_id %win1%
                                                                                    screenPylonX := winX + pylonX
                                                                                    screenPylonY := winY + pylonY
                                                                                    SendMessageClick(screenPylonX, screenPylonY)
                                                                                }
                                                                                sleep, 1000
                                                                            }
                                                                        Return

                                                                        SolveCaptcha() {
                                                                            ;sgBox, solve

                                                                            capchaguardtargetted:="|<>FFFFFF-323232$71.C00002000w00W002040024022004080084040QKQQK70E14M14mF4mF0U29E094W14217YEU3m9428w218X18YG84G842F94HAYF8Yk48WFkOKAQF6U7UwE00U00000000001000000000002000000001"
                                                                            capchaconfirm:="|<>DFE3E9-323232$33.D00o0200400ESxpjw2IYd8UUUZ92444d8EGUZ91vo4d8U"
                                                                            capchaquestionwindowopen:="|<>FFFFFF-323232$37.C00000cU0000M8sgACA0WN98a018Y4H07YG3tUYG910cWN4YWHUoWACA"
                                                                            ;questions
                                                                            threeminusone:="|<>FBFF47-323232$20.TU0zw0Tb0T1k7lw1gT031k0kAwDXD3tk0zw0By03U"
                                                                            threeminusone.="|<>FFFF00-323232$20.TU0zw0Tb0T1k7lw1gT031k0kAwDXD3tk0zw0By03U"

                                                                            oneplustwo:="|<>FFFF00-323232$25.600z700zzUMQzkAADM60CATs76DwD30kD1UMD0kA70M07yA03zU"
                                                                            twominusone:="|<>FFFF00-323232$20.TU0zw0Tb0Tkk7kQ1g7037U0nkwBsD3Q00zw0Dz03U"
                                                                            fourplustwo:="|<>FBFF47-0.90$26.TU03jw00vb30Skkk7UQA3s7Ttq7byNXkACNs33zQ0kzzw00Pz006U"
                                                                            fourplustwo.="|<>FFFF00-323232$26.TU03jw00vb30Skkk7UQA3s7Ttq7byNXkACNs33zQ0kzzw00Pz006U"

                                                                            twoplustwo:="|<>FFFF00-323232$26.TU0Tjw0Dzb33bkkkkkQA0Q7Ts77by7XkA3ls31sQ0kQDw0Dzz03zU"
                                                                            fourplusthree:="|<>FFFF00-323232$26.3U0TUs0DwS33b7Uk1nsA1xqTsTNby1yMA0Dz33XzkktkM0Dw601yU"
                                                                            fourplusthree.="|<>FBFF47-323232$26.3U0TUs0DwS33b7Uk1nsA1xqTsTNby1yMA0Dz33XzkktkM0Dw601yU"
                                                                            presswaterpixie:="|<>FFFF00-323232$70.llk1U001zX03Db060007zA0AyQ0M000MQ00vvbvtwT1UnQTjizjjtw67AviqviMvbETwlwTTXtXyQ1zX7lxwzaDtU60AC7rnyMk60M0lwTTCtXiM1U37ksszrjtU60AvXXVzST60M0r7U"
                                                                            pressyeti:="|<>FFFF00-323232$26.kC0My706BnU1UQtwynwzjgSCtX7XyMkkzaAAA1X33iMkkzbgA7lvU"
                                                                            pressorc:="|<>FFFF00-323232$25.Dk00Dw00DD0073bnzVnvzUNprkAskM6MMC7AA7ba7RzX3yTVUyU"
                                                                            pressskeleton:="|<>FFFF00-323232$65.TlU01U0k001zn00301U003ba0060300077AwyATDbszjUPnyNzTTtzjsz7QniMtnrDtwDtbwlnb63nwTnDtX3ADVbsk6M37CMTbAtrAvaCQkzyNnyNzDTtVjslnslwSTX3U"
                                                                            pressoctopus:="|<>FBFF47-323232$63.Dk060000003z00k000000ww0600000073Xxwz7wMMysQzjjwzn3Dy1bQlnbCMNrkAk6CQtn3Da1a0lVa6MNzsQk6CQtn73zbbQlnbCRtrTszbjwznzDty3swz7wDsy000000k00000000060000000000k0004"
                                                                            pressoctopus.="|<>FFFF00-323232$63.Dk060000003z00k000000ww0600000073Xxwz7wMMysQzjjwzn3Dy1bQlnbCMNrkAk6CQtn3Da1a0lVa6MNzsQk6CQtn73zbbQlnbCRtrTszbjwznzDty3swz7wDsy000000k00000000060000000000k0004"

                                                                            presssiren:="|<>FBFF47-323232$38.TlU000DyM0003bU0000stbnszjUNxzDxz6RRnrDtb7wskSNVzADVaMM33wta7QkzyNVzABz6MDX3U"
                                                                            presssiren.="|<>FFFF00-323232$38.TlU000DyM0003bU0000stbnszjUNxzDxz6RRnrDtb7wskSNVzADVaMM33wta7QkzyNVzABz6MDX3U"

                                                                            pressA:="|<>FFFF00-323232$19.wC7yDXw7kS3MD3i7Vr3llVszswTwSQ7DC3bb1nk01y03z01w"
                                                                            pressB:="|<>FFFF00-323232$20.xzXzTwz673lUkwMQD7z3lzswMSD61XlUswTyD7z3k00z00zk0DU"
                                                                            pressD:="|<>FBFF47-323232$20.xzXzTwz67XlUswMCD61XlUMwMCD63XlVswTwD7y3k00z00zk0DU"
                                                                            pressD.="|<>FFFF00-323232$21.xzXrjySlVsqA76lUsqA36lUMqA76lUsqAD6lzkqDw6k00rU0Sw03o"
                                                                            pressC:="|<>FFFF00-323232$20.wTnzDyz7bXlkswQ0D603lU0wQ0D73XltswDyD1z3k00z00zk0DU"
                                                                            ;answers
                                                                            A:="|<>FFFFFF-323232$11.3UDUT0q3i7QQMztzr1y3w7U"
                                                                            A.="|<>FFFFFF-323232$11.3UDUT0q3i7QQMztzr1y3w7U"
                                                                            B:="|<>FFFFFF-323232$10.znzgCkP3jyzz1w3kTzzyU"
                                                                            B.="|<>FFFFFF-323232$10.znzgCkP3jyzz1w3kTzzyU"
                                                                            C:="|<>FFFFFF-323232$10.DtzzDsTUA0k3UC7wxznyU"
                                                                            C.="|<>FFFFFF-323232$10.DtzzDsTUA0k3UC7wxznyU"
                                                                            Dee:="|<>FFFFFF-323232$10.znzgDkT1w3kD1w7kzzjwU"
                                                                            Dee.="|<>FFFFFF-323232$10.znzgDkT1w3kD1w7kzzjwU"
                                                                            Dee.="|<>FFFFFF-0.90$10.znzgDkT1w3kD1w7kzzjwU"
                                                                            one:="|<>FFFFFF-323232$5.6TzxX6AMlXU"
                                                                            one.="|<>FFFFFF-323232$4.4zwF4F6"
                                                                            two:="|<>FFFFFF-323232$8.TjzbkkQ77XlsQDzzU"
                                                                            two.="|<>FFFFFF-323232$8.TjzbkkQ77XlsQDzzU"
                                                                            three:="|<>FFFFFF-323232$8.TjzbFlwT1kDXtzxyU"
                                                                            three.="|<>FFFFFF-323232$8.TjzbFlwT1kDXtzxyU"
                                                                            four:="|<>FFFFFF-323232$8.3UsS7XtqNiPzzkM6U"
                                                                            four.="|<>FFFFFF-323232$8.3UsS7XtqNiPzzkM6U"
                                                                            six:="|<>FFFFFF-323232$8.DbzrsDvztwD3xrwyU"
                                                                            seven:="|<>FFFFFF-323232$8.zzw73VkQ73UsC30kU"
                                                                            seven.="|<>FFFFFF-323232$8.zzw73VkQ73UsC30kU"
                                                                            waterpixie:="|<>FFFFFF-323232$88.sQC0A0001zX01U3Xss0k0007zA060CDXU30000MQ0000QyQzT7ly1UnQRXtrxrxwzbs67AvaTrRrRn3iQUTwlwNrBrQTADtk1zX7lbwyDbwkza060AC6TnsyTn30M0M0lwNUDXtrACtU1U37lbQQ77ywza060AvaTlkQDvlwM0M0r7MyU"
                                                                            waterpixie.="|<>FFFFFF-323232$88.sQC0A0001zX01U3Xss0k0007zA060CDXU30000MQ0000QyQzT7ly1UnQRXtrxrxwzbs67AvaTrRrRn3iQUTwlwNrBrQTADtk1zX7lbwyDbwkza060AC6TnsyTn30M0M0lwNUDXtrACtU1U37lbQQ77ywza060AvaTlkQDvlwM0M0r7MyU"
                                                                            octopus:="|<>FFFFFF-323232$65.Ds030000000zs060000003ls0A00000071lwyDlz66Di1bxwznzAAzs3CtVnbCMNrk6M33bCQkntkAk666MNVbzUtUACQtn73zXniMQtnbSRrz7wwznzDwzbw7lsz7wDsy000000A0000000000M0000000000k0004"
                                                                            octopus.="|<>FFFFFF-323232$65.Ds030000000zs060000003ls0A00000071lwyDlz66Di1bxwznzAAzs3CtVnbCMNrk6M33bCQkntkAk666MNVbzUtUACQtn73zXniMQtnbSRrz7wwznzDwzbw7lsz7wDsy000000A0000000000M0000000000k0004"
                                                                            orc:="|<>FFFFFF-323232$27.Ds003zU00wS0071nwys6Tjy0nZrk6QA70n1UsCMA7Xn1rTwMDtz30yU"
                                                                            orc.="|<>FFFFFF-323232$27.Ds003zU00wS0071nwys6Tjy0nZrk6QA70n1UsCMA7Xn1rTwMDtz30yU"
                                                                            siren:="|<>FFFFFF-323232$39.TlU0007zA0000xs000077AzDXyy1bvyTvyAtRnrDtb3yQMDAkTn3sNa30MTbAkRn3zta3yMPyAkDX3U"
                                                                            siren.="|<>FFFFFF-323232$39.TlU0007zA0000xs000077AzDXyy1bvyTvyAtRnrDtb3yQMDAkTn3sNa30MTbAkRn3zta3yMPyAkDX3U"
                                                                            siren.="|<>FBFF47-323232$38.TlU000DyM0003bU0000stbnszjUNxzDxz6RRnrDtb7wskSNVzADVaMM33wta7QkzyNVzABz6MDX3U"
                                                                            skeleton:="|<>FFFFFF-323232$66.TlU01U0k000ztU01U0k000xtU01U0k000stbblXtwTXyy1jDtbxwznzTlyCtbQktnrDtyDtbwktnX1tyDtbwkkn3sNyA1a0ktn3wtbCtbQktn3ztbDtbwwzn3TlXblXswTX3U"
                                                                            skeleton.="|<>FFFFFF-323232$66.TlU01U0k000ztU01U0k000xtU01U0k000stbblXtwTXyy1jDtbxwznzTlyCtbQktnrDtyDtbwktnX1tyDtbwkkn3sNyA1a0ktn3wtbCtbQktn3ztbDtbwwzn3TlXblXswTX3U"
                                                                            yeti:="|<>FFFFFF-323232$27.kC0MT3U33Qs0M3bDbnDnyyMwRn37XyMMMTn3330MMMRn333ySMMDXnU"
                                                                            yeti.="|<>FFFFFF-323232$27.kC0MT3U33Qs0M3bDbnDnyyMwRn37XyMMMTn3330MMMRn333ySMMDXnU"
                                                                            ;MsgBox, solve
                                                                            ; First check if a CAPTCHA is present
                                                                            loop, 4
                                                                            {
                                                                                ;MsgBox, in loop
                                                                                ; Now check which question is displayed
                                                                                if (FindText(QX, QY, 0, 0, 1919, 1030, 0, 0, threeminusone)) {
                                                                                    ; Answer is 2
                                                                                    if (FindText(AX, AY, 0, 0, 1919, 1030, 0, 0, two)) {
                                                                                        sleep 100
                                                                                        ;Critical, Off
                                                                                        SendMessageClick(AX, AY)
                                                                                        sleep, 200
                                                                                        ;SetTimer, essences, on
                                                                                        ;SetTimer, buffdaddystone, on
                                                                                        ;SetTimer, buffpetscroll, on
                                                                                        settimer, checkweight, on
                                                                                        sleep, 200
                                                                                        ;SetTimer, snapshot, on
                                                                                        ;settimer, DPSLoop, on
                                                                                        return
                                                                                    }
                                                                                }
                                                                                if (FindText(QX, QY, 0, 0, 1919, 1030, 0, 0, oneplustwo)) {
                                                                                    ; Answer is 3
                                                                                    if (FindText(AX, AY, 0, 0, 1919, 1030, 0, 0, three)) {
                                                                                        sleep 100
                                                                                        ;Critical, Off
                                                                                        SendMessageClick(AX, AY)
                                                                                        sleep, 200
                                                                                        ;SetTimer, essences, on
                                                                                        ;SetTimer, buffdaddystone, on
                                                                                        ;SetTimer, buffpetscroll, on
                                                                                        settimer, checkweight, on
                                                                                        sleep, 200
                                                                                        ;SetTimer, snapshot, on
                                                                                        ;settimer, DPSLoop, on
                                                                                        return
                                                                                    }
                                                                                }
                                                                                if (FindText(QX, QY, 0, 0, 1919, 1030, 0, 0, twominusone)) {
                                                                                    ; Answer is 1
                                                                                    if (FindText(AX, AY, 0, 0, 1919, 1030, 0, 0, one)) {
                                                                                        sleep 100
                                                                                        ;Critical, Off
                                                                                        SendMessageClick(AX, AY)
                                                                                        sleep, 200
                                                                                        ;SetTimer, essences, on
                                                                                        ;SetTimer, buffdaddystone, on
                                                                                        ;SetTimer, buffpetscroll, on
                                                                                        settimer, checkweight, on
                                                                                        sleep, 200
                                                                                        ;SetTimer, snapshot, on
                                                                                        ;settimer, DPSLoop, on
                                                                                        return
                                                                                    }
                                                                                }
                                                                                if (FindText(QX, QY, 0, 0, 1919, 1030, 0, 0, twoplustwo)) {
                                                                                    ; Answer is 4
                                                                                    if (FindText(AX, AY, 0, 0, 1919, 1030, 0, 0, four)) {
                                                                                        sleep 100
                                                                                        ;Critical, Off
                                                                                        SendMessageClick(AX, AY)
                                                                                        sleep, 200
                                                                                        ;SetTimer, essences, on
                                                                                        ;SetTimer, buffdaddystone, on
                                                                                        ;SetTimer, buffpetscroll, on
                                                                                        settimer, checkweight, on
                                                                                        sleep, 200
                                                                                        ;SetTimer, snapshot, on
                                                                                        ;settimer, DPSLoop, on
                                                                                        return
                                                                                    }
                                                                                }
                                                                                if (FindText(QX, QY, 0, 0, 1919, 1030, 0, 0, fourplustwo)) {
                                                                                    ; Answer is 4
                                                                                    if (FindText(AX, AY, 0, 0, 1919, 1030, 0, 0, six)) {
                                                                                        sleep 100
                                                                                        ;Critical, Off
                                                                                        SendMessageClick(AX, AY)
                                                                                        sleep, 200
                                                                                        ;SetTimer, essences, on
                                                                                        ;SetTimer, buffdaddystone, on
                                                                                        ;SetTimer, buffpetscroll, on
                                                                                        settimer, checkweight, on
                                                                                        sleep, 200
                                                                                        ;SetTimer, snapshot, on
                                                                                        ;settimer, DPSLoop, on
                                                                                        return
                                                                                    }
                                                                                }
                                                                                if (FindText(QX, QY, 0, 0, 1919, 1030, 0, 0, fourplusthree)) {
                                                                                    ; Answer is 4
                                                                                    if (FindText(AX, AY, 0, 0, 1919, 1030, 0, 0, seven)) {
                                                                                        sleep 100
                                                                                        ;Critical, Off
                                                                                        SendMessageClick(AX, AY)
                                                                                        sleep, 200
                                                                                        ;SetTimer, essences, on
                                                                                        ;SetTimer, buffdaddystone, on
                                                                                        ;SetTimer, buffpetscroll, on
                                                                                        settimer, checkweight, on
                                                                                        sleep, 200
                                                                                        ;SetTimer, snapshot, on
                                                                                        ;settimer, DPSLoop, on
                                                                                        return
                                                                                    }
                                                                                }
                                                                                if (FindText(QX, QY, 0, 0, 1919, 1030, 0, 0, presswaterpixie)) {
                                                                                    ; Find and click waterpixie
                                                                                    if (FindText(AX, AY, 0, 0, 1919, 1030, 0, 0, waterpixie)) {
                                                                                        sleep 100
                                                                                        ;Critical, Off
                                                                                        SendMessageClick(AX, AY)
                                                                                        sleep, 200
                                                                                        ;SetTimer, essences, on
                                                                                        ;SetTimer, buffdaddystone, on
                                                                                        ;SetTimer, buffpetscroll, on
                                                                                        settimer, checkweight, on
                                                                                        sleep, 200
                                                                                        ;SetTimer, snapshot, on
                                                                                        ;settimer, DPSLoop, on
                                                                                        return
                                                                                    }
                                                                                }
                                                                                if (FindText(QX, QY, 0, 0, 1919, 1030, 0, 0, presssiren)) {
                                                                                    ; Find and click waterpixie
                                                                                    if (FindText(AX, AY, 0, 0, 1919, 1030, 0, 0, siren)) {
                                                                                        sleep 100
                                                                                        ;Critical, Off
                                                                                        SendMessageClick(AX, AY)
                                                                                        sleep, 200
                                                                                        ;SetTimer, essences, on
                                                                                        ;SetTimer, buffdaddystone, on
                                                                                        ;SetTimer, buffpetscroll, on
                                                                                        settimer, checkweight, on
                                                                                        sleep, 200
                                                                                        ;SetTimer, snapshot, on
                                                                                        ;settimer, DPSLoop, on
                                                                                        return
                                                                                    }
                                                                                }
                                                                                if (FindText(QX, QY, 0, 0, 1919, 1030, 0, 0, pressyeti)) {
                                                                                    ; Find and click yeti
                                                                                    if (FindText(AX, AY, 0, 0, 1919, 1030, 0, 0, yeti)) {
                                                                                        sleep 100
                                                                                        ;Critical, Off
                                                                                        SendMessageClick(AX, AY)
                                                                                        sleep, 200
                                                                                        ;SetTimer, essences, on
                                                                                        ;SetTimer, buffdaddystone, on
                                                                                        ;SetTimer, buffpetscroll, on
                                                                                        settimer, checkweight, on
                                                                                        sleep, 200
                                                                                        ;SetTimer, snapshot, on
                                                                                        ;settimer, DPSLoop, on
                                                                                        return
                                                                                    }
                                                                                }
                                                                                if (FindText(QX, QY, 0, 0, 1919, 1030, 0, 0, pressorc)) {
                                                                                    ; Find and click orc
                                                                                    if (FindText(AX, AY, 0, 0, 1919, 1030, 0, 0, orc)) {
                                                                                        sleep 100
                                                                                        ;Critical, Off
                                                                                        SendMessageClick(AX, AY)
                                                                                        sleep, 200
                                                                                        ;SetTimer, essences, on
                                                                                        ;SetTimer, buffdaddystone, on
                                                                                        ;SetTimer, buffpetscroll, on
                                                                                        settimer, checkweight, on
                                                                                        sleep, 200
                                                                                        ;SetTimer, snapshot, on
                                                                                        ;settimer, DPSLoop, on
                                                                                        return
                                                                                    }
                                                                                }
                                                                                if (FindText(QX, QY, 0, 0, 1919, 1030, 0, 0, pressskeleton)) {
                                                                                    ; Find and click skeleton
                                                                                    if (FindText(AX, AY, 0, 0, 1919, 1030, 0, 0, skeleton)) {
                                                                                        sleep 100
                                                                                        ;Critical, Off
                                                                                        SendMessageClick(AX, AY)
                                                                                        sleep, 200
                                                                                        ;SetTimer, essences, on
                                                                                        ;SetTimer, buffdaddystone, on
                                                                                        ;SetTimer, buffpetscroll, on
                                                                                        settimer, checkweight, on
                                                                                        sleep, 200
                                                                                        ;SetTimer, snapshot, on
                                                                                        ;settimer, DPSLoop, on
                                                                                        return
                                                                                    }
                                                                                }
                                                                                if (FindText(QX, QY, 0, 0, 1919, 1030, 0, 0, pressoctopus)) {
                                                                                    ; Find and click skeleton
                                                                                    if (FindText(AX, AY, 0, 0, 1919, 1030, 0, 0, octopus)) {
                                                                                        sleep 100
                                                                                        ;Critical, Off
                                                                                        SendMessageClick(AX, AY)
                                                                                        sleep, 200
                                                                                        ;SetTimer, essences, on
                                                                                        ;SetTimer, buffdaddystone, on
                                                                                        ;SetTimer, buffpetscroll, on
                                                                                        settimer, checkweight, on
                                                                                        sleep, 200
                                                                                        ;SetTimer, snapshot, on
                                                                                        ;settimer, DPSLoop, on
                                                                                        return
                                                                                    }
                                                                                }
                                                                                if (FindText(QX, QY, 0, 0, 1919, 1030, 0, 0, pressA)) {
                                                                                    ; Find and click A
                                                                                    if (FindText(AX, AY, 0, 0, 1919, 1030, 0, 0, A)) {
                                                                                        sleep 100
                                                                                        ;Critical, Off
                                                                                        SendMessageClick(AX, AY)
                                                                                        sleep, 200
                                                                                        ;SetTimer, essences, on
                                                                                        ;SetTimer, buffdaddystone, on
                                                                                        ;SetTimer, buffpetscroll, on
                                                                                        settimer, checkweight, on
                                                                                        sleep, 200
                                                                                        ;SetTimer, snapshot, on
                                                                                        ;settimer, DPSLoop, on
                                                                                        return
                                                                                    }
                                                                                }
                                                                                if (FindText(QX, QY, 0, 0, 1919, 1030, 0, 0, pressB)) {
                                                                                    ; Find and click B
                                                                                    if (FindText(AX, AY, 0, 0, 1919, 1030, 0, 0, B)) {
                                                                                        sleep 100
                                                                                        ;Critical, Off
                                                                                        SendMessageClick(AX, AY)
                                                                                        sleep, 200
                                                                                        ;SetTimer, essences, on
                                                                                        ;SetTimer, buffdaddystone, on
                                                                                        ;SetTimer, buffpetscroll, on
                                                                                        settimer, checkweight, on
                                                                                        sleep, 200
                                                                                        ;SetTimer, snapshot, on
                                                                                        ;settimer, DPSLoop, on
                                                                                        return
                                                                                    }
                                                                                }
                                                                                if (FindText(QX, QY, 0, 0, 1919, 1030, 0, 0, pressC)) {
                                                                                    ; Find and click C
                                                                                    if (FindText(AX, AY, 0, 0, 1919, 1030, 0, 0, C)) {
                                                                                        sleep 100
                                                                                        ;Critical, Off
                                                                                        SendMessageClick(AX, AY)
                                                                                        sleep, 200
                                                                                        ;SetTimer, essences, on
                                                                                        ;SetTimer, buffdaddystone, on
                                                                                        ;SetTimer, buffpetscroll, on
                                                                                        settimer, checkweight, on
                                                                                        sleep, 200
                                                                                        ;SetTimer, snapshot, on
                                                                                        ;settimer, DPSLoop, on
                                                                                        return
                                                                                    }
                                                                                }
                                                                                if (FindText(QX, QY, 0, 0, 1919, 1030, 0, 0, pressD)) {
                                                                                    ; Find and click D

                                                                                    if (FindText(AX, AY, 0, 0, 1919, 1030, 0, 0, Dee)) {
                                                                                        sleep 100
                                                                                        ;Critical, Off
                                                                                        SendMessageClick(AX, AY)
                                                                                        sleep, 200
                                                                                        ;SetTimer, essences, on
                                                                                        ;SetTimer, buffdaddystone, on
                                                                                        ;SetTimer, buffpetscroll, on
                                                                                        settimer, checkweight, on
                                                                                        sleep, 200
                                                                                        ;SetTimer, snapshot, on
                                                                                        ;settimer, DPSLoop, on
                                                                                        return
                                                                                    }
                                                                                }
                                                                                ;msgbox, searching for tower
                                                                                Gosub, PylonClicker
                                                                            }

                                                                            ;msgbox, escaped
                                                                        return
                                                                    }
                                                                    return
                                                                    essences:
                                                                        sleep 250
                                                                        ControlSend ,, {6}, ahk_id %win1%
                                                                        sleep 250
                                                                        ControlSend ,, {6}, ahk_id %win1%
                                                                        sleep, 250 sleep, 250

                                                                        ControlSend ,, {7}, ahk_id %win1%
                                                                        sleep, 250
                                                                        ControlSend ,, {6}, ahk_id %win2%
                                                                        sleep, 250
                                                                        ControlSend ,, {7}, ahk_id %win2%
                                                                        sleep, 250
                                                                        ControlSend ,, {8}, ahk_id %win2%
                                                                    Return
                                                                    buffdaddystone:
                                                                        ;WinActivate, ahk_id %win1%  
                                                                        buffdaddy:="|<>#273@0.83$26.080008000A00400PU000C0U3zkh7zy/VyTX0Tzs07zy03No00Kx007zkA3zs10Tq037u00Fi40UC0084S441GE2"
                                                                        buffdaddy.="|<>*126$29.zy07zzUQ3zyAtkzl0Vtz07sNw0zykt7zzJaTzzy/zUyQ3w00k7k00U70000S0000y0005s003rk00bjU007zU023z0047Q008ww00tVs01s"

                                                                        if (buffdaddyok:=FindText(buffdaddyX, buffdaddyY, 0, 0, 1919, 1030, 0, 0, buffdaddy))
                                                                        {
                                                                            SendMessageClick(buffdaddyX, buffdaddyY)
                                                                        }
                                                                        sleep, 150
                                                                        refreshscroll:="|<>*140$23.zzVhzsM3z707s00CA00U001M0S51so8ATt8kDVns806DM0A0k0M3U2"

                                                                        if (brefreshscrollok:=FindText(refreshscrollX, refreshscrollY, 0, 0, 1919, 1030, 0, 0, refreshscroll))
                                                                        {
                                                                            SendMessageClick(refreshscrollX, refreshscrollY)
                                                                        }
                                                                        sleep, 150
                                                                        windpotionlvl5:="|<>*149$20.yzvpk3zvzzzTzyU1zw0Ty03z00zk07w00s"
                                                                        if (windpotionlvl5ok:=FindText(windpotionlvl5X, windpotionlvl5Y, 0, 0, 1919, 1030, 0, 0, windpotionlvl5))
                                                                        {
                                                                            SendMessageClick(windpotionlvl5X, windpotionlvl5Y)
                                                                        }
                                                                    return
                                                                    buffpetscroll:
                                                                        ;WinActivate, ahk_id %win1%  
                                                                        refreshscroll:="|<>*140$23.zzVhzsM3z707s00CA00U001M0S51so8ATt8kDVns806DM0A0k0M3U2"
                                                                        if (brefreshscroll2ok:=FindText(refreshscroll2X, refreshscroll2Y, 0, 0, 1919, 1030, 0, 0, refreshscroll))
                                                                        {
                                                                            SendMessageClick(refreshscroll2X, refreshscroll2Y)
                                                                        }
                                                                        sleep, 150
                                                                    return
                                                                    sellitems:

                                                                        sellscroll:="|<>#47@0.83$7.2DcYG8YD1FUE8h7E"
                                                                        sellscroll.="|<>*133$27.zzzzzzzzzzzzs7zzsDzzkzzzkq0zkE07ss01w800oM01z0M0AQDk00290I0F018280E0D0010w0003M000N00M34062N008/M070Q070107L007uw"

                                                                        if (sellscrollok:=FindText(sellscrollX, sellscrollY, 0, 0, 1919, 1030, 0, 0, sellscroll))
                                                                        {
                                                                            ;WinActivate, ahk_id %win1%  
                                                                            sleep, 1000
                                                                            SendMessageClick(sellscrollX, sellscrollY)
                                                                            sleep, 1000
                                                                            Loop,
                                                                            {
                                                                                sellbutton:="|<>#75@0.83$16.V01800biAG0Hu1824E4Fvc"
                                                                                sellbutton.="|<>#74@0.83$16.l01A06bjAnUnv1A74k4Fzc"
                                                                                if (sellbuttonok:=FindText(sellbuttonX, sellbuttonY, 0, 0, 1919, 1030, 0, 0, sellbutton))
                                                                                {
                                                                                    SendMessageClick(sellbuttonX, sellbuttonY)
                                                                                    Sleep, 1000
                                                                                    break
                                                                                }
                                                                            } until sellbuttonok!
                                                                        }
                                                                        Else
                                                                        {
                                                                            Goto, sellitems
                                                                        }
                                                                    Return
                                                                    snapshot:
                                                                        imgFile := A_ScriptDir "\weightcheck.bmp" 
                                                                        WinGetPos, winX, winY,,, ahk_id %win1%
                                                                        x1 := winX + checkweightX1
                                                                        y1 := winY + checkweightY1
                                                                        x2 := winX + checkweightX2
                                                                        y2 := winY + checkweightY2
                                                                        FindText().Screenshot(x1, y1, x2, y2, 0)
                                                                        Sleep, 500
                                                                        FindText().SavePic(imgFile, x1, y1, x2, y2, 1) 
                                                                        SetTimer, CheckRegionSnapshot, 3000
                                                                    Return 
                                                                    ;==============================================================================
                                                                    CheckRegionSnapshot: 
                                                                        ;  Search entire screen  
                                                                        ImageSearch, sx, sy, 0, 0, A_ScreenWidth, A_ScreenHeight, *50 %A_ScriptDir%\weightcheck.bmp 
                                                                        if (ErrorLevel= 0) { 
                                                                            ToolTip, looter inactive, 1480, 488
                                                                            sleep 1000
                                                                            ControlSend,, +7, ahk_id %win1% 
                                                                            sleep 1000
                                                                        }
                                                                        Else{
                                                                            ToolTip, looter active, 1480, 500
                                                                            SetTimer, CheckRegionSnapshot, Off

                                                                        }
                                                                    Return 
                                                                    checkweight:
                                                                        74weight:="|<>BDBDBD@0.83$23.y2688AGUEMZ11FA22Vf490NET1GU42Z088o"
                                                                        74weight.="|<>BDBDBD@0.83$23.yC688WGUF0Z12lA26Ff48UNEF1GUW2Z0s8o"
                                                                        sleep, 50
                                                                        WinGetPos, winX, winY,,, ahk_id %win1%
                                                                        screenX1 := winX + checkweightX1
                                                                        screenY1 := winY + checkweightY1
                                                                        screenX2 := winX + checkweightX2
                                                                        screenY2 := winY + checkweightY2

                                                                        if (74weightok:=FindText(74weightX, 74weightY, screenX1, screenY1, screenX2, screenY2, 0, 0, 74weight))
                                                                        {
                                                                            Gosub, sellitems
                                                                        }
                                                                    Return
                                                                    f3:: reload

                                                                    SendMessageClick(x, y, winId := "") {
                                                                        if (winId = "")
                                                                            winId := win1

                                                                        ; Get window position and client area
                                                                        WinGetPos, winX, winY,,, ahk_id %winId%

                                                                        ; Calculate relative coordinates (simple screen to window conversion)
                                                                        relativeX := x - winX
                                                                        relativeY := y - winY

                                                                        ; Adjust for title bar and borders (typical Windows offset)
                                                                        relativeX := relativeX - 8
                                                                        relativeY := relativeY - 31

                                                                        ; Create lParam for coordinates
                                                                        lParam := (relativeY << 16) | (relativeX & 0xFFFF)

                                                                        ; Send mouse down and up messages
                                                                        SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
                                                                        Sleep, 50
                                                                        SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
                                                                        Sleep, 50
                                                                        SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
                                                                        Sleep, 50
                                                                        SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
                                                                    }
                                                                    SendMessageClick3(x, y, winId := "") {
                                                                        if (winId = "")
                                                                            winId := win1

                                                                        ; Get window position and client area
                                                                        WinGetPos, winX, winY,,, ahk_id %winId%

                                                                        ; Calculate relative coordinates (simple screen to window conversion)
                                                                        relativeX := x - winX
                                                                        relativeY := y - winY

                                                                        ; Adjust for title bar and borders (typical Windows offset)
                                                                        relativeX := relativeX - 8
                                                                        relativeY := relativeY - 31

                                                                        ; Create lParam for coordinates
                                                                        lParam := (relativeY << 16) | (relativeX & 0xFFFF)

                                                                        ; Send mouse down and up messages
                                                                        SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
                                                                        Sleep, 50
                                                                        SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
                                                                        Sleep, 50
                                                                    }

                                                                    normcontrolclick(x, y, sleepTime := 100) {
                                                                        ControlClick, x%x% y%y%, ahk_id %win1%,, Left, 1, D
                                                                        sleep %sleepTime%
                                                                        ControlClick, x%x% y%y%, ahk_id %win1%,, Left, 1, U
                                                                    }

                                                                    ; ========= COORDINATE SETTINGS FUNCTIONS =========
                                                                    SetCheckSnapshotCoords:
                                                                        Gui, Hide

                                                                        MsgBox, 4, Set Area, Click OK then drag to select the area for both checkweight and snapshot.`n`nClick top-left corner, then drag to bottom-right corner.
                                                                            IfMsgBox No
                                                                        {
                                                                            Gui, Show
                                                                            return
                                                                        }

                                                                        ToolTip, Click and drag to select area, 100, 100

                                                                        KeyWait, LButton, D
                                                                        MouseGetPos, startX, startY
                                                                        KeyWait, LButton
                                                                        MouseGetPos, endX, endY

                                                                        ToolTip

                                                                        WinGetPos, winX, winY,,, ahk_id %win1%
                                                                        checkweightX1 := startX - winX
                                                                        checkweightY1 := startY - winY
                                                                        checkweightX2 := endX - winX
                                                                        checkweightY2 := endY - winY

                                                                        if (checkweightX1 > checkweightX2) {
                                                                            temp := checkweightX1
                                                                            checkweightX1 := checkweightX2
                                                                            checkweightX2 := temp
                                                                        }
                                                                        if (checkweightY1 > checkweightY2) {
                                                                            temp := checkweightY1
                                                                            checkweightY1 := checkweightY2
                                                                            checkweightY2 := temp
                                                                        }

                                                                        SaveCoordinateSettings()
                                                                        UpdateCoordinateDisplay()

                                                                        MsgBox, 64, Success, Area set to:`n%checkweightX1%,%checkweightY1% to %checkweightX2%,%checkweightY2%

                                                                        Gui, Show
                                                                    return

                                                                    SaveCoordinateSettings() {
                                                                        global iniFile, checkweightX1, checkweightY1, checkweightX2, checkweightY2

                                                                        FileEncoding, UTF-8
                                                                        IniWrite, %checkweightX1%, %iniFile%, CoordinateSettings, CheckweightX1
                                                                        IniWrite, %checkweightY1%, %iniFile%, CoordinateSettings, CheckweightY1
                                                                        IniWrite, %checkweightX2%, %iniFile%, CoordinateSettings, CheckweightX2
                                                                        IniWrite, %checkweightY2%, %iniFile%, CoordinateSettings, CheckweightY2
                                                                        FileEncoding
                                                                    }

                                                                    LoadCoordinateSettings() {
                                                                        global iniFile, checkweightX1, checkweightY1, checkweightX2, checkweightY2

                                                                        IniRead, loadedCWX1, %iniFile%, CoordinateSettings, CheckweightX1, %checkweightX1%
                                                                        IniRead, loadedCWY1, %iniFile%, CoordinateSettings, CheckweightY1, %checkweightY1%
                                                                        IniRead, loadedCWX2, %iniFile%, CoordinateSettings, CheckweightX2, %checkweightX2%
                                                                        IniRead, loadedCWY2, %iniFile%, CoordinateSettings, CheckweightY2, %checkweightY2%

                                                                        if (loadedCWX1 != "ERROR") checkweightX1 := loadedCWX1
                                                                            if (loadedCWY1 != "ERROR") checkweightY1 := loadedCWY1
                                                                            if (loadedCWX2 != "ERROR") checkweightX2 := loadedCWX2
                                                                            if (loadedCWY2 != "ERROR") checkweightY2 := loadedCWY2

                                                                        SetTimer, UpdateCoordinateDisplayDelayed, 500
                                                                    }

                                                                    UpdateCoordinateDisplayDelayed:
                                                                        UpdateCoordinateDisplay()
                                                                    return

                                                                    UpdateCoordinateDisplay() {
                                                                        global checkweightX1, checkweightY1, checkweightX2, checkweightY2

                                                                        coordText := "Area: " . checkweightX1 . "," . checkweightY1 . " to " . checkweightX2 . "," . checkweightY2

                                                                        GuiControl,, CheckSnapshotCoordsText, %coordText%
                                                                    }

                                                                    ForceRefreshDPS:
                                                                        RefreshDPSPriorityList()
                                                                    return

                                                                    ForceRefreshcc:
                                                                        RefreshccPriorityList()
                                                                    return

                                                                    ForceRefreshHeal:
                                                                        RefreshHealPriorityList()
                                                                    return

                                                                    ; Timer functions to remove health dots
                                                                    RemoveHealthDot1:
                                                                        Gui, HealthDot1:Destroy
                                                                    return
                                                                    RemoveHealthDot2:
                                                                        Gui, HealthDot2:Destroy
                                                                    return
                                                                    RemoveHealthDot3:
                                                                        Gui, HealthDot3:Destroy
                                                                    return
                                                                    RemoveHealthDot4:
                                                                        Gui, HealthDot4:Destroy
                                                                    return
                                                                    RemoveHealthDot5:
                                                                        Gui, HealthDot5:Destroy
                                                                    return
                                                                    RemoveHealthDot6:
                                                                        Gui, HealthDot6:Destroy
                                                                    return
                                                                    RemoveHealthDot7:
                                                                        Gui, HealthDot7:Destroy
                                                                    return
                                                                    RemoveHealthDot8:
                                                                        Gui, HealthDot8:Destroy
                                                                    return
                                                                    RemoveHealthDot11:
                                                                        Gui, HealthDot11:Destroy
                                                                    return
                                                                    RemoveHealthDot12:
                                                                        Gui, HealthDot12:Destroy
                                                                    return
                                                                    RemoveHealthDot13:
                                                                        Gui, HealthDot13:Destroy
                                                                    return
                                                                    RemoveHealthDot14:
                                                                        Gui, HealthDot14:Destroy
                                                                    return
                                                                    RemoveHealthDot15:
                                                                        Gui, HealthDot15:Destroy
                                                                    return
                                                                    RemoveHealthDot16:
                                                                        Gui, HealthDot16:Destroy
                                                                    return

                                                                    ; ========= MANUAL HEALING FUNCTIONS =========
                                                                    SetManualCoords:
                                                                        Gui, Submit, NoHide
                                                                        PlayerCount := PlayerCountEdit
                                                                        PetCount := PetCountEdit

                                                                        if (PlayerCount = 0 && PetCount = 0) {
                                                                            UpdateHealerStatus("Set at least 1 player or pet count first.")
                                                                            return
                                                                        }

                                                                        ManualPlayerCoords := []
                                                                        ManualPetCoords := []

                                                                        Gui, Hide

                                                                        if (PlayerCount > 0) {
                                                                            MsgBox, Click OK then left-click on %PlayerCount% player health bar locations.
                                                                            Loop, %PlayerCount% {
                                                                                ToolTip, Click on Player %A_Index% health bar, 100, 100
                                                                                KeyWait, LButton, D
                                                                                MouseGetPos, px, py
                                                                                ManualPlayerCoords.Push({x: px, y: py})
                                                                                KeyWait, LButton
                                                                                Sleep, 200
                                                                            }
                                                                        }

                                                                        if (PetCount > 0) {
                                                                            MsgBox, Now left-click on %PetCount% pet health bar locations.
                                                                            Loop, %PetCount% {
                                                                                ToolTip, Click on Pet %A_Index% health bar, 100, 100
                                                                                KeyWait, LButton, D
                                                                                MouseGetPos, px, py
                                                                                ManualPetCoords.Push({x: px, y: py})
                                                                                KeyWait, LButton
                                                                                Sleep, 200
                                                                            }
                                                                        }

                                                                        ToolTip
                                                                        Gui, Show

                                                                        statusText := "Manual coords set: " . PlayerCount . " players, " . PetCount . " pets"
                                                                        GuiControl,, ManualHealStatus, %statusText%
                                                                        UpdateHealerStatus(statusText)
                                                                    return

                                                                    StartManualHealing:
                                                                        if (ManualPlayerCoords.Length() = 0 && ManualPetCoords.Length() = 0) {
                                                                            UpdateHealerStatus("Set manual coordinates first.")
                                                                            return
                                                                        }

                                                                        isManualHealingActive := true
                                                                        SetTimer, ManualHealthCheck, %healCheckInterval%
                                                                        UpdateHealerStatus("Manual healing started - checking " . ManualPlayerCoords.Length() . " players, " . ManualPetCoords.Length() . " pets")
                                                                    return

                                                                    StopManualHealing:
                                                                        isManualHealingActive := false
                                                                        SetTimer, ManualHealthCheck, Off
                                                                        UpdateHealerStatus("Manual healing stopped.")
                                                                    return

                                                                    ManualHealthCheck:
                                                                        if (!isManualHealingActive)
                                                                            return

                                                                        ; Check manual player coordinates
                                                                        for index, coords in ManualPlayerCoords {
                                                                            checkX := coords.x
                                                                            checkY := coords.y

                                                                            ; Look for full health (green)
                                                                            healthFull := "|<>##0.90$0/0/24690C,0/1/00AA90,0/2/006655,0/3/3ED514"
                                                                            healthFull.="|<>##0.90$0/0/51CA2F,0/1/48C723,0/2/42D019,0/3/25A800,0/4/259F00"

                                                                            healthFound := FindText(0, 0, checkX-10, checkY-10, checkX+10, checkY+10, 0, 0, healthFull)

                                                                            if (!healthFound) {
                                                                                SendMessageClick(checkX, checkY)
                                                                                TryCastHealingSkill()
                                                                                UpdateHealerStatus("→ Healed Manual Player " . index)
                                                                                Sleep, 25
                                                                            }
                                                                        }

                                                                        ; Check manual pet coordinates
                                                                        for index, coords in ManualPetCoords {
                                                                            checkX := coords.x
                                                                            checkY := coords.y

                                                                            ; Look for full health (green)
                                                                            healthFull := "|<>##0.90$0/0/24690C,0/1/00AA90,0/2/006655,0/3/3ED514"
                                                                            healthFull.="|<>##0.90$0/0/51CA2F,0/1/48C723,0/2/42D019,0/3/25A800,0/4/259F00"
                                                                            healthFound := FindText(0, 0, checkX-10, checkY-10, checkX+10, checkY+10, 0, 0, healthFull)

                                                                            if (!healthFound) {
                                                                                SendMessageClick(checkX, checkY)
                                                                                TryCastHealingSkill()
                                                                                UpdateHealerStatus("→ Healed Manual Pet " . index)
                                                                                Sleep, 25
                                                                            }
                                                                        }
                                                                    return
                                                                    DPSTargetedHealthCheck:
                                                                        ; Check DPS targeted player coordinates
                                                                        for index, coords in DPSTargetedPlayerCoords {
                                                                            checkX := coords.x
                                                                            checkY := coords.y

                                                                            ; Look for full health (green)
                                                                            healthFull := "|<>##0.90$0/0/24690C,0/1/00AA90,0/2/006655,0/3/3ED514"
                                                                            healthFound := FindText(0, 0, checkX-10, checkY-10, checkX+10, checkY+10, 0, 0, healthFull)

                                                                            if (!healthFound) {
                                                                                SendMessageClick(checkX, checkY)
                                                                                TryCastHealingSkill()
                                                                                Sleep, 25
                                                                            }
                                                                        }

                                                                        ; Check DPS targeted pet coordinates
                                                                        for index, coords in DPSTargetedPetCoords {
                                                                            checkX := coords.x
                                                                            checkY := coords.y

                                                                            ; Look for full health (green)
                                                                            healthFull := "|<>##0.90$0/0/24690C,0/1/00AA90,0/2/006655,0/3/3ED514"
                                                                            healthFound := FindText(0, 0, checkX-10, checkY-10, checkX+10, checkY+10, 0, 0, healthFull)

                                                                            if (!healthFound) {
                                                                                SendMessageClick(checkX, checkY)
                                                                                TryCastHealingSkill()
                                                                                Sleep, 25
                                                                            }
                                                                        }
                                                                    return

                                                                    LaunchGame:
                                                                        IniRead, outpath, %iniFile%, gamepath, path
                                                                        Run, %outpath%
                                                                    Return

                                                                    SelectGame:
                                                                        FileSelectFile, selectedGame, 3,, Select a game, Executables (*.exe)
                                                                        if (selectedGame != "") {
                                                                            MsgBox, You selected: %selectedGame%
                                                                            IniWrite, %selectedGame%, %iniFile%, gamepath, path
                                                                        }
                                                                    Return
                                                                    Characters:
                                                                        Gui, char:New
                                                                        Gui, char:Color, 444444
                                                                        Loop, 8 {
                                                                            IniRead, buttonName, %iniFile%, Character%A_Index%, username, Character %A_Index%
                                                                            y := (A_Index-1)*40 + 10
                                                                            Gui, char:Add, Button, x10 y%y% w100 h30 gChar%A_Index%, %buttonName%
                                                                            Gui, char:Add, Button, x120 y%y% w50 h30 gReset%A_Index%, Edit
                                                                        }
                                                                        Gui, char:Show, w180 h340, Characters
                                                                    return

                                                                    Reset1:
                                                                    Reset2:
                                                                    Reset3:
                                                                    Reset4:
                                                                    Reset5:
                                                                    Reset6:
                                                                    Reset7:
                                                                    Reset8:
                                                                        CurrentChar := SubStr(A_ThisLabel, 6)
                                                                        Gui, login:New
                                                                        Gui, login:+AlwaysOnTop
                                                                        Gui, login:Add, Text,, Username:
                                                                        Gui, login:Add, Edit, vNewUser w150
                                                                        Gui, login:Add, Text,, Password:
                                                                        Gui, login:Add, Edit, vNewPass Password w150
                                                                        Gui, login:Add, Button, gSaveLogin w60, Save
                                                                        Gui, login:Show,, Edit Character
                                                                    return

                                                                    SaveLogin:
                                                                        Gui, login:Submit
                                                                        IniWrite, %NewUser%, %iniFile%, Character%CurrentChar%, username
                                                                        IniWrite, %NewPass%, %iniFile%, Character%CurrentChar%, password
                                                                        Gui, login:Destroy
                                                                        Gui, char:Destroy
                                                                        Gosub, Characters
                                                                    return

                                                                    Char1:
                                                                    Char2:
                                                                    Char3:
                                                                    Char4:
                                                                    Char5:
                                                                    Char6:
                                                                    Char7:
                                                                    Char8:
                                                                        CurrentChar := SubStr(A_ThisLabel, 5)
                                                                        IniRead, username, %iniFile%, Character%CurrentChar%, username
                                                                        IniRead, password, %iniFile%, Character%CurrentChar%, password

                                                                        if (username = "ERROR" || password = "ERROR") {
                                                                            Gui, login:New
                                                                            Gui, login:+AlwaysOnTop
                                                                            Gui, login:Add, Text,, Username:
                                                                            Gui, login:Add, Edit, vNewUser w150
                                                                            Gui, login:Add, Text,, Password:
                                                                            Gui, login:Add, Edit, vNewPass Password w150
                                                                            Gui, login:Add, Button, gSaveLogin w60, Save
                                                                            Gui, login:Show,, Setup Character
                                                                        } else {
                                                                            KeyWait, LButton, D
                                                                            if (InStr(username, "!")) {
                                                                                SendInput, {!}
                                                                            }
                                                                            Sleep, 100
                                                                            SendInput %username%
                                                                            Sleep, 100
                                                                            SendInput {Tab}
                                                                            Sleep, 100
                                                                            SendInput %password%
                                                                            if (InStr(password, "!")) {
                                                                                SendInput, {!}
                                                                            }
                                                                            KeyWait, LButton
                                                                        }
                                                                    return
                                                                    passwordonly:
                                                                        CurrentChar := SubStr(A_ThisLabel, 5)
                                                                        IniRead, password, %iniFile%, Character%CurrentChar%, password

                                                                        if (password = "ERROR") {
                                                                            Gui, login:New
                                                                            Gui, login:+AlwaysOnTop
                                                                            Gui, login:Add, Text,, Password:
                                                                            Gui, login:Add, Edit, vNewPass Password w150
                                                                            Gui, login:Add, Button, gSaveLogin w60, Save
                                                                            Gui, login:Show,, Setup password
                                                                        } else {
                                                                            KeyWait, LButton, D
                                                                            Sleep, 100
                                                                            SendInput %password%
                                                                            if (InStr(password, "!")) {
                                                                                SendInput, {!}
                                                                            }
                                                                            KeyWait, LButton
                                                                        }
                                                                    return

                                                                    ; ========= WINDOW SETTINGS FUNCTIONS =========
                                                                    SaveGameWindowSettings() {
                                                                        global TargetGameWindow, TargetGameTitle, TargetGamePID, iniFile

                                                                        FileEncoding, UTF-8
                                                                        IniWrite, %TargetGameWindow%, %iniFile%, GameWindow, WindowID
                                                                        IniWrite, %TargetGameTitle%, %iniFile%, GameWindow, WindowTitle
                                                                        IniWrite, %TargetGamePID%, %iniFile%, GameWindow, WindowPID
                                                                        FileEncoding
                                                                    }

                                                                    LoadGameWindowSettings() {
                                                                        global TargetGameWindow, TargetGameTitle, TargetGamePID, iniFile, win1

                                                                        ; Check if window title "win2" exists first
                                                                        WinGet, win7ID, ID, win7
                                                                        if (win7ID) {
                                                                            TargetGameWindow := win7ID
                                                                            win1 := win7ID
                                                                            TargetGameTitle := "win7"
                                                                            WinGet, win7PID, PID, ahk_id %win7ID%
                                                                            TargetGamePID := win7PID
                                                                            FindText().BindWindow(win7ID)
                                                                            SetTimer, UpdateWindowDisplayDelayed, -200
                                                                            return
                                                                        }

                                                                        IniRead, loadedWindowID, %iniFile%, GameWindow, WindowID, 
                                                                        IniRead, loadedWindowTitle, %iniFile%, GameWindow, WindowTitle, 
                                                                        IniRead, loadedPID, %iniFile%, GameWindow, WindowPID,

                                                                        ; Check if we have a saved PID
                                                                        if (loadedPID != "" && loadedPID != "ERROR") {
                                                                            ; Try to find the window by PID
                                                                            WinGet, winIDFromPID, ID, ahk_pid %loadedPID%
                                                                            if (winIDFromPID) {
                                                                                ; Window with this PID still exists
                                                                                TargetGameWindow := winIDFromPID
                                                                                win1 := winIDFromPID
                                                                                TargetGamePID := loadedPID

                                                                                ; Get current window title (may have changed)
                                                                                WinGetTitle, currentTitle, ahk_id %winIDFromPID%
                                                                                TargetGameTitle := currentTitle

                                                                                ; Bind the window
                                                                                FindText().BindWindow(winIDFromPID)

                                                                                ; Show success message
                                                                                MsgBox, Previous client found and window has been re-selected!`nWindow: %currentTitle%

                                                                                ; Update display
                                                                                SetTimer, UpdateWindowDisplayDelayed, -200
                                                                                return
                                                                            }
                                                                        }

                                                                        ; Fallback: Try to use old WindowID method if PID not found
                                                                        if (loadedWindowID != "" && loadedWindowID != "ERROR") {
                                                                            TargetGameWindow := loadedWindowID
                                                                            win1 := loadedWindowID
                                                                            if (loadedWindowTitle != "" && loadedWindowTitle != "ERROR") {
                                                                                TargetGameTitle := loadedWindowTitle
                                                                            }
                                                                            ; Verify window still exists
                                                                            WinGet, testPID, PID, ahk_id %TargetGameWindow%
                                                                            if (ErrorLevel) {
                                                                                ; Window doesn't exist anymore, clear settings
                                                                                TargetGameWindow := ""
                                                                                TargetGameTitle := ""
                                                                                TargetGamePID := ""
                                                                                win1 := ""
                                                                            } else {
                                                                                ; Window exists, bind it
                                                                                FindText().BindWindow(TargetGameWindow)
                                                                            }
                                                                        }

                                                                        ; Update display after loading
                                                                        SetTimer, UpdateWindowDisplayDelayed, -200
                                                                    }

                                                                    UpdateWindowDisplayDelayed:
                                                                        UpdateWindowStatusDisplay()
                                                                    return

                                                                    UpdateWindowStatusDisplay() {
                                                                        global TargetGameTitle

                                                                        if (TargetGameTitle != "" && TargetGameTitle != "ERROR") {
                                                                            statusText := "Window: " . TargetGameTitle
                                                                            GuiControl,, WindowStatus, %statusText%
                                                                        } else {
                                                                            GuiControl,, WindowStatus, No window selected
                                                                        }
                                                                    }

                                                                    ; ========= PROFILE MANAGEMENT FUNCTIONS =========
                                                                    SaveProfile() {
                                                                        global CurrentProfileName, ProfileSettingsFile, SettingsFile
                                                                        global KeyCombination1, KeyDelay1, TimerInterval1
                                                                        global KeyCombination2, KeyDelay2, TimerInterval2
                                                                        global KeyCombination3, KeyDelay3, TimerInterval3
                                                                        global win1

                                                                        ; Get current values from GUI
                                                                        GuiControlGet, CurrentProfile,, CurrentProfile
                                                                        GuiControlGet, KeyCombination1,, KeyCombinationEdit1
                                                                        GuiControlGet, KeyDelay1,, KeyDelayEdit1
                                                                        GuiControlGet, TimerInterval1,, TimerIntervalEdit1
                                                                        GuiControlGet, KeyCombination2,, KeyCombinationEdit2
                                                                        GuiControlGet, KeyDelay2,, KeyDelayEdit2
                                                                        GuiControlGet, TimerInterval2,, TimerIntervalEdit2
                                                                        GuiControlGet, KeyCombination3,, KeyCombinationEdit3
                                                                        GuiControlGet, KeyDelay3,, KeyDelayEdit3
                                                                        GuiControlGet, TimerInterval3,, TimerIntervalEdit3

                                                                        if (CurrentProfile != "") {
                                                                            CurrentProfileName := CurrentProfile
                                                                        }

                                                                        ; Save profile-specific settings to ProfileSettingsFile
                                                                        FileEncoding, UTF-8
                                                                        IniWrite, %KeyCombination1%, %ProfileSettingsFile%, %CurrentProfileName%, KeyCombination1
                                                                        IniWrite, %KeyDelay1%, %ProfileSettingsFile%, %CurrentProfileName%, KeyDelay1
                                                                        IniWrite, %TimerInterval1%, %ProfileSettingsFile%, %CurrentProfileName%, TimerInterval1
                                                                        IniWrite, %KeyCombination2%, %ProfileSettingsFile%, %CurrentProfileName%, KeyCombination2
                                                                        IniWrite, %KeyDelay2%, %ProfileSettingsFile%, %CurrentProfileName%, KeyDelay2
                                                                        IniWrite, %TimerInterval2%, %ProfileSettingsFile%, %CurrentProfileName%, TimerInterval2
                                                                        IniWrite, %KeyCombination3%, %ProfileSettingsFile%, %CurrentProfileName%, KeyCombination3
                                                                        IniWrite, %KeyDelay3%, %ProfileSettingsFile%, %CurrentProfileName%, KeyDelay3
                                                                        IniWrite, %TimerInterval3%, %ProfileSettingsFile%, %CurrentProfileName%, TimerInterval3
                                                                        FileEncoding

                                                                        ; Also persist current keypresser settings to the general SettingsFile (merge behavior)
                                                                        FileEncoding, UTF-8
                                                                        IniWrite, %win1%, %SettingsFile%, Settings, win1

                                                                        IniWrite, %KeyCombination1%, %SettingsFile%, Sequence1, KeyCombination
                                                                        IniWrite, %KeyDelay1%, %SettingsFile%, Sequence1, KeyDelay
                                                                        IniWrite, %TimerInterval1%, %SettingsFile%, Sequence1, TimerInterval

                                                                        IniWrite, %KeyCombination2%, %SettingsFile%, Sequence2, KeyCombination
                                                                        IniWrite, %KeyDelay2%, %SettingsFile%, Sequence2, KeyDelay
                                                                        IniWrite, %TimerInterval2%, %SettingsFile%, Sequence2, TimerInterval

                                                                        IniWrite, %KeyCombination3%, %SettingsFile%, Sequence3, KeyCombination
                                                                        IniWrite, %KeyDelay3%, %SettingsFile%, Sequence3, KeyDelay
                                                                        IniWrite, %TimerInterval3%, %SettingsFile%, Sequence3, TimerInterval
                                                                        FileEncoding
                                                                        ;RefreshProfileDropdown()

                                                                        ; Notify user and update statuses
                                                                        MsgBox, 64, Success, Profile "%CurrentProfileName%" saved successfully!
                                                                        UpdateStatus1("Settings saved")
                                                                        UpdateStatus2("Settings saved")
                                                                        UpdateStatus3("Settings saved")

                                                                    }

                                                                    LoadProfile() {
                                                                        global CurrentProfileName, ProfileSettingsFile
                                                                        global KeyCombination1, KeyDelay1, TimerInterval1
                                                                        global KeyCombination2, KeyDelay2, TimerInterval2
                                                                        global KeyCombination3, KeyDelay3, TimerInterval3

                                                                        ; Get selected profile from GUI
                                                                        GuiControlGet, CurrentProfile,, CurrentProfile
                                                                        if (CurrentProfile != "") {
                                                                            CurrentProfileName := CurrentProfile
                                                                        }

                                                                        IniRead, KeyCombination1, %ProfileSettingsFile%, %CurrentProfileName%, KeyCombination1, %A_Space%
                                                                        IniRead, KeyDelay1, %ProfileSettingsFile%, %CurrentProfileName%, KeyDelay1, 0.1
                                                                        IniRead, TimerInterval1, %ProfileSettingsFile%, %CurrentProfileName%, TimerInterval1, 1
                                                                        IniRead, KeyCombination2, %ProfileSettingsFile%, %CurrentProfileName%, KeyCombination2, %A_Space%
                                                                        IniRead, KeyDelay2, %ProfileSettingsFile%, %CurrentProfileName%, KeyDelay2, 0.1
                                                                        IniRead, TimerInterval2, %ProfileSettingsFile%, %CurrentProfileName%, TimerInterval2, 2
                                                                        IniRead, KeyCombination3, %ProfileSettingsFile%, %CurrentProfileName%, KeyCombination3, %A_Space%
                                                                        IniRead, KeyDelay3, %ProfileSettingsFile%, %CurrentProfileName%, KeyDelay3, 0.1
                                                                        IniRead, TimerInterval3, %ProfileSettingsFile%, %CurrentProfileName%, TimerInterval3, 3

                                                                        ; Clean up ERROR values
                                                                        if (KeyCombination1 = "ERROR") 
                                                                            KeyCombination1 := ""
                                                                        if (KeyCombination2 = "ERROR") 
                                                                            KeyCombination2 := ""
                                                                        if (KeyCombination3 = "ERROR") 
                                                                            KeyCombination3 := ""

                                                                        ; Update GUI controls
                                                                        GuiControl,, KeyCombinationEdit1, %KeyCombination1%
                                                                        GuiControl,, KeyDelayEdit1, %KeyDelay1%
                                                                        GuiControl,, TimerIntervalEdit1, %TimerInterval1%
                                                                        GuiControl,, KeyCombinationEdit2, %KeyCombination2%
                                                                        GuiControl,, KeyDelayEdit2, %KeyDelay2%
                                                                        GuiControl,, TimerIntervalEdit2, %TimerInterval2%
                                                                        GuiControl,, KeyCombinationEdit3, %KeyCombination3%
                                                                        GuiControl,, KeyDelayEdit3, %KeyDelay3%
                                                                        GuiControl,, TimerIntervalEdit3, %TimerInterval3%

                                                                        ; Show which profile was actually loaded
                                                                        GuiControlGet, actualProfile,, CurrentProfile
                                                                        ;MsgBox, 64, Success, Profile "%actualProfile%" loaded successfully!
                                                                    }

                                                                    ProfileChanged() {
                                                                        ; Auto-load when profile is changed
                                                                        LoadProfile()
                                                                    }

                                                                    NewProfile() {
                                                                        ; Get profile name from input
                                                                        GuiControlGet, ProfileNameEdit,, ProfileNameEdit
                                                                        if (ProfileNameEdit != "") {
                                                                            CurrentProfileName := ProfileNameEdit
                                                                            ; Ensure a section exists and persist default/settings immediately
                                                                            FileEncoding, UTF-8
                                                                            ; use an explicit non-empty placeholder to avoid IniWrite parameter #1 being empty
                                                                            safeValue := " " ; single space (or use "default" / "0" if you prefer)
                                                                            IniWrite, %safeValue%, %ProfileSettingsFile%, %CurrentProfileName%, KeyCombination1
                                                                            FileEncoding
                                                                            ; Refresh dropdown and select new profile
                                                                            RefreshProfileDropdown()
                                                                            GuiControl,, ProfileNameEdit,
                                                                            ;MsgBox, 64, Success, New profile "%CurrentProfileName%" created and saved!
                                                                        } else {
                                                                            MsgBox, 48, Warning, Please enter a profile name first.
                                                                        }
                                                                    }

                                                                    RenameProfile() {
                                                                        global CurrentProfileName, ProfileSettingsFile

                                                                        ; Read current GUI selection and desired new name
                                                                        GuiControlGet, CurrentProfile,, CurrentProfile
                                                                        GuiControlGet, ProfileNameEdit,, ProfileNameEdit

                                                                        if (ProfileNameEdit = "" || CurrentProfile = "") {
                                                                            MsgBox, 48, Warning, Please select a profile and enter a new name.
                                                                            return
                                                                        }

                                                                        oldName := CurrentProfile
                                                                        newName := ProfileNameEdit

                                                                        ; Read all known keys from the old profile (safe defaults)
                                                                        IniRead, kc1, %ProfileSettingsFile%, %oldName%, KeyCombination1,
                                                                        IniRead, kd1, %ProfileSettingsFile%, %oldName%, KeyDelay1,
                                                                        IniRead, ti1, %ProfileSettingsFile%, %oldName%, TimerInterval1,

                                                                        IniRead, kc2, %ProfileSettingsFile%, %oldName%, KeyCombination2,
                                                                        IniRead, kd2, %ProfileSettingsFile%, %oldName%, KeyDelay2,
                                                                        IniRead, ti2, %ProfileSettingsFile%, %oldName%, TimerInterval2,

                                                                        IniRead, kc3, %ProfileSettingsFile%, %oldName%, KeyCombination3,
                                                                        IniRead, kd3, %ProfileSettingsFile%, %oldName%, KeyDelay3,
                                                                        IniRead, ti3, %ProfileSettingsFile%, %oldName%, TimerInterval3

                                                                        ; Write them under the new profile name
                                                                        FileEncoding, UTF-8
                                                                        IniWrite, %kc1%, %ProfileSettingsFile%, %newName%, KeyCombination1
                                                                        IniWrite, %kd1%, %ProfileSettingsFile%, %newName%, KeyDelay1
                                                                        IniWrite, %ti1%, %ProfileSettingsFile%, %newName%, TimerInterval1

                                                                        IniWrite, %kc2%, %ProfileSettingsFile%, %newName%, KeyCombination2
                                                                        IniWrite, %kd2%, %ProfileSettingsFile%, %newName%, KeyDelay2
                                                                        IniWrite, %ti2%, %ProfileSettingsFile%, %newName%, TimerInterval2

                                                                        IniWrite, %kc3%, %ProfileSettingsFile%, %newName%, KeyCombination3
                                                                        IniWrite, %kd3%, %ProfileSettingsFile%, %newName%, KeyDelay3
                                                                        IniWrite, %ti3%, %ProfileSettingsFile%, %newName%, TimerInterval3
                                                                        FileEncoding

                                                                        ; Remove the old profile section so it won't appear after reload
                                                                        IniDelete, %ProfileSettingsFile%, %oldName%

                                                                        ; Update runtime state
                                                                        CurrentProfileName := newName

                                                                        ; Refresh dropdown and select the renamed profile
                                                                        RefreshProfileDropdown()
                                                                        MsgBox, 64, Success, Profile renamed from "%oldName%" to "%newName%"!
                                                                    }

                                                                    DeleteProfile() {
                                                                        global CurrentProfileName, ProfileSettingsFile

                                                                        ; Get selected profile from GUI
                                                                        GuiControlGet, CurrentProfile,, CurrentProfile

                                                                        if (CurrentProfile != "") {
                                                                            MsgBox, 4, Confirm Delete, Are you sure you want to delete the "%CurrentProfile%" profile?
                                                                            IfMsgBox Yes
                                                                            {
                                                                                ; Delete the profile section
                                                                                IniDelete, %ProfileSettingsFile%, %CurrentProfile%

                                                                                ; Reset to default profile variable
                                                                                CurrentProfileName := ""
                                                                                ; Refresh dropdown so deleted profile disappears
                                                                                RefreshProfileDropdown()
                                                                                ; select farming if present
                                                                                GuiControl, Choose, CurrentProfile, 1

                                                                                LoadProfile()

                                                                                MsgBox, 64, Success, Profile "%CurrentProfile%" deleted successfully!
                                                                            }
                                                                        } else {
                                                                            MsgBox, 48, Warning, Please select a profile to delete.
                                                                        }
                                                                    }

                                                                    ; Build the dropdown options from the ProfileSettingsFile sections

                                                                    RefreshProfileDropdown() {
                                                                        global ProfileSettingsFile, CurrentProfileName

                                                                        profiles := [] ; final unique ordered list
                                                                        seen := {} ; dedupe map

                                                                        if FileExist(ProfileSettingsFile) {
                                                                            FileRead, iniText, %ProfileSettingsFile%
                                                                            Loop, Parse, iniText, `n, `r
                                                                            {
                                                                                line := A_LoopField
                                                                                if RegExMatch(line, "^\s*\[\s*(.+?)\s*\]\s*$", m) {
                                                                                    name := Trim(m1)
                                                                                    if (name != "" && !seen.HasKey(name)) {
                                                                                        seen[name] := true
                                                                                        profiles.Push(name)
                                                                                    }
                                                                                }
                                                                            }
                                                                        }

                                                                        ; Ensure at least "Farming" exists and prefer it as the first item
                                                                        if (!seen.HasKey("Default")) {
                                                                            profiles.InsertAt(1, "Default")
                                                                            seen["Default"] := true
                                                                        } else {
                                                                            ; move existing "Farming" to first position for consistency
                                                                            for i, nm in profiles {
                                                                                if (nm = "Default") {
                                                                                    profiles.RemoveAt(i)
                                                                                    profiles.InsertAt(1, "Default")
                                                                                    break
                                                                                }
                                                                            }
                                                                        }

                                                                        ; Build pipe-delimited list string
                                                                        list := ""
                                                                        for index, name in profiles {
                                                                            if (index > 1)
                                                                                list .= "|"
                                                                            list .= name
                                                                        }

                                                                        ; Clear the dropdown first (prevents appending / duplicates), then set full list
                                                                        GuiControl,, CurrentProfile, |
                                                                        Sleep, 10
                                                                        GuiControl,, CurrentProfile, %list%

                                                                        ; Preserve or reselect current profile if present
                                                                        selIndex := 1
                                                                        for index, name in profiles {
                                                                            if (name = CurrentProfileName) {
                                                                                selIndex := index
                                                                                break
                                                                            }
                                                                        }
                                                                        GuiControl, Choose, CurrentProfile, %selIndex%
                                                                    }

                                                                    LoadDefaultProfile() {
                                                                        global CurrentProfileName, ProfileSettingsFile
                                                                        global KeyCombination1, KeyDelay1, TimerInterval1
                                                                        global KeyCombination2, KeyDelay2, TimerInterval2
                                                                        global KeyCombination3, KeyDelay3, TimerInterval3

                                                                        ; Try to load the farming profile first
                                                                        IniRead, KeyCombination1, %ProfileSettingsFile%, Farming, KeyCombination1, %A_Space%
                                                                        IniRead, KeyDelay1, %ProfileSettingsFile%, Farming, KeyDelay1, 0.1
                                                                        IniRead, TimerInterval1, %ProfileSettingsFile%, Farming, TimerInterval1, 1
                                                                        IniRead, KeyCombination2, %ProfileSettingsFile%, Farming, KeyCombination2, %A_Space%
                                                                        IniRead, KeyDelay2, %ProfileSettingsFile%, Farming, KeyDelay2, 0.1
                                                                        IniRead, TimerInterval2, %ProfileSettingsFile%, Farming, TimerInterval2, 2
                                                                        IniRead, KeyCombination3, %ProfileSettingsFile%, Farming, KeyCombination3, %A_Space%
                                                                        IniRead, KeyDelay3, %ProfileSettingsFile%, Farming, KeyDelay3, 0.1
                                                                        IniRead, TimerInterval3, %ProfileSettingsFile%, Farming, TimerInterval3, 3

                                                                        ; Clean up ERROR values
                                                                        if (KeyCombination1 = "ERROR") 
                                                                            KeyCombination1 := ""
                                                                        if (KeyCombination2 = "ERROR") 
                                                                            KeyCombination2 := ""
                                                                        if (KeyCombination3 = "ERROR") 
                                                                            KeyCombination3 := ""
                                                                    }
                                                                    DPSHoldHotkey:
                                                                        ; Save new hotkey from control and persist
                                                                        GuiControlGet, DPSHoldHotkey,, DPSHoldHotkey

                                                                        ; Turn off old hotkey if it exists
                                                                        if (OldDPSHoldHotkey != "") {
                                                                            Hotkey, %OldDPSHoldHotkey%, Off
                                                                        }

                                                                        ; normalize empty -> clear
                                                                        if (DPSHoldHotkey = "") {
                                                                            IniDelete, %SettingsFile%, Settings, DPSHoldHotkey
                                                                            MsgBox, 64, Saved, DPS hold-hotkey cleared.
                                                                            OldDPSHoldHotkey := ""
                                                                            return
                                                                        }

                                                                        ; persist
                                                                        FileEncoding, UTF-8
                                                                        IniWrite, %DPSHoldHotkey%, %SettingsFile%, Settings, DPSHoldHotkey
                                                                        FileEncoding

                                                                        ; Register the new hotkey
                                                                        try {
                                                                            Hotkey, %DPSHoldHotkey%, DPSHotkeyAction, On
                                                                            OldDPSHoldHotkey := DPSHoldHotkey
                                                                            MsgBox, 64, Saved, DPS hold-hotkey set to "%DPSHoldHotkey%". Hold it to loop DPS + DynamicHealthCheck.
                                                                        } catch {
                                                                            MsgBox, 16, Error, Invalid hotkey: %DPSHoldHotkey%
                                                                        }
                                                                    return

                                                                    DPSHotkeyAction:
                                                                        ; This runs while the key is held
                                                                        if (!isSystemBusy) {
                                                                            isSystemBusy := true
                                                                            TryCastCCSkills()
                                                                            TryCastDPSSkills()
                                                                            gosub, DynamicHealthCheck
                                                                            isSystemBusy := false
                                                                        }
                                                                    return

                                                                    DPSToggleHotkeyChanged:
                                                                        ; Save new DPS toggle hotkey from control and persist
                                                                        GuiControlGet, newDPSToggleKey,, DPSToggleHotkey

                                                                        ; Turn off old hotkey if it exists
                                                                        if (DPSToggleHotkey != "") {
                                                                            hotkey, %DPSToggleHotkey%, Off, UseErrorLevel
                                                                        }

                                                                        ; Update the variable
                                                                        DPSToggleHotkey := newDPSToggleKey

                                                                        ; If empty, clear hotkey
                                                                        if (DPSToggleHotkey = "") {
                                                                            IniDelete, %SettingsFile%, Settings, DPSToggleHotkey
                                                                            MsgBox, 64, Saved, DPS toggle hotkey cleared.
                                                                            return
                                                                        }

                                                                        ; Persist to INI
                                                                        FileEncoding, UTF-8
                                                                        IniWrite, %DPSToggleHotkey%, %SettingsFile%, Settings, DPSToggleHotkey
                                                                        FileEncoding

                                                                        ; Enable new hotkey
                                                                        hotkey, %DPSToggleHotkey%, ToggleDPSAction, On, UseErrorLevel
                                                                        if (ErrorLevel) {
                                                                            MsgBox, 16, Invalid Hotkey, The hotkey "%DPSToggleHotkey%" is invalid or already in use.
                                                                        } else {
                                                                            MsgBox, 64, Saved, DPS toggle hotkey set to: %DPSToggleHotkey%
                                                                        }
                                                                    return

                                                                    ToggleDPSAction:
                                                                        ; Toggle DPS on/off when hotkey is pressed
                                                                        if (isDpsRunning) {
                                                                            gosub, StopDPSScript
                                                                        } else {
                                                                            gosub, StartDPSScript
                                                                        }
                                                                    return

                                                                    autofollowhotkey:
                                                                        ; Save new hotkey from control and persist
                                                                        GuiControlGet, newAutoFollowKey,, autofollowhotkey

                                                                        ; Turn off old hotkey if it exists
                                                                        if (autofollowhotkey != "") {
                                                                            hotkey, %autofollowhotkey%, Off, UseErrorLevel
                                                                        }

                                                                        ; Update the variable
                                                                        autofollowhotkey := newAutoFollowKey

                                                                        ; normalize empty -> clear timer
                                                                        if (autofollowhotkey = "") {
                                                                            IniDelete, %SettingsFile%, Settings, autofollowhotkey
                                                                            SetTimer, autofollowhotkeyWorker, Off
                                                                            MsgBox, 64, Saved, auto follow hotkey cleared.
                                                                            return
                                                                        }
                                                                        ; persist
                                                                        FileEncoding, UTF-8
                                                                        IniWrite, %autofollowhotkey%, %SettingsFile%, Settings, autofollowhotkey
                                                                        FileEncoding
                                                                        ; ensure timer interval has a safe default
                                                                        if (autofollowhotkeyTimerInterval = "" || autofollowhotkeyTimerInterval <= 0)
                                                                            autofollowhotkeyTimerInterval := 50
                                                                        ; start timer to watch the key
                                                                        SetTimer, autofollowhotkeyWorker, %autofollowhotkeyTimerInterval%
                                                                    MsgBox, 64, Saved, auto follow hotkey set to "%autofollowhotkey%". press to return to main character.
                                                                    return
                                                                    autofollowhotkeyWorker:
                                                                        ; Poll the hotkey; when pressed, run return to main character
                                                                        Gui, Submit, NoHide
                                                                        if (autofollowhotkey = "") {
                                                                            SetTimer, autofollowhotkeyWorker, Off
                                                                            return
                                                                        }

                                                                        key := autofollowhotkey

                                                                        ; Normalize for parsing
                                                                        ; Accept forms like "Ctrl+F1", "Alt+X", "A" (keyboard) or "A" / "LB" / "DPAD_UP" / "Joy1" for Xbox buttons
                                                                        hasCtrl := InStr(key, "Ctrl") || InStr(key, "^")
                                                                        hasAlt := InStr(key, "Alt") || InStr(key, "!")
                                                                        hasShift:= InStr(key, "Shift")|| InStr(key, "+")
                                                                        baseKey := key

                                                                        ; Remove common modifier tokens (case-insensitive)
                                                                        baseKey := RegExReplace(baseKey, "(?i)\b(ctrl|alt|shift)\b\+?", "")
                                                                        baseKey := StrReplace(baseKey, "^", "")
                                                                        baseKey := StrReplace(baseKey, "!", "")
                                                                        baseKey := StrReplace(baseKey, "+", "")
                                                                        baseKey := Trim(baseKey)

                                                                        ; Prepare Xbox mapping
                                                                        xboxMap := {}
                                                                        xboxMap["A"] := "Joy1"
                                                                        xboxMap["B"] := "Joy2"
                                                                        xboxMap["X"] := "Joy3"
                                                                        xboxMap["Y"] := "Joy4"
                                                                        xboxMap["LB"] := "Joy5"
                                                                        xboxMap["RB"] := "Joy6"
                                                                        xboxMap["BACK"] := "Joy7"
                                                                        xboxMap["START"] := "Joy8"
                                                                        xboxMap["LS"] := "Joy9"
                                                                        xboxMap["RS"] := "Joy10"
                                                                        xboxMap["DPADUP"] := "Joy11"
                                                                        xboxMap["DPADDOWN"] := "Joy12"
                                                                        xboxMap["DPADLEFT"] := "Joy13"
                                                                        xboxMap["DPADRIGHT"] := "Joy14"
                                                                        xboxMap["LT"] := "Joy15"
                                                                        xboxMap["RT"] := "Joy16"

                                                                        isGamepad := false
                                                                        mappedJoy := ""

                                                                        ; If user supplied "JoyN" directly (e.g. Joy1) accept that
                                                                        if RegExMatch(baseKey, "(?i)^\s*Joy\s*([0-9]{1,2})\s*$", m) {
                                                                            mappedJoy := "Joy" . m1
                                                                            isGamepad := true
                                                                        } else {
                                                                            ; Normalize for lookup: remove non-alphanum and uppercase
                                                                            lookupKey := RegExReplace(baseKey, "[^A-Za-z0-9]", "")
                                                                            StringUpper, lookupKey, lookupKey
                                                                            if (lookupKey != "" && xboxMap.HasKey(lookupKey)) {
                                                                                isGamepad := true
                                                                                mappedJoy := xboxMap[lookupKey]
                                                                            } else {
                                                                                isGamepad := false
                                                                            }
                                                                        } 
                                                                        ; Check key state depending on type
                                                                        isDown := true 
                                                                        ; if there is no base key and not a recognized gamepad mapping, treat as not pressed
                                                                        if (baseKey = "" && !isGamepad) {
                                                                            isDown := false
                                                                        }
                                                                        if (hasCtrl && !GetKeyState("Ctrl", "P"))
                                                                            isDown := false
                                                                        if (hasAlt && !GetKeyState("Alt", "P"))
                                                                            isDown := false
                                                                        if (hasShift && !GetKeyState("Shift", "P"))
                                                                            isDown := false 
                                                                        if (isGamepad) {
                                                                            ; Try multiple variations to detect joystick button reliably:
                                                                            ; - GetKeyState(mappedJoy, "P")
                                                                            ; - GetKeyState(mappedJoy) (non-physical)
                                                                            ; - If mappedJoy is "JoyN", also try numeric forms
                                                                            joyDetected := false
                                                                            if (mappedJoy != "") {
                                                                                if (GetKeyState(mappedJoy, "P") || GetKeyState(mappedJoy))
                                                                                    joyDetected := true
                                                                                else if RegExMatch(mappedJoy, "^Joy(\d+)$", jm) {
                                                                                    jnum := jm1
                                                                                    if (GetKeyState("Joy" . jnum, "P") || GetKeyState("Joy" . jnum))
                                                                                        joyDetected := true
                                                                                }
                                                                            }
                                                                            if (!joyDetected)
                                                                                isDown := false
                                                                        } else {
                                                                            ; Regular keyboard key - try both physical and non-physical checks for common keys
                                                                            if (!(GetKeyState(baseKey, "P") || GetKeyState(baseKey)))
                                                                                isDown := false
                                                                        }
                                                                        if (isDown) {
                                                                            ; When pressed: run return to main character
                                                                            ; Avoid reentrancy using isSystemBusy
                                                                            if (!isSystemBusy) {
                                                                                isSystemBusy := true
                                                                                ReturnToMainCharacter()
                                                                                isSystemBusy := false
                                                                            }
                                                                        }
                                                                    return

                                                                    AutoFollowAction: 
                                                                        ReturnToMainCharacter()
                                                                    return
                                                                    ; ========== END PROFILE MANAGEMENT FUNCTIONS ==========
                                                                    ; ========== CROWD CONTROL COOLDOWN HANDLING ==========

                                                                    CCCooldownEnd:
                                                                        ccOnCooldown := false
                                                                        SetTimer, CCCooldownEnd, Off
                                                                    return

                                                                    ; ========= Navigation Functions =========
                                                                    return
                                                                    InitializeNavigation() {
                                                                        CheckNavPreviousSettings()
                                                                        LoadNavWaypoints()
                                                                        LoadDPSNavSettings()
                                                                        SetTimer, UpdateNavCoordinatesDisplay, 500
                                                                    }

                                                                    CheckNavPreviousSettings() {
                                                                        global usePreviousSettings := false ; Track user's choice
                                                                        IniRead, savedPID, navpathingsettings.ini, Settings, WindowPID, ERROR
                                                                        IniRead, savedCameraFile, navpathingsettings.ini, Settings, CameraFile, ERROR

                                                                        if (savedPID != "ERROR" && savedCameraFile != "ERROR") {
                                                                            WinGet, winID, ID, ahk_pid %savedPID%
                                                                            if (winID) {
                                                                                WinGetTitle, winTitle, ahk_id %winID%
                                                                                MsgBox, 4,, Use previous navigation settings?`nWindow: %winTitle% (PID: %savedPID%)`nCamera File: %savedCameraFile%
                                                                                IfMsgBox Yes
                                                                                {
                                                                                    NavTargetGameWindow := winID
                                                                                    NavTargetGamePID := savedPID
                                                                                    NavCameraFile := savedCameraFile
                                                                                    FindText().BindWindow(winID)
                                                                                    LoadNavCameraSettings(savedCameraFile)
                                                                                    GuiControl,, NavRadiusEdit, %NavCameraRadius%
                                                                                    GuiControl,, NavCameraFile, Camera: %savedCameraFile%
                                                                                    usePreviousSettings := true
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    LoadNavWaypoints() {
                                                                        if (!NavSelectedRouteFile || !FileExist(NavSelectedRouteFile)) {
                                                                            return
                                                                        }

                                                                        NavWaypoints := []
                                                                        NavWaypointCount := 0

                                                                        ; Try new format first (Waypoints section with X1, Y1, etc.)
                                                                        IniRead, waypointCount, %NavSelectedRouteFile%, Waypoints, Count, 0
                                                                        if (waypointCount > 0) {
                                                                            Loop, %waypointCount% {
                                                                                IniRead, x, %NavSelectedRouteFile%, Waypoints, X%A_Index%, ERROR
                                                                                IniRead, y, %NavSelectedRouteFile%, Waypoints, Y%A_Index%, ERROR
                                                                                if (x != "ERROR" && y != "ERROR") {
                                                                                    NavWaypointCount++
                                                                                    NavWaypoints[NavWaypointCount] := {x: x, y: y}
                                                                                }
                                                                            }
                                                                        } else {
                                                                            ; Try old format (Waypoint1, Waypoint2, etc. sections)
                                                                            i := 1
                                                                            Loop {
                                                                                IniRead, x, %NavSelectedRouteFile%, Waypoint%i%, X, ERROR
                                                                                IniRead, y, %NavSelectedRouteFile%, Waypoint%i%, Y, ERROR
                                                                                if (x = "ERROR" || y = "ERROR") {
                                                                                    break
                                                                                }
                                                                                NavWaypointCount++
                                                                                NavWaypoints[NavWaypointCount] := {x: x, y: y}
                                                                                i++
                                                                            }
                                                                        }
                                                                    }

                                                                    SaveNavSettings() {
                                                                        if (NavTargetGamePID && NavCameraFile) {
                                                                            IniWrite, %NavTargetGamePID%, navpathingsettings.ini, Settings, WindowPID
                                                                            IniWrite, %NavCameraFile%, navpathingsettings.ini, Settings, CameraFile
                                                                        }
                                                                    }

                                                                    LoadCameraFilesAtStartup() {
                                                                        ; Check for any saved camera files
                                                                        IniRead, savedNavCameraFile, navpathingsettings.ini, Settings, CameraFile, ERROR
                                                                        IniRead, savedMainCameraFile, pathingsettings.ini, Settings, CameraFile, ERROR

                                                                        ; Determine which camera file to offer
                                                                        cameraFileToOffer := ""
                                                                        cameraFileSource := ""

                                                                        if (savedNavCameraFile != "ERROR" && FileExist(savedNavCameraFile)) {
                                                                            cameraFileToOffer := savedNavCameraFile
                                                                            cameraFileSource := "Navigation"
                                                                        }
                                                                        else if (savedMainCameraFile != "ERROR" && FileExist(savedMainCameraFile)) {
                                                                            cameraFileToOffer := savedMainCameraFile
                                                                            cameraFileSource := "Main"
                                                                        }

                                                                        ; If we have a camera file to offer, prompt user
                                                                        if (cameraFileToOffer != "") {
                                                                            SplitPath, cameraFileToOffer, fileName
                                                                            MsgBox, 3, Camera File Setup, Previous %cameraFileSource% camera file found:`n%fileName%`n`nYes = Use this file`nNo = Select different file`nCancel = No camera file
                                                                            IfMsgBox Yes
                                                                            {
                                                                                ; Use the saved camera file
                                                                                LoadSavedCameraFile(cameraFileToOffer)
                                                                            }
                                                                            else IfMsgBox No
                                                                            {
                                                                                ; Let user select a different camera file
                                                                                FileSelectFile, newCameraFile, 1,, Select Camera File, TXT Files (*.txt)
                                                                                if (newCameraFile != "") {
                                                                                    LoadSavedCameraFile(newCameraFile)
                                                                                }
                                                                            }
                                                                            ; Cancel = do nothing, no camera file loaded
                                                                        }
                                                                        ; If no saved camera files found, don't prompt (user can set up later)
                                                                    }

                                                                    LoadSavedCameraFile(filePath) {
                                                                        ; Set up navigation camera
                                                                        NavCameraFile := filePath
                                                                        LoadNavCameraSettings(NavCameraFile)
                                                                        GuiControl,, NavCameraFile, Camera: %NavCameraFile%
                                                                        GuiControl,, NavRadiusEdit, %NavCameraRadius%

                                                                        ; Set up main camera  
                                                                        CameraFile := filePath
                                                                        LoadCameraSettings(navCameraFile)

                                                                        ; Save to both INI files
                                                                        SaveNavSettings()
                                                                        SaveSettings()

                                                                        SplitPath, filePath, fileName
                                                                        ToolTip, Camera file loaded: %fileName%, 0, 0
                                                                        SetTimer, RemoveCameraToolTip, 3000
                                                                    }

                                                                    RemoveCameraToolTip:
                                                                        ToolTip
                                                                        SetTimer, RemoveCameraToolTip, Off
                                                                    return
                                                                    return
                                                                    UpdateNavCoordinatesDisplay:
                                                                        if (NavTargetGameWindow) {
                                                                            GetNavCurrentCoordinates(coordX, coordY)
                                                                            if (coordX != "" && coordY != "") {
                                                                                GuiControl,, NavCurrentCoords, Current: X: %coordX% Y: %coordY%
                                                                            } else {
                                                                                GuiControl,, NavCurrentCoords, Current: X: --- Y: ---
                                                                            }
                                                                        } else {
                                                                            GuiControl,, NavCurrentCoords, Current: X: --- Y: ---
                                                                        }
                                                                    return

                                                                    ; Check and execute pending timer actions at waypoints
                                                                    CheckAndExecuteTimerFlags() {
                                                                        global gnollBuffNeeded, dtBuffNeeded, sequence1Needed, sequence2Needed, sequence3Needed
                                                                        global potionDestroyNeeded, duraRepairNeeded

                                                                        ; Debug: Show current flag status
                                                                        flagStatus := "Timer Flags: "
                                                                        flagStatus .= "Gnoll:" . gnollBuffNeeded . " "
                                                                        flagStatus .= "DT:" . dtBuffNeeded . " "
                                                                        flagStatus .= "Seq1:" . sequence1Needed . " "
                                                                        flagStatus .= "Seq2:" . sequence2Needed . " "
                                                                        flagStatus .= "Seq3:" . sequence3Needed . " "
                                                                        flagStatus .= "Pot:" . potionDestroyNeeded . " "
                                                                        flagStatus .= "Dur:" . duraRepairNeeded
                                                                        ToolTip, %flagStatus%, 10, 10, 7
                                                                        SetTimer, RemoveFlagDebug, -5000

                                                                        ; Check and execute gnoll buff if needed
                                                                        if (gnollBuffNeeded) {
                                                                            gnollBuffNeeded := false
                                                                            gnoll(true)
                                                                            sleep, 5000
                                                                        }

                                                                        ; Check and execute Death Tyrant buff if needed
                                                                        if (dtBuffNeeded) {
                                                                            dtBuffNeeded := false
                                                                            DeathTyrant(true)
                                                                            sleep, 5000
                                                                        }

                                                                        ; Check and execute sequences if needed
                                                                        if (sequence1Needed) {
                                                                            sequence1Needed := false
                                                                            ; Execute sequence 1 directly without navigation checks
                                                                            ExecuteSequence1(true)
                                                                        }

                                                                        if (sequence2Needed) {
                                                                            sequence2Needed := false
                                                                            ; Execute sequence 2 directly without navigation checks
                                                                            ExecuteSequence2(true)
                                                                        }

                                                                        if (sequence3Needed) {
                                                                            sequence3Needed := false
                                                                            ; Execute sequence 3 directly without navigation checks
                                                                            ExecuteSequence3(true)
                                                                        }

                                                                        ; Check and execute potion destroy if needed
                                                                        if (potionDestroyNeeded) {
                                                                            potionDestroyNeeded := false
                                                                            DestroySkyPotions(true)

                                                                        }

                                                                        ; Check and execute dura repair if needed
                                                                        if (duraRepairNeeded) {
                                                                            duraRepairNeeded := false
                                                                            PerformDuraRepair(true)

                                                                        }
                                                                    }

                                                                    RemoveFlagDebug:
                                                                        ToolTip, , , , 7
                                                                    return

                                                                    RemoveSignalDebug:
                                                                        ToolTip, , , , 9
                                                                    return

                                                                    RemoveNavDebug:
                                                                        ToolTip, , , , 10
                                                                    return

                                                                    ; Execute sequence functions without navigation checks (for waypoint execution)
                                                                    ExecuteSequence1(force := false) {
                                                                        global KeySequence1, KeyDelay1, win1, isSystemBusy

                                                                        ; Check if Critical mode is enabled - pause until disabled
                                                                        if (CriticalModeEnabled) {
                                                                            return false
                                                                        }

                                                                        ; If navigation is running, set flag instead of executing, unless forced
                                                                        if ((NavIsTraveling || IsTraveling) && !force) {
                                                                            sequence1Needed := true
                                                                            return false
                                                                        }

                                                                        ; Set system busy for buff sequence
                                                                        ;isSystemBusy := true

                                                                        ; Pause navigation during sequence execution
                                                                        PauseNavigationForBuff()

                                                                        Loop % KeySequence1.Length()
                                                                        {
                                                                            CurrentKey := KeySequence1[A_Index]
                                                                            if (CurrentKey != "") {
                                                                                ; Execute the key sequence (copy logic from SendKeys1)
                                                                                hasCtrl := InStr(CurrentKey, "^")
                                                                                hasAlt := InStr(CurrentKey, "!")
                                                                                hasShift := InStr(CurrentKey, "+")

                                                                                baseKey := CurrentKey
                                                                                if (hasCtrl)
                                                                                    baseKey := StrReplace(baseKey, "^", "")
                                                                                if (hasAlt)
                                                                                    baseKey := StrReplace(baseKey, "!", "")
                                                                                if (hasShift)
                                                                                    baseKey := StrReplace(baseKey, "+", "")

                                                                                baseKey := ConvertQwertyToQwertz(baseKey)

                                                                                if (hasCtrl)
                                                                                    ControlSend, , {Ctrl down}, ahk_id %win1%
                                                                                if (hasAlt)
                                                                                    ControlSend, , {Alt down}, ahk_id %win1%
                                                                                if (hasShift)
                                                                                    ControlSend, , {Shift down}, ahk_id %win1%

                                                                                ControlSend, , {%baseKey% down}, ahk_id %win1%
                                                                                Sleep, 50
                                                                                ControlSend, , {%baseKey% up}, ahk_id %win1%

                                                                                if (hasShift)
                                                                                    ControlSend, , {Shift up}, ahk_id %win1%
                                                                                if (hasAlt)
                                                                                    ControlSend, , {Alt up}, ahk_id %win1%
                                                                                if (hasCtrl)
                                                                                    ControlSend, , {Ctrl up}, ahk_id %win1%

                                                                                if (KeyDelay1 > 0 && A_Index < KeySequence1.Length()) {
                                                                                    DelayMS1 := KeyDelay1 * 1000
                                                                                    Sleep, %DelayMS1%
                                                                                }
                                                                            }
                                                                        }
                                                                        Sleep, 2000 
                                                                        NextExecutionTime1 := A_TickCount + (TimerInterval1 * 60 * 1000)

                                                                        ; Resume navigation after sequence execution
                                                                        ResumeNavigationAfterBuff()

                                                                        ; Release system busy flag
                                                                        isSystemBusy := false
                                                                    }

                                                                    ExecuteSequence2(force := false) {
                                                                        global KeySequence2, KeyDelay2, win1, isSystemBusy

                                                                        if (CriticalModeEnabled) {
                                                                            return false
                                                                        }

                                                                        ; If navigation is running, set flag instead of executing, unless forced
                                                                        if ((NavIsTraveling || IsTraveling) && !force) {
                                                                            sequence2Needed := true
                                                                            return false
                                                                        }

                                                                        isSystemBusy := true
                                                                        PauseNavigationForBuff()

                                                                        Loop % KeySequence2.Length()
                                                                        {
                                                                            CurrentKey := KeySequence2[A_Index]
                                                                            if (CurrentKey != "") {
                                                                                hasCtrl := InStr(CurrentKey, "^")
                                                                                hasAlt := InStr(CurrentKey, "!")
                                                                                hasShift := InStr(CurrentKey, "+")

                                                                                baseKey := CurrentKey
                                                                                if (hasCtrl)
                                                                                    baseKey := StrReplace(baseKey, "^", "")
                                                                                if (hasAlt)
                                                                                    baseKey := StrReplace(baseKey, "!", "")
                                                                                if (hasShift)
                                                                                    baseKey := StrReplace(baseKey, "+", "")

                                                                                baseKey := ConvertQwertyToQwertz(baseKey)

                                                                                if (hasCtrl)
                                                                                    ControlSend, , {Ctrl down}, ahk_id %win1%
                                                                                if (hasAlt)
                                                                                    ControlSend, , {Alt down}, ahk_id %win1%
                                                                                if (hasShift)
                                                                                    ControlSend, , {Shift down}, ahk_id %win1%

                                                                                ControlSend, , {%baseKey% down}, ahk_id %win1%
                                                                                Sleep, 50
                                                                                ControlSend, , {%baseKey% up}, ahk_id %win1%

                                                                                if (hasShift)
                                                                                    ControlSend, , {Shift up}, ahk_id %win1%
                                                                                if (hasAlt)
                                                                                    ControlSend, , {Alt up}, ahk_id %win1%
                                                                                if (hasCtrl)
                                                                                    ControlSend, , {Ctrl up}, ahk_id %win1%

                                                                                if (KeyDelay2 > 0 && A_Index < KeySequence2.Length()) {
                                                                                    DelayMS2 := KeyDelay2 * 1000
                                                                                    Sleep, %DelayMS2%
                                                                                }
                                                                            }
                                                                        }
                                                                        Sleep, 2000 
                                                                        NextExecutionTime2 := A_TickCount + (TimerInterval2 * 60 * 1000)

                                                                        ResumeNavigationAfterBuff()
                                                                        isSystemBusy := false
                                                                    }

                                                                    ExecuteSequence3(force := false) {
                                                                        global KeySequence3, KeyDelay3, win1, isSystemBusy

                                                                        if (CriticalModeEnabled) {
                                                                            return false
                                                                        }

                                                                        ; If navigation is running, set flag instead of executing, unless forced
                                                                        if ((NavIsTraveling || IsTraveling) && !force) {
                                                                            sequence3Needed := true
                                                                            return false
                                                                        }

                                                                        isSystemBusy := true
                                                                        PauseNavigationForBuff()

                                                                        Loop % KeySequence3.Length()
                                                                        {
                                                                            CurrentKey := KeySequence3[A_Index]
                                                                            if (CurrentKey != "") {
                                                                                hasCtrl := InStr(CurrentKey, "^")
                                                                                hasAlt := InStr(CurrentKey, "!")
                                                                                hasShift := InStr(CurrentKey, "+")

                                                                                baseKey := CurrentKey
                                                                                if (hasCtrl)
                                                                                    baseKey := StrReplace(baseKey, "^", "")
                                                                                if (hasAlt)
                                                                                    baseKey := StrReplace(baseKey, "!", "")
                                                                                if (hasShift)
                                                                                    baseKey := StrReplace(baseKey, "+", "")

                                                                                baseKey := ConvertQwertyToQwertz(baseKey)

                                                                                if (hasCtrl)
                                                                                    ControlSend, , {Ctrl down}, ahk_id %win1%
                                                                                if (hasAlt)
                                                                                    ControlSend, , {Alt down}, ahk_id %win1%
                                                                                if (hasShift)
                                                                                    ControlSend, , {Shift down}, ahk_id %win1%

                                                                                ControlSend, , {%baseKey% down}, ahk_id %win1%
                                                                                Sleep, 50
                                                                                ControlSend, , {%baseKey% up}, ahk_id %win1%

                                                                                if (hasShift)
                                                                                    ControlSend, , {Shift up}, ahk_id %win1%
                                                                                if (hasAlt)
                                                                                    ControlSend, , {Alt up}, ahk_id %win1%
                                                                                if (hasCtrl)
                                                                                    ControlSend, , {Ctrl up}, ahk_id %win1%

                                                                                if (KeyDelay3 > 0 && A_Index < KeySequence3.Length()) {
                                                                                    DelayMS3 := KeyDelay3 * 1000
                                                                                    Sleep, %DelayMS3%
                                                                                }
                                                                            }
                                                                        }
                                                                        Sleep, 2000 
                                                                        isSystemBusy := false

                                                                        NextExecutionTime3 := A_TickCount + (TimerInterval3 * 60 * 1000)
                                                                        UpdateStatus3("Buffs executed - yielding to DPS/Heal")
                                                                        if (NavigationPausedForBuff) {
                                                                            ResumeNavigationAfterBuff()
                                                                        }
                                                                    }
                                                                    SetSequence1Flag:
                                                                        sequence1Needed := true
                                                                    return

                                                                    SetSequence2Flag:
                                                                        sequence2Needed := true
                                                                    return

                                                                    SetSequence3Flag:
                                                                        sequence3Needed := true
                                                                    return
                                                                    LoadNavCameraSettings(filePath) {
                                                                        FileRead, fileContent, %filePath%
                                                                        if (ErrorLevel) {
                                                                            MsgBox, Error reading camera file
                                                                            return
                                                                        }

                                                                        RegExMatch(fileContent, "RADIUS\|([0-9.]+)\|", radiusMatch)
                                                                        RegExMatch(fileContent, "ZANGLE\|([0-9.-]+)\|", zangleMatch)

                                                                        if (radiusMatch1) {
                                                                            NavCameraRadius := radiusMatch1
                                                                            radiusRatio := NavCameraRadius / 900
                                                                            NavPixelsPerGameUnitX := (100 / 89) / radiusRatio
                                                                            NavPixelsPerGameUnitY := (100 / 43) / radiusRatio
                                                                        }

                                                                        if (zangleMatch1) {
                                                                            NavCameraAngle := zangleMatch1
                                                                        }
                                                                    }

                                                                    ShowSearchArea:
                                                                        if (!NavTargetGameWindow) {
                                                                            MsgBox, 0, Error, Please select a navigation window first!
                                                                            return
                                                                        }

                                                                        WinGetPos, winX, winY,,, ahk_id %NavTargetGameWindow%
                                                                        searchX1 := winX + 835
                                                                        searchY1 := winY + 30
                                                                        searchX2 := winX + 1019
                                                                        searchY2 := winY + 48

                                                                        Gui, NavTop:New, +ToolWindow -Caption +AlwaysOnTop, NavTop
                                                                        Gui, NavTop:Color, Red
                                                                        Gui, NavTop:Show, x%searchX1% y%searchY1% w184 h2, NavTop

                                                                        Gui, NavBottom:New, +ToolWindow -Caption +AlwaysOnTop, NavBottom
                                                                        Gui, NavBottom:Color, Red
                                                                        bottomY := searchY2 - 2
                                                                        Gui, NavBottom:Show, x%searchX1% y%bottomY% w184 h2, NavBottom

                                                                        Gui, NavLeft:New, +ToolWindow -Caption +AlwaysOnTop, NavLeft
                                                                        Gui, NavLeft:Color, Red
                                                                        Gui, NavLeft:Show, x%searchX1% y%searchY1% w2 h18, NavLeft

                                                                        Gui, NavRight:New, +ToolWindow -Caption +AlwaysOnTop, NavRight
                                                                        Gui, NavRight:Color, Red
                                                                        rightX := searchX2 - 2
                                                                        Gui, NavRight:Show, x%rightX% y%searchY1% w2 h18, NavRight

                                                                        Sleep, 3000
                                                                        Gui, NavTop:Destroy
                                                                        Gui, NavBottom:Destroy
                                                                        Gui, NavLeft:Destroy
                                                                        Gui, NavRight:Destroy
                                                                    return

                                                                    ; StartTravel:
                                                                    ;     if (NavSelectedRouteFile = "") {
                                                                    ;         MsgBox, 0, Error, Please select a route first!
                                                                    ;         return
                                                                    ;     }
                                                                    ;     if (NavWaypointCount = 0) {
                                                                    ;         MsgBox, No waypoints loaded. Please select a route first.
                                                                    ;         return
                                                                    ;     }
                                                                    ;     InitializeNavigation()
                                                                    ;     NavIsTraveling := true
                                                                    ;     NavCurrentWaypoint := 1
                                                                    ;     SetTimer, NavTravelLoop, 100
                                                                    ; return

                                                                    NavTravelLoop:
                                                                        if (!NavIsTraveling || NavCurrentWaypoint > NavWaypointCount) {
                                                                            NavIsTraveling := false
                                                                            SetTimer, NavTravelLoop, Off
                                                                            ;SetTimer, TimerSignalCheck, Off ; Stop signal checking when navigation ends
                                                                            ; Restore any blocked functions when navigation ends
                                                                            RestoreBlockedFunctions()
                                                                            return
                                                                        }

                                                                        waypoint := NavWaypoints[NavCurrentWaypoint]

                                                                        ; Check if we should block/unblock functions at this waypoint
                                                                        CheckWaypointFunctionBlocking()

                                                                        GetNavCurrentCoordinates(coordsX, coordsY)
                                                                        if (Abs(coordsX - waypoint.x) <= 10 && Abs(coordsY - waypoint.y) <= 10) {
                                                                            NavCurrentWaypoint++
                                                                            ; Check if we reached the end and should loop
                                                                            if (NavCurrentWaypoint > NavWaypointCount) {
                                                                                NavCurrentWaypoint := 1
                                                                            }
                                                                            ; Trigger waypoint reached check for function blocking
                                                                            CheckWaypointFunctionBlocking()
                                                                        } else {
                                                                            NavigateToNavCoordinates(waypoint.x, waypoint.y)
                                                                        }
                                                                    return

                                                                    SaveNavRadius:
                                                                        if (!NavCameraFile) {
                                                                            MsgBox, 0, Error, No camera file loaded!
                                                                            return
                                                                        }

                                                                        Gui, Submit, NoHide
                                                                        newRadius := NavRadiusEdit

                                                                        if (newRadius = "" || newRadius < 1) {
                                                                            MsgBox, 0, Error, Please enter a valid number for radius!
                                                                                return
                                                                        }

                                                                        FileRead, fileContent, %NavCameraFile%
                                                                        if (ErrorLevel) {
                                                                            MsgBox, Error reading camera file
                                                                            return
                                                                        }

                                                                        newContent := RegExReplace(fileContent, "RADIUS\|[0-9.]+\|", "RADIUS|" . newRadius . "|")

                                                                        FileDelete, %NavCameraFile%
                                                                        FileAppend, %newContent%, %NavCameraFile%

                                                                        NavCameraRadius := newRadius
                                                                        radiusRatio := NavCameraRadius / 900
                                                                        NavPixelsPerGameUnitX := (100 / 89) / radiusRatio
                                                                        NavPixelsPerGameUnitY := (100 / 43) / radiusRatio

                                                                        MsgBox, Radius updated to %newRadius%
                                                                    return

                                                                    ToggleCameraLock:
                                                                        Gui, Submit, NoHide
                                                                        NavCameraLocked := NavCameraLockCheck
                                                                    return

                                                                    NavigateToNavCoordinates(targetX, targetY) {
                                                                        lastX := ""
                                                                        lastY := ""
                                                                        stuckCount := 0

                                                                        Loop {
                                                                            GetNavCurrentCoordinates(coords1X, coords1Y)
                                                                            Sleep, 20
                                                                            GetNavCurrentCoordinates(coords2X, coords2Y)
                                                                            Sleep, 20
                                                                            GetNavCurrentCoordinates(coords3X, coords3Y)

                                                                            if (coords1X != coords2X || coords1Y != coords2Y || coords2X != coords3X || coords2Y != coords3Y) {
                                                                                Sleep, 300
                                                                                continue
                                                                            }

                                                                            currentX := coords3X
                                                                            currentY := coords3Y
                                                                            targetX := targetX + 0
                                                                            targetY := targetY + 0

                                                                            if (Abs(currentX - targetX) <= 50 && Abs(currentY - targetY) <= 50) {
                                                                                global arrived := true
                                                                                global pylonresetting := true
                                                                                return
                                                                            }

                                                                            if (currentX = lastX && currentY = lastY) {
                                                                                stuckCount++
                                                                            } else {
                                                                                stuckCount := 0
                                                                            }
                                                                            lastX := currentX
                                                                            lastY := currentY

                                                                            clickX := 516
                                                                            clickY := 430

                                                                            deltaX := targetX - currentX
                                                                            deltaY := targetY - currentY

                                                                            pixelsPerGameUnitX := NavPixelsPerGameUnitX
                                                                            pixelsPerGameUnitY := NavPixelsPerGameUnitY

                                                                            cos_angle := Cos(-NavCameraAngle)
                                                                            sin_angle := Sin(-NavCameraAngle)

                                                                            rotatedX := deltaX * cos_angle - deltaY * sin_angle
                                                                            rotatedY := deltaX * sin_angle + deltaY * cos_angle

                                                                            clickOffsetX := -rotatedX * pixelsPerGameUnitX
                                                                            clickOffsetY := -rotatedY * pixelsPerGameUnitY

                                                                            maxClickDistance := 100
                                                                            if (Abs(clickOffsetX) > maxClickDistance) {
                                                                                clickOffsetX := (clickOffsetX > 0) ? maxClickDistance : -maxClickDistance
                                                                            }
                                                                            if (Abs(clickOffsetY) > maxClickDistance) {
                                                                                clickOffsetY := (clickOffsetY > 0) ? maxClickDistance : -maxClickDistance
                                                                            }

                                                                            if (stuckCount > 2) {
                                                                                Random, randX, -30, 30
                                                                                Random, randY, -30, 30
                                                                                clickOffsetX += randX
                                                                                clickOffsetY += randY
                                                                            }

                                                                            clickX += clickOffsetX
                                                                            clickY -= clickOffsetY

                                                                            sendmessage, 0x201, 1, % (clickY << 16) | (clickX & 0xFFFF), , ahk_id %TargetGameWindow% ; WM_LBUTTONDOWN
                                                                            Sleep, 50
                                                                            sendmessage, 0x202, 0, % (clickY << 16) | (clickX & 0xFFFF), , ahk_id %TargetGameWindow% ; WM_LBUTTONUP
                                                                            sleep, 50
                                                                            decopet:="|<>7D7D7D-0.90$62.w0000Y00w18U0008009UG5vrhzMj2/zVGV+2Z+EaZ8TkUbdLyDTG748/+JM264WEX+mYm0UVD7jSbh8w8DS"

                                                                            if (ok:=FindText(X, Y, 1466-150000, 248-150000, 1466+150000, 248+150000, 0, 0, decopet))
                                                                            {
                                                                                sendmessage, 0x1
                                                                            }
                                                                        }
                                                                    }

                                                                    GetNavCurrentCoordinates(ByRef outX, ByRef outY) {
                                                                        outX := ""
                                                                        outY := ""

                                                                        WinGetPos, winX, winY,,, ahk_id %NavTargetGameWindow%
                                                                        searchX1 := winX + 835
                                                                        searchY1 := winY + 30
                                                                        searchX2 := winX + 1019
                                                                        searchY2 := winY + 48

                                                                        if (ok := FindText(x, y, searchX1, searchY1, searchX2, searchY2, 0, 0, NavText)) {
                                                                            results := []
                                                                            for i, v in ok {
                                                                                results.Push({x: v.x, id: v.id})
                                                                            }

                                                                            Loop % results.Length() - 1 {
                                                                                i := A_Index
                                                                                Loop % results.Length() - i {
                                                                                    j := A_Index + i
                                                                                    if (results[i].x > results[j].x) {
                                                                                        temp := results[i]
                                                                                        results[i] := results[j]
                                                                                        results[j] := temp
                                                                                    }
                                                                                }
                                                                            }

                                                                            coordX := ""
                                                                            coordY := ""
                                                                            spaceFound := false

                                                                            for i, v in results {
                                                                                if (i > 1) {
                                                                                    prevX := results[i-1].x
                                                                                    gap := v.x - prevX
                                                                                    if (gap > 9 && !spaceFound) {
                                                                                        spaceFound := true
                                                                                    }
                                                                                }

                                                                                if (!spaceFound) {
                                                                                    coordX .= v.id
                                                                                } else {
                                                                                    coordY .= v.id
                                                                                }
                                                                            }

                                                                            outX := coordX + 0
                                                                            outY := coordY + 0
                                                                        }
                                                                    }

                                                                    RemoveNavToolTip:
                                                                        ToolTip
                                                                    return

                                                                    ; Navigation hotkeys
                                                                    #If NavCameraLocked && NavTargetGameWindow && WinActive("ahk_id " . NavTargetGameWindow)
                                                                    RButton::return
                                                                WheelUp::return
                                                                WheelDown::return
                                                                #If

                                                                ;F8::Gosub, AddWaypoint

                                                                ; ========= NAVIGATION FUNCTION BLOCKING SYSTEM =========

                                                                ; Set which waypoints should block functions
                                                                ; Example: SetNavFunctionBlock(3, 7, ["CheckHealth", "DPSLoop"]) blocks healing and DPS functions from waypoint 3 to 7
                                                                SetNavFunctionBlock(startWaypoint, endWaypoint, functionNames) {
                                                                    global NavFunctionBlockRanges
                                                                    NavFunctionBlockRanges[startWaypoint . "-" . endWaypoint] := {start: startWaypoint, end: endWaypoint, functions: functionNames}
                                                                }

                                                                ; Check if current waypoint requires function blocking/unblocking
                                                                CheckWaypointFunctionBlocking() {
                                                                    global NavCurrentWaypoint, CurrentWaypoint, NavFunctionBlockRanges, NavFunctionsCurrentlyBlocked

                                                                    ; Use NavCurrentWaypoint if available (Navigation tab), otherwise use CurrentWaypoint (old system)
                                                                    currentWP := (NavCurrentWaypoint > 0) ? NavCurrentWaypoint : CurrentWaypoint

                                                                    shouldBlock := false
                                                                    functionsToBlock := []

                                                                    ; Check all defined blocking ranges
                                                                    for rangeName, rangeData in NavFunctionBlockRanges {
                                                                        if (currentWP >= rangeData.start && currentWP <= rangeData.end) {
                                                                            shouldBlock := true
                                                                            for index, functionName in rangeData.functions {
                                                                                functionsToBlock.Push(functionName)
                                                                            }
                                                                        }
                                                                    }

                                                                    ; Block functions if needed and not already blocked
                                                                    if (shouldBlock && !NavFunctionsCurrentlyBlocked) {
                                                                        BlockNavFunctions(functionsToBlock)
                                                                    }
                                                                    ; Restore functions if not needed and currently blocked
                                                                    else if (!shouldBlock && NavFunctionsCurrentlyBlocked) {
                                                                        RestoreBlockedFunctions()
                                                                    }
                                                                }

                                                                ; Block specified functions (timers keep running, but functions won't execute)
                                                                BlockNavFunctions(functionNames) {
                                                                    global NavBlockedFunctions, NavFunctionsCurrentlyBlocked

                                                                    NavBlockedFunctions := []

                                                                    for index, functionName in functionNames {
                                                                        ; Store the function info for later restoration
                                                                        NavBlockedFunctions.Push(functionName)
                                                                    }

                                                                    NavFunctionsCurrentlyBlocked := true

                                                                    ; Optional: Show notification
                                                                    if (NavBlockedFunctions.Length() > 0) {
                                                                        functionList := ""
                                                                        for index, func in NavBlockedFunctions {
                                                                            functionList .= func . (index < NavBlockedFunctions.Length() ? ", " : "")
                                                                        }
                                                                        ToolTip, Navigation: Critical protection - Blocked: %functionList%, 0, 30
                                                                        SetTimer, RemoveNavBlockTooltip, 3000
                                                                    }
                                                                }

                                                                ; Restore all blocked functions
                                                                RestoreBlockedFunctions() {
                                                                    global NavBlockedFunctions, NavFunctionsCurrentlyBlocked

                                                                    if (!NavFunctionsCurrentlyBlocked) {
                                                                    return
                                                                }

                                                                restoredFunctions := []

                                                                for index, functionName in NavBlockedFunctions {
                                                                    restoredFunctions.Push(functionName)
                                                                }

                                                                NavBlockedFunctions := []
                                                                NavFunctionsCurrentlyBlocked := false

                                                                ; Optional: Show notification
                                                                if (restoredFunctions.Length() > 0) {
                                                                    functionList := ""
                                                                    for index, func in restoredFunctions {
                                                                        functionList .= func . (index < restoredFunctions.Length() ? ", " : "")
                                                                    }
                                                                    ToolTip, Navigation: Critical protection OFF - Restored: %functionList%, 0, 30
                                                                    SetTimer, RemoveNavBlockTooltip, 3000
                                                                }
                                                            }

                                                            ; Enable Critical mode to block all timers
                                                            EnableCriticalMode() {
                                                                global CriticalModeEnabled := true
                                                                ToolTip, Critical Mode: ON - All timers blocked, 10, 50, 2
                                                                SetTimer, RemoveCriticalTooltip, -2000
                                                            }

                                                            ; Disable Critical mode to allow timers
                                                            DisableCriticalMode() {
                                                                global CriticalModeEnabled := false
                                                                ToolTip, Critical Mode: OFF - Timers enabled, 10, 50, 2
                                                                SetTimer, RemoveCriticalTooltip, -2000
                                                            }

                                                            ; Hotkeys for manual Critical mode control
                                                            F9::EnableCriticalMode()
                                                            F11::DisableCriticalMode()

                                                            RemoveCriticalTooltip:
                                                                ToolTip, , , , 2
                                                            return

                                                            RemoveNavBlockTooltip:
                                                                ToolTip
                                                                SetTimer, RemoveNavBlockTooltip, Off
                                                            return

                                                            CheckDPSNavigation() {
                                                                if (!NavTargetGameWindow || dpsNavTargetX = "" || dpsNavTargetY = "") {
                                                                    return
                                                                }

                                                                GetNavCurrentCoordinates(currentX, currentY)
                                                                if (currentX = "" || currentY = "") {
                                                                    return
                                                                }

                                                                ; Check if already at target coordinates (within 50 units)
                                                                if (Abs(currentX - dpsNavTargetX) <= 50 && Abs(currentY - dpsNavTargetY) <= 50) {
                                                                    return ; Already there, skip navigation
                                                                }

                                                                ; Navigate to target coordinates
                                                                NavigateToNavCoordinates(dpsNavTargetX, dpsNavTargetY)
                                                            }
                                                            CheckDPSNavigation2() {
                                                                if (!NavTargetGameWindow || dpsNavTargetX = "" || dpsNavTargetY = "") {
                                                                    return
                                                                }

                                                                GetNavCurrentCoordinates(currentX, currentY)
                                                                if (currentX = "" || currentY = "") {
                                                                    return
                                                                }

                                                                ; Check if already at target coordinates (within 50 units)
                                                                if (Abs(currentX - dpsNavTargetX) <= 50 && Abs(currentY - dpsNavTargetY) <= 50) {
                                                                    return ; Already there, skip navigation
                                                                }

                                                                ; Navigate to target coordinates
                                                                NavigateToNavCoordinates(dpsNavTargetX, dpsNavTargetY)
                                                            }
                                                            LoadDPSNavSettings() {
                                                                global usePreviousSettings

                                                                ; Only load DPS coordinates if user chose to use previous settings
                                                                if (!usePreviousSettings) {
                                                                    return
                                                                }

                                                                IniRead, loadedEnabled, dpsnavsettings.ini, Navigation, Enabled, 0
                                                                IniRead, loadedX, dpsnavsettings.ini, Navigation, TargetX, 
                                                                IniRead, loadedY, dpsnavsettings.ini, Navigation, TargetY, 
                                                                IniRead, loadedRadius, dpsnavsettings.ini, Navigation, Radius, 50

                                                                if (loadedEnabled != "ERROR") {
                                                                    dpsNavEnabled := loadedEnabled
                                                                    ;GuiControl,, dpsNavEnabled, %dpsNavEnabled%
                                                                }

                                                                if (loadedX != "ERROR" && loadedX != "") {
                                                                    dpsNavTargetX := loadedX
                                                                    GuiControl,, dpsNavTargetXEdit, %dpsNavTargetX%
                                                                }

                                                                if (loadedY != "ERROR" && loadedY != "") {
                                                                    dpsNavTargetY := loadedY
                                                                    GuiControl,, dpsNavTargetYEdit, %dpsNavTargetY%
                                                                }

                                                                if (loadedRadius != "ERROR" && loadedRadius != "") {
                                                                    ; Validate radius (minimum 25)
                                                                    if (loadedRadius < 25)
                                                                        loadedRadius := 50
                                                                    dpsNavRadius := loadedRadius
                                                                    GuiControl,, dpsNavRadiusEdit, %dpsNavRadius%
                                                                }
                                                            }
                                                            SetPylonPosition:
                                                                MsgBox, 0, Pylon Setup, Press SPACEBAR at first pylon location, then SPACEBAR at second pylon location.

                                                                KeyWait, Space, D
                                                                keywait, Space, u
                                                                MouseGetPos, PylonPos1X, PylonPos1Y
                                                                ToolTip, Pylon 1 set. Press SPACEBAR for second position.

                                                                KeyWait, Space, D
                                                                keywait, Space, u
                                                                MouseGetPos, PylonPos2X, PylonPos2Y

                                                                IniWrite, %PylonPos1X%, pylonpositions.ini, Positions, Pylon1X
                                                                IniWrite, %PylonPos1Y%, pylonpositions.ini, Positions, Pylon1Y
                                                                IniWrite, %PylonPos2X%, pylonpositions.ini, Positions, Pylon2X
                                                                IniWrite, %PylonPos2Y%, pylonpositions.ini, Positions, Pylon2Y

                                                                ToolTip, Pylon positions saved!
                                                                global pylonresetlocationset := true
                                                                SetTimer, RemovePylonToolTip, 2000
                                                            return

                                                            RemovePylonToolTip:
                                                                ToolTip
                                                            return

                                                            SendMessageClick2(x, y, winId := "") {
                                                                if (winId = "")
                                                                    winId := win1

                                                                ; Create lParam for coordinates (x and y are already client coordinates)
                                                                lParam := (y << 16) | (x & 0xFFFF)

                                                                ; Send mouse down and up messages
                                                                SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
                                                                Sleep, 50
                                                                SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
                                                                Sleep, 50
                                                                SendMessage, 0x201, 1, %lParam%,, ahk_id %winId% ; WM_LBUTTONDOWN
                                                                Sleep, 50
                                                                SendMessage, 0x202, 0, %lParam%,, ahk_id %winId% ; WM_LBUTTONUP
                                                            }

                                                            ; ========= SAVE/LOAD ALL CHECKBOX SETTINGS =========
                                                            SaveAllSettings:
                                                                Gui, Submit, NoHide
                                                                SaveAllCheckboxStates()
                                                                MsgBox, 64, Settings Saved, All checkbox settings have been saved to INI file!
                                                            return

                                                            SaveAllCheckboxStates() {
                                                                global iniFile
                                                                global healanddps, dpstargetedhealing, returnafterheal, farming
                                                                global destroyskypotionstimer, infinitemouse, ResurrectionEnabled
                                                                global dpsNavEnabled, meleeAttackEnabled, SequentialDPSMode
                                                                global refreshscrollEnabled
                                                                global gnollbuff, dtbuff, NavCameraLockCheck

                                                                FileEncoding, UTF-8
                                                                ; Main tab checkboxes (excluding farming, dpstargetedhealing, destroyskypotionstimer - they always start unchecked)
                                                                IniWrite, %healanddps%, %iniFile%, CheckboxStates, healanddps
                                                                ; IniWrite, %dpstargetedhealing%, %iniFile%, CheckboxStates, dpstargetedhealing  ; Not saved - must be off by default
                                                                IniWrite, %returnafterheal%, %iniFile%, CheckboxStates, returnafterheal
                                                                ; IniWrite, %farming%, %iniFile%, CheckboxStates, farming  ; Not saved - must be off by default
                                                                ; IniWrite, %destroyskypotionstimer%, %iniFile%, CheckboxStates, destroyskypotionstimer  ; Not saved - must be off by default
                                                                IniWrite, %infinitemouse%, %iniFile%, CheckboxStates, infinitemouse
                                                                IniWrite, %ResurrectionEnabled%, %iniFile%, CheckboxStates, ResurrectionEnabled
                                                                IniWrite, %dpsNavEnabled%, %iniFile%, CheckboxStates, dpsNavEnabled

                                                                ; DPS tab checkboxes
                                                                IniWrite, %meleeAttackEnabled%, %iniFile%, CheckboxStates, meleeAttackEnabled
                                                                IniWrite, %refreshscrollEnabled%, %iniFile%, CheckboxStates, refreshscrollEnabled
                                                                IniWrite, %SequentialDPSMode%, %iniFile%, CheckboxStates, SequentialDPSMode

                                                                ; Buffs tab checkboxes (excluding gnollbuff, dtbuff - they always start unchecked)
                                                                ; IniWrite, %gnollbuff%, %iniFile%, CheckboxStates, gnollbuff  ; Not saved - must be off by default
                                                                ; IniWrite, %dtbuff%, %iniFile%, CheckboxStates, dtbuff  ; Not saved - must be off by default

                                                                ; Navigation tab checkboxes
                                                                IniWrite, %NavCameraLockCheck%, %iniFile%, CheckboxStates, NavCameraLockCheck
                                                                FileEncoding
                                                            }

                                                            LoadAllCheckboxStates() {
                                                                global iniFile
                                                                global healanddps, dpstargetedhealing, returnafterheal, farming
                                                                global destroyskypotionstimer, infinitemouse, ResurrectionEnabled
                                                                global dpsNavEnabled, meleeAttackEnabled, SequentialDPSMode
                                                                global refreshscrollenabled
                                                                global gnollbuff, dtbuff, NavCameraLockCheck

                                                                ; Main tab checkboxes (excluding farming, dpstargetedhealing, destroyskypotionstimer - they always start unchecked)
                                                                IniRead, healanddps, %iniFile%, CheckboxStates, healanddps, 0
                                                                ; dpstargetedhealing always starts at 0 (not loaded from INI)
                                                                dpstargetedhealing := 0
                                                                IniRead, returnafterheal, %iniFile%, CheckboxStates, returnafterheal, 0
                                                                ; farming always starts at 0 (not loaded from INI)
                                                                farming := 0
                                                                ; destroyskypotionstimer always starts at 0 (not loaded from INI)
                                                                destroyskypotionstimer := 0
                                                                IniRead, infinitemouse, %iniFile%, CheckboxStates, infinitemouse, 0
                                                                IniRead, ResurrectionEnabled, %iniFile%, CheckboxStates, ResurrectionEnabled, 0
                                                                IniRead, dpsNavEnabled, %iniFile%, CheckboxStates, dpsNavEnabled, 0

                                                                ; DPS tab checkboxes
                                                                IniRead, meleeAttackEnabled, %iniFile%, CheckboxStates, meleeAttackEnabled, 0
                                                                IniRead, refreshscrollEnabled, %iniFile%, CheckboxStates, refreshscrollEnabled, 0
                                                                IniRead, SequentialDPSMode, %iniFile%, CheckboxStates, SequentialDPSMode, 0

                                                                ; Buffs tab checkboxes (excluding gnollbuff, dtbuff - they always start unchecked)
                                                                ; gnollbuff always starts at 0 (not loaded from INI)
                                                                gnollbuff := 0
                                                                ; dtbuff always starts at 0 (not loaded from INI)
                                                                dtbuff := 0

                                                                ; Navigation tab checkboxes
                                                                IniRead, NavCameraLockCheck, %iniFile%, CheckboxStates, NavCameraLockCheck, 1

                                                                ; Update GUI controls to reflect loaded values
                                                                GuiControl,, healanddps, %healanddps%
                                                                GuiControl,, dpstargetedhealing, 0
                                                                GuiControl,, returnafterheal, %returnafterheal%
                                                                GuiControl,, farming, 0
                                                                GuiControl,, destroyskypotionstimer, 0
                                                                GuiControl,, infinitemouse, %infinitemouse%
                                                                GuiControl,, ResurrectionEnabled, %ResurrectionEnabled%
                                                                GuiControl,, dpsNavEnabled, %dpsNavEnabled%
                                                                GuiControl,, meleeAttackEnabled, %meleeAttackEnabled%
                                                                GuiControl,, refreshscrollEnabled, %refreshscrollEnabled%
                                                                GuiControl,, SequentialDPSMode, %SequentialDPSMode%
                                                                GuiControl,, gnollbuff, 0
                                                                GuiControl,, dtbuff, 0
                                                                GuiControl,, NavCameraLockCheck, %NavCameraLockCheck%
                                                                ; Activate refresh scroll timer if enabled
                                                                if (refreshscrollEnabled = 1 || refreshscrollEnabled = "1") {
                                                                    GuiControl, Show, refreshKey
                                                                    refreshScrollEndTime := A_TickCount + 3600000
                                                                    SetTimer, UpdateRefreshScrollTimer, 1000
                                                                    SetTimer, userefreshscroll, 3600000
                                                                }

                                                                ; Debug: Show what was loaded
                                                                ; ToolTip, Loaded checkboxes: healanddps=%healanddps% farming=%farming% melee=%meleeAttackEnabled% sequential=%SequentialDPSMode%, 0, 0, 1
                                                                SetTimer, RemoveLoadTooltip, -3000
                                                            }

                                                            LoadCheckboxStatesDelayed:
                                                                ; Load all checkbox states from INI
                                                                LoadAllCheckboxStates()

                                                                ; Set the selectedKey dropdown to the loaded value
                                                                GuiControl, Choose, selectedKey, %selectedKey%
                                                                ; Set the DPS toggle hotkey control to the loaded value
                                                                GuiControl,, DPSToggleHotkey, %DPSToggleHotkey%
                                                                ; Set the melee attack input value
                                                                GuiControl,, meleeAttackKey, %meleeAttackKey%
                                                                ; Set the refresh scroll input value
                                                                GuiControl,, refreshKey, %refreshKey%
                                                                ; Set the max resurrections default value
                                                                GuiControl,, MaxResurrectionsEdit, %MaxResurrections%
                                                                ; Show/hide melee controls based on checkbox state
                                                                if (meleeAttackEnabled = 1 || meleeAttackEnabled = "1") {
                                                                    GuiControl, Show, MeleeKeyLabel
                                                                    GuiControl, Show, meleeAttackKey
                                                                } else {
                                                                    GuiControl, Hide, MeleeKeyLabel
                                                                    GuiControl, Hide, meleeAttackKey
                                                                }
                                                                if (refreshscrollEnabled = 1 || refreshscrollEnabled = "1") {
                                                                    GuiControl, Show, refreshKeyLabel
                                                                    GuiControl, Show, refreshKey
                                                                } else {
                                                                    GuiControl, Hide, refreshKeyLabel
                                                                    GuiControl, Hide, refreshKey
                                                                }

                                                                ; Start death detection if auto-resurrection is enabled
                                                                if (ResurrectionEnabled = 1 || ResurrectionEnabled = "1") {
                                                                    UpdateResurrectionStatus("Enabled - " . CurrentResurrections . "/" . MaxResurrections)
                                                                    StartDeathDetection()
                                                                }
                                                            return

                                                            RemoveLoadTooltip:
                                                                ToolTip,,,,1
                                                            return

                                                            LoadSettings() {
                                                                global
                                                                IniRead, pullAreas, %iniFile%, Settings, PullAreas, 3
                                                                IniRead, clickLocations, %iniFile%, Settings, ClickLocations, 4
                                                                IniRead, randomOffsetX, %iniFile%, Settings, RandomOffsetX, 5
                                                                IniRead, randomOffsetY, %iniFile%, Settings, RandomOffsetY, 5
                                                                IniRead, returnSleepTime, %iniFile%, Settings, ReturnSleepTime, 4500
                                                                IniRead, mouseMoveDelay, %iniFile%, Settings, MouseMoveDelay, 90
                                                                IniRead, mouseClickDelay, %iniFile%, Settings, MouseClickDelay, 50
                                                                IniRead, selectedWindow, %iniFile%, Settings, SelectedWindow,
                                                                IniRead, selectedKey, %iniFile%, Settings, FollowWhoKey, F2
                                                                IniRead, DPSToggleHotkey, %iniFile%, Settings, DPSToggleHotkey, Insert
                                                                ; Note: meleeAttackEnabled is loaded in LoadAllCheckboxStates()
                                                                IniRead, meleeAttackKey, %SettingsFile%, Settings, meleeAttackKey, ""
                                                                IniRead, refreshKey, %SettingsFile%, Settings, refreshKey, ""
                                                                ;IniRead, refreshscrollEnabled, %SettingsFile%, Settings, refreshscrollEnabled, 0

                                                                ; Apply to GUI after it's created
                                                                GuiControl,, meleeAttackKey, %meleeAttackKey%
                                                                GuiControl,, refreshKey, %refreshKey%
                                                                GuiControl,, refreshscrollEnabled, %refreshscrollEnabled%

                                                                ; Show/hide refresh key controls based on checkbox state
                                                                if (refreshscrollEnabled) {
                                                                    GuiControl, Show, refreshKeyLabel
                                                                    GuiControl, Show, refreshKey
                                                                    ; Load Max Resurrections setting
                                                                    IniRead, MaxResurrections, %iniFile%, Settings, MaxResurrections, 8

                                                                    ; Set up DPS toggle hotkey if loaded
                                                                    if (DPSToggleHotkey != "" && DPSToggleHotkey != "ERROR") {
                                                                        hotkey, %DPSToggleHotkey%, ToggleDPSAction, On, UseErrorLevel
                                                                    }
                                                                }

                                                                IniRead, movementX1, %iniFile%, MovementArea, X1, 0
                                                                IniRead, movementY1, %iniFile%, MovementArea, Y1, 0
                                                                IniRead, movementX2, %iniFile%, MovementArea, X2, 0
                                                                IniRead, movementY2, %iniFile%, MovementArea, Y2, 0

                                                                IniRead, movement2X1, %iniFile%, MovementArea2, X1, 0
                                                                IniRead, movement2Y1, %iniFile%, MovementArea2, Y1, 0
                                                                IniRead, movement2X2, %iniFile%, MovementArea2, X2, 0
                                                                IniRead, movement2Y2, %iniFile%, MovementArea2, Y2, 0
                                                                IniRead, RandomDelayMin, %iniFile%, Delays, MinDelay
                                                                IniRead, RandomDelayMax, %iniFile%, Delays, MaxDelay
                                                                IniRead, pullHotkey, %iniFile%, Hotkeys, PullHotkey, 1
                                                                if (movementX1 != 0 || movementY1 != 0 || movementX2 != 0 || movementY2 != 0)
                                                                    movementAreaSet := true
                                                                if (movement2X1 != 0 || movement2Y1 != 0 || movement2X2 != 0 || movement2Y2 != 0)
                                                                    movementArea2Set := true

                                                                clickCoords := []
                                                                IniRead, coordCount, %iniFile%, ClickCoords, Count, 0
                                                                Loop, %coordCount% {
                                                                    IniRead, coordX, %iniFile%, ClickCoords, X%A_Index%, 0
                                                                    IniRead, coordY, %iniFile%, ClickCoords, Y%A_Index%, 0
                                                                    IniRead, coordArea, %iniFile%, ClickCoords, Area%A_Index%, 1
                                                                    if (coordX != 0 || coordY != 0) {
                                                                        clickCoords.Push({x: coordX, y: coordY, area: coordArea})
                                                                    }
                                                                }
                                                            }

                                                            SaveSettings() {
                                                                global
                                                                GuiControlGet, randomdelaymin,, randomdelaymin
                                                                GuiControlGet, randomdelaymax,, randomdelaymax
                                                                GuiControlGet, selectedKey,, selectedKey
                                                                IniWrite, %pullAreas%, %iniFile%, Settings, PullAreas
                                                                IniWrite, %clickLocations%, %iniFile%, Settings, ClickLocations
                                                                IniWrite, %randomOffsetX%, %iniFile%, Settings, RandomOffsetX
                                                                IniWrite, %randomOffsetY%, %iniFile%, Settings, RandomOffsetY
                                                                IniWrite, %returnSleepTime%, %iniFile%, Settings, ReturnSleepTime
                                                                IniWrite, %mouseMoveDelay%, %iniFile%, Settings, MouseMoveDelay
                                                                IniWrite, %mouseClickDelay%, %iniFile%, Settings, MouseClickDelay
                                                                IniWrite, ahk_id %win1%, %iniFile%, Settings, SelectedWindow
                                                                IniWrite, %selectedKey%, %iniFile%, Settings, FollowWhoKey

                                                                IniWrite, %movementX1%, %iniFile%, MovementArea, X1
                                                                IniWrite, %movementY1%, %iniFile%, MovementArea, Y1
                                                                IniWrite, %movementX2%, %iniFile%, MovementArea, X2
                                                                IniWrite, %movementY2%, %iniFile%, MovementArea, Y2

                                                                IniWrite, %movement2X1%, %iniFile%, MovementArea2, X1
                                                                IniWrite, %movement2Y1%, %iniFile%, MovementArea2, Y1
                                                                IniWrite, %movement2X2%, %iniFile%, MovementArea2, X2
                                                                IniWrite, %movement2Y2%, %iniFile%, MovementArea2, Y2
                                                                IniWrite, %RandomDelayMin%, %iniFile%, Delays, MinDelay
                                                                IniWrite, %RandomDelayMax%, %iniFile%, Delays, MaxDelay
                                                                IniWrite, %pullHotkey%, %iniFile%, Hotkeys, PullHotkey
                                                                coordCount := clickCoords.Length()

                                                                IniWrite, %coordCount%, %iniFile%, ClickCoords, Count
                                                                Loop, %coordCount% {
                                                                    coord := clickCoords[A_Index]
                                                                    coordX := coord.x
                                                                    coordY := coord.y
                                                                    coordArea := coord.area

                                                                    IniWrite, %coordX%, %iniFile%, ClickCoords, X%A_Index%
                                                                    IniWrite, %coordY%, %iniFile%, ClickCoords, Y%A_Index%
                                                                    IniWrite, %coordArea%, %iniFile%, ClickCoords, Area%A_Index%
                                                                }
                                                                if (TargetGamePID && navCameraFile) {
                                                                    IniWrite, %TargetGamePID%, pathingsettings.ini, Settings, WindowPID
                                                                    IniWrite, %navCameraFile%, pathingsettings.ini, Settings, CameraFile
                                                                }
                                                                if (win2PID) {
                                                                    IniWrite, %win2PID%, pathingsettings.ini, Settings, Win2PID
                                                                }

                                                            }

                                                            StartWindowMonitor:
                                                                StartWindowMonitor()
                                                            return

                                                            StopWindowMonitor:
                                                                StopWindowMonitor()
                                                            return
                                                            ; DPS Settings Update Functions
                                                            UpdateDpsEnabled:
                                                                Gui, Submit, NoHide
                                                                dpsEnabled := DpsEnabledCheckbox
                                                            statusText := dpsEnabled ? "DPS: Enabled" : "DPS: Disabled"
                                                                GuiControl,, DpsStatusText, %statusText%
                                                            return

                                                            UpdateDpsHotkey:
                                                                Gui, Submit, NoHide
                                                                dpsHotkey := DpsHotkeyEdit
                                                            return

                                                            UpdateDpsDuration:
                                                                Gui, Submit, NoHide
                                                                dpsDuration := DpsDurationEdit
                                                                ; Validate that it's a number
                                                                if dpsDuration is not number
                                                                {
                                                                    dpsDuration := 3000
                                                                    GuiControl,, DpsDurationEdit, %dpsDuration%
                                                                }
                                                            return

                                                            TestDpsHotkey:
                                                                if (dpsHotkey != "" && selectedWindow != "") {
                                                                    GuiControl,, DpsStatusText, Testing DPS hotkey...
                                                                    ExecuteDpsSequence()
                                                                    GuiControl,, DpsStatusText, DPS test completed
                                                                } else {
                                                                    GuiControl,, DpsStatusText, Set hotkey and select window first
                                                                }
                                                            return

                                                            SaveDpsSettings:
                                                                Gui, Submit, NoHide
                                                                ; You can add file saving logic here if needed
                                                                GuiControl,, DpsStatusText, DPS settings saved
                                                            return

                                                            ; DPS Execution Function
                                                            ExecuteDpsSequence() {
                                                                if (dpsHotkey = "" || selectedWindow = "")
                                                                    return
                                                                sendlevel 1

                                                                send, {%dpsHotkey% down}

                                                                Sleep, %dpsDuration%

                                                                send, {%dpsHotkey% up}
                                                                sendlevel 0
                                                            }

                                                            UpdatePullAreas:
                                                                GuiControlGet, pullAreas,, PullAreasEdit
                                                            return

                                                            UpdateClickLocations:
                                                                GuiControlGet, clickLocations,, ClickLocationsEdit
                                                            return

                                                            UpdateOffsetX:
                                                                GuiControlGet, randomOffsetX,, OffsetXEdit
                                                            return

                                                            UpdateOffsetY:
                                                                GuiControlGet, randomOffsetY,, OffsetYEdit
                                                            return

                                                            UpdateSleepTime:
                                                                GuiControlGet, returnSleepTime,, SleepTimeEdit
                                                            return

                                                            UpdateMouseMoveDelay:
                                                                GuiControlGet, mouseMoveDelay,, MouseMoveDelayEdit
                                                            return

                                                            UpdateMouseClickDelay:
                                                                GuiControlGet, mouseClickDelay,, MouseClickDelayEdit
                                                            return

                                                            SaveDelaySettings:
                                                                GuiControlGet, mouseMoveDelay,, MouseMoveDelayEdit
                                                                GuiControlGet, mouseClickDelay,, MouseClickDelayEdit
                                                                GuiControlGet, returnSleepTime,, SleepTimeEdit

                                                                ; Add these lines to get the random delay values:
                                                                GuiControlGet, randomdelaymin,, randomdelaymin
                                                                GuiControlGet, randomdelaymax,, randomdelaymax

                                                                SaveSettings()
                                                            return

                                                            SetMovementArea:
                                                                Gui, Hide
                                                                MsgBox, 4,, Click OK then drag to select movement detection area
                                                                IfMsgBox, Yes
                                                                {
                                                                    Gui, 2:New, +AlwaysOnTop -Caption +ToolWindow +Border, Selection
                                                                    Gui, 2:Color, Red

                                                                    CoordMode, Mouse, Screen
                                                                    KeyWait, LButton, U
                                                                    KeyWait, LButton, D
                                                                    MouseGetPos, movementX1, movementY1

                                                                    Gui, 2:Show, x%movementX1% y%movementY1% w1 h1
                                                                    WinSet, Transparent, 128, Selection

                                                                    while GetKeyState("LButton", "P") {
                                                                        MouseGetPos, currentX, currentY
                                                                        boxX := movementX1 < currentX ? movementX1 : currentX
                                                                        boxY := movementY1 < currentY ? movementY1 : currentY
                                                                        boxW := Abs(currentX - movementX1)
                                                                        boxH := Abs(currentY - movementY1)
                                                                        Gui, 2:Show, x%boxX% y%boxY% w%boxW% h%boxH%
                                                                        Sleep, 10
                                                                    }

                                                                    MouseGetPos, movementX2, movementY2
                                                                    Gui, 2:Destroy

                                                                    if (movementX1 > movementX2) {
                                                                        temp := movementX1
                                                                        movementX1 := movementX2
                                                                        movementX2 := temp
                                                                    }
                                                                    if (movementY1 > movementY2) {
                                                                        temp := movementY1
                                                                        movementY1 := movementY2
                                                                        movementY2 := temp
                                                                    }

                                                                    movementAreaSet := true

                                                                    MsgBox, 4,, Set optional second movement area?
                                                                    IfMsgBox, Yes
                                                                    {
                                                                        Gui, 2:New, +AlwaysOnTop -Caption +ToolWindow +Border, Selection2
                                                                        Gui, 2:Color, Blue

                                                                        KeyWait, LButton, U
                                                                        KeyWait, LButton, D
                                                                        MouseGetPos, movement2X1, movement2Y1

                                                                        Gui, 2:Show, x%movement2X1% y%movement2Y1% w1 h1
                                                                        WinSet, Transparent, 128, Selection2

                                                                        while GetKeyState("LButton", "P") {
                                                                            MouseGetPos, currentX, currentY
                                                                            boxX := movement2X1 < currentX ? movement2X1 : currentX
                                                                            boxY := movement2Y1 < currentY ? movement2Y1 : currentY
                                                                            boxW := Abs(currentX - movement2X1)
                                                                            boxH := Abs(currentY - movement2Y1)
                                                                            Gui, 2:Show, x%boxX% y%boxY% w%boxW% h%boxH%
                                                                            Sleep, 10
                                                                        }

                                                                        MouseGetPos, movement2X2, movement2Y2
                                                                        Gui, 2:Destroy

                                                                        if (movement2X1 > movement2X2) {
                                                                            temp := movement2X1
                                                                            movement2X1 := movement2X2
                                                                            movement2X2 := temp
                                                                        }
                                                                        if (movement2Y1 > movement2Y2) {
                                                                            temp := movement2Y1
                                                                            movement2Y1 := movement2Y2
                                                                            movement2Y2 := temp
                                                                        }

                                                                        movementArea2Set := true
                                                                        GuiControl,, MovementStatus, Areas: Set (2)
                                                                    } else {
                                                                        GuiControl,, MovementStatus, Area: Set (1)
                                                                    }

                                                                    SaveSettings()
                                                                }
                                                                Gui, 1:Show,, Templar Puller
                                                            return

                                                            SetClickLocations:
                                                                ;MsgBox, YES
                                                                ReturnToMainCharacter()

                                                                clickCoords := []
                                                                totalClicks := pullAreas * clickLocations

                                                                GuiControl,, StatusText, Click %totalClicks% locations. Current: 1

                                                                Loop, %totalClicks% {
                                                                    MsgBox, 4,, Right Click location %A_Index% of %totalClicks%
                                                                    IfMsgBox, Yes
                                                                    {
                                                                        KeyWait, rbutton, D
                                                                        keywait, rbutton, U
                                                                        CoordMode, Mouse, Screen
                                                                        MouseGetPos, clickX, clickY
                                                                        WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                                                                        ; Account for window border/title bar
                                                                        borderX := 8
                                                                        borderY := 31
                                                                        relativeX := clickX - winX - borderX
                                                                        relativeY := clickY - winY - borderY

                                                                        clickCoords.Push({x: relativeX, y: relativeY, area: Ceil(A_Index / clickLocations)})
                                                                        GuiControl,, StatusText, Click %totalClicks% locations. Current: %A_Index%

                                                                        if (Mod(A_Index, clickLocations) = 0 && A_Index < totalClicks) {
                                                                            ReturnToMainCharacter()
                                                                        }

                                                                        Sleep, 200
                                                                    }
                                                                    else
                                                                    {
                                                                        break
                                                                    }
                                                                }

                                                                coordsCount := clickCoords.Length()
                                                                SaveSettings()
                                                                if (coordsCount = totalClicks) {
                                                                    GuiControl,, StatusText, Status: Ready to start pulling!
                                                                } else {
                                                                    GuiControl,, StatusText, Status: Setup incomplete.
                                                                }
                                                            return

                                                            StartPulling:

                                                                coordsCount := clickCoords.Length()
                                                                if (!movementAreaSet || coordsCount = 0) {
                                                                    MsgBox, Please set movement area and click locations first!
                                                                    return
                                                                }

                                                                if (selectedWindow != "") {
                                                                    ;WinActivate, ahk_id %win1%
                                                                    Sleep, 200
                                                                }

                                                                pullingActive := true
                                                                currentPullArea := 1
                                                                currentClickIndex := 1

                                                                SetTimer, PullingLoop, 50
                                                                GuiControl,, StatusText, Status: Pulling active...
                                                            return

                                                            StopPulling:
                                                                pullingActive := false
                                                                SetTimer, PullingLoop, Off
                                                                GuiControl,, StatusText, Status: Stopped.
                                                            return

                                                            ReturnToCharacter:
                                                                if (selectedWindow != "") {
                                                                    ;WinActivate, ahk_id %win1%
                                                                    Sleep, 200
                                                                }
                                                                ReturnToMainCharacter()
                                                            return

                                                            SaveCoords:
                                                                SaveSettings()
                                                                GuiControl,, StatusText, Status: Coordinates saved to INI file.
                                                            return

                                                            LoadCoords:
                                                                LoadSettings()
                                                                coordsCount := clickCoords.Length()
                                                                GuiControl,, StatusText, Status: Loaded %coordsCount% coordinates from INI file.
                                                            return

                                                            ; Updated Pulling Loop with DPS Integration
                                                            PullingLoop:

                                                                if (!pullingActive)
                                                                    return
                                                                CoordMode, Pixel, Screen
                                                                coordmode, mouse, screen
                                                                areaClicks := []
                                                                for index, coord in clickCoords {
                                                                    if (coord["area"] = currentPullArea) {
                                                                        areaClicks.Push({x: coord["x"], y: coord["y"], originalIndex: index})
                                                                    }
                                                                }
                                                                CoordMode, mouse, client
                                                                areaClicksCount := areaClicks.Length()

                                                                if (currentClickIndex <= areaClicksCount) {
                                                                    coord := areaClicks[currentClickIndex]
                                                                    offsetX := Random(-randomOffsetX, randomOffsetX)
                                                                    offsetY := Random(-randomOffsetY, randomOffsetY)

                                                                    clickX := coord["x"] + offsetX
                                                                    clickY := coord["y"] + offsetY

                                                                    ControlSend,, 1, ahk_id %win1% 
                                                                    Sleep, 80
                                                                    origX := coord["x"]
                                                                    origY := coord["y"]

                                                                    lParam1 := clickX | (clickY << 16)
                                                                    SendMessage, 0x0200, 0x0000, %lParam1%,, ahk_id %win1%
                                                                    Sleep, %mouseMoveDelay%
                                                                    SendMessage, 0x0201, 0x0000, %lParam1%,, ahk_id %win1%
                                                                    Sleep, %mouseClickDelay%
                                                                    SendMessage, 0x0202, 0x0000, %lParam1%,, ahk_id %win1%
                                                                    Random, randomdelay, %RandomDelayMin%, %RandomDelayMax%
                                                                    Sleep, %randomdelay%
                                                                    if (movingg)
                                                                    {
                                                                        WaitForMovementStop()
                                                                    }
                                                                    if (healanddps)
                                                                    {
                                                                        gosub, DynamicHealthCheck
                                                                    }
                                                                    if (templardps)
                                                                    {
                                                                        TryCastCC()
                                                                        TryCastDPSSkills()
                                                                    }
                                                                    ;Check DPS Navigation if enabled
                                                                    if (dpsNavEnabled && dpsNavTargetX != "" && dpsNavTargetY != "") {
                                                                        Loop {
                                                                            CheckDPSNavigation()
                                                                            GetNavCurrentCoordinates(currentX, currentY)
                                                                            if (Abs(currentX - dpsNavTargetX) <= 50 && Abs(currentY - dpsNavTargetY) <= 50) {
                                                                                controlsend,, {tab}, ahk_id %win1%
                                                                                break
                                                                            }
                                                                            Sleep, 100
                                                                        }
                                                                        if (arrived)
                                                                        {
                                                                            ; SendMessageClick3(pylonPos1X, pylonPos1Y, win1)
                                                                            ; Sleep, 100
                                                                            ; SendMessageClick3(pylonPos2X, pylonPos2Y, win1)
                                                                            ; Sleep, 100
                                                                            ; SendMessageClick3(pylonPos2X, pylonPos2Y, win1)
                                                                            ; Sleep, 100
                                                                            ; SendMessageClick3(pylonPos2X, pylonPos2Y, win1)
                                                                            ; Sleep, 100
                                                                            ; decopetorplayertargetted:="|<>7D7D7D-0.90$71.000000000000000000000000000000000000000000000000S0000G00S0U0W0000U00a1012xvqzgLV5zU25+4c+Id2OI04DsEHofz7jc08QEUgdJU8ME0F8FZNGN0EEU0wSxuSoXkUxk00000000000000000000000000000000000000000000000000000000000E"

                                                                            ; decopetorplayertargetted.="|<>*86$56.zzzzzzzzzzzzzzzzzzzzzzzzzzzzzyTzzzrjvzz3zzzzlwTzUTxyRyCDzk3m8WTl7zs0QFF7y3zw03081zlzy00zkTzsDz00TyDzwFzU0DzrzyCDk07zzzz7lw03zzzzvyzU1y000zzzw0zzzzzzzzcTzzzzzzzxDzzzzzzzzbzzzzzzzzzzzzzzzzy"

                                                                            ; if (ok:=FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, decopetorplayertargetted))
                                                                            ; {
                                                                            sendmessage, 0x100, ox1b, 0, , ahk_id %win1% ; esc_KEYDOWN
                                                                            Sleep, 50
                                                                            sendmessage, 0x101, ox1b, 0, , ahk_id %win1% ; esc_KEYUP
                                                                            sendmessage, 0x100, ox1b, 0, , ahk_id %win1% ; esc_KEYDOWN
                                                                            Sleep, 50
                                                                            sendmessage, 0x101, ox1b, 0, , ahk_id %win1% ; esc_KEYUP

                                                                            ;}
                                                                            arrived := false
                                                                        }

                                                                    }

                                                                    currentClickIndex++
                                                                    GuiControl,, StatusText, Status: Area %currentPullArea%, Click %currentClickIndex%/%areaClicksCount%
                                                                } else {
                                                                    if (autofolloww = true)
                                                                    {
                                                                        ReturnToMainCharacter()
                                                                    }

                                                                    ; NEW: DPS Logic after returning to character
                                                                    if (dpsEnabled && dpsHotkey != "") {
                                                                        GuiControl,, StatusText, Status: Executing DPS sequence...
                                                                        Sleep, 500 ; Small delay after returning to character
                                                                        ExecuteDpsSequence()
                                                                        GuiControl,, StatusText, Status: DPS sequence completed
                                                                        Sleep, 200 ; Small delay after DPS
                                                                    }

                                                                    currentPullArea++
                                                                    currentClickIndex := 1

                                                                    if (currentPullArea > pullAreas) {
                                                                        currentPullArea := 1
                                                                    }

                                                                    GuiControl,, StatusText, Status: Moving to area %currentPullArea%
                                                                }
                                                            return
                                                            StartWindowMonitor() {
                                                                global MonitorWindowID, BaselinePixels, MonitorActive

                                                                ; Use your existing selected window
                                                                MonitorWindowID := win1 ; Replace with your window variable

                                                                if (!MonitorWindowID || MonitorWindowID = "") {
                                                                    MsgBox, No window selected! Please select a window first.
                                                                    return
                                                                }

                                                                ; Take baseline screenshot of the area
                                                                TakeBaselineSnapshot()

                                                                if (BaselinePixels != "") {
                                                                    MonitorActive := true
                                                                    SetTimer, CheckWindowArea, 2000 ; Check every 2 seconds
                                                                    MsgBox, 0, Monitor, Window monitoring started! Baseline captured., 1
                                                                } else {
                                                                    MsgBox, 0, Monitor, Failed to capture baseline!, 2
                                                                }
                                                            }

                                                            ; Stop monitoring
                                                            StopWindowMonitor() {
                                                                global MonitorActive
                                                                MonitorActive := false
                                                                SetTimer, CheckWindowArea, Off
                                                                MsgBox, 0, Monitor, Window monitoring stopped!, 1
                                                            }

                                                            ; Take baseline screenshot using multiple pixel sampling
                                                            TakeBaselineSnapshot() {
                                                                global MonitorWindowID, BaselinePixels

                                                                ; Get window position
                                                                WinGetPos, winX, winY,,, ahk_id %MonitorWindowID%

                                                                if (winX = "" || winY = "") {
                                                                    BaselinePixels := ""
                                                                    return
                                                                }

                                                                ; Sample multiple pixels across the area for comparison
                                                                BaselinePixels := ""

                                                                ; Sample 9 points across the area (3x3 grid)
                                                                Loop, 3 {
                                                                    row := A_Index
                                                                    Loop, 3 {
                                                                        col := A_Index

                                                                        ; Calculate pixel position
                                                                        pixelX := winX + 8 + ((148-8) * col / 4)
                                                                        pixelY := winY + 28 + ((58-28) * row / 4)

                                                                        ; Get pixel color
                                                                        PixelGetColor, color, %pixelX%, %pixelY%, RGB
                                                                        BaselinePixels .= color . "|"
                                                                    }
                                                                }

                                                                ; Remove trailing |
                                                                BaselinePixels := RTrim(BaselinePixels, "|")
                                                            }

                                                            ; Check if area has changed
                                                            CheckWindowArea:
                                                                global MonitorWindowID, BaselinePixels, MonitorActive

                                                                if (!MonitorActive)
                                                                    return

                                                                ; Check if window still exists
                                                                WinGetPos, winX, winY,,, ahk_id %MonitorWindowID%

                                                                if (winX = "" || winY = "") {
                                                                    MsgBox, 0, Monitor, Target window lost - stopping monitor!, 2
                                                                    StopWindowMonitor()
                                                                    return
                                                                }

                                                                ; Sample the same pixels
                                                                CurrentPixels := ""

                                                                ; Sample same 9 points
                                                                Loop, 3 {
                                                                    row := A_Index
                                                                    Loop, 3 {
                                                                        col := A_Index

                                                                        ; Calculate pixel position
                                                                        pixelX := winX + 8 + ((148-8) * col / 4)
                                                                        pixelY := winY + 28 + ((58-28) * row / 4)

                                                                        ; Get pixel color
                                                                        PixelGetColor, color, %pixelX%, %pixelY%, RGB
                                                                        CurrentPixels .= color . "|"
                                                                    }
                                                                }

                                                                ; Remove trailing |
                                                                CurrentPixels := RTrim(CurrentPixels, "|")

                                                                ; Compare pixel patterns
                                                                if (CurrentPixels != BaselinePixels) {
                                                                    ; Area changed - reload script
                                                                    MsgBox, 0, Monitor, Area changed detected - Reloading script!, 1
                                                                    Reload
                                                                }
                                                            return
                                                            WaitForMovementStopold() {
                                                                if (!movementAreaSet)
                                                                    return

                                                                centerX := movementX1 + (movementX2 - movementX1) // 2
                                                                centerY := movementY1 + (movementY2 - movementY1) // 2

                                                                if (!movementArea2Set) {
                                                                    PixelGetColor, initialColor, %centerX%, %centerY%
                                                                    Loop, 20 {
                                                                        Sleep, 50
                                                                        PixelGetColor, currentColor, %centerX%, %centerY%
                                                                        if (currentColor != initialColor)
                                                                            break
                                                                    }
                                                                    Loop {
                                                                        PixelGetColor, color1, %centerX%, %centerY%
                                                                        Sleep, 50
                                                                        PixelGetColor, color2, %centerX%, %centerY%
                                                                        if (color1 = color2) {
                                                                            sleep, 120
                                                                            break
                                                                        }
                                                                    }
                                                                    return
                                                                }

                                                                center2X := movement2X1 + (movement2X2 - movement2X1) // 2
                                                                center2Y := movement2Y1 + (movement2Y2 - movement2Y1) // 2

                                                                PixelGetColor, initialColor, %centerX%, %centerY%
                                                                PixelGetColor, initial2Color, %center2X%, %center2Y%

                                                                Loop, 20{
                                                                    Sleep, 50
                                                                    PixelGetColor, currentColor, %centerX%, %centerY%
                                                                    if (currentColor != initialColor)
                                                                        break
                                                                    PixelGetColor, current2Color, %center2X%, %center2Y%
                                                                    if (current2Color != initial2Color)
                                                                        break
                                                                }

                                                                checkArea1 := true
                                                                Loop {
                                                                    if (checkArea1) {
                                                                        PixelGetColor, color1, %centerX%, %centerY%
                                                                        Sleep, 50
                                                                        PixelGetColor, color2, %centerX%, %centerY%
                                                                        if (color1 = color2) {
                                                                            sleep, 50
                                                                            break
                                                                        }
                                                                    } else {
                                                                        PixelGetColor, color1, %center2X%, %center2Y%
                                                                        Sleep, 50
                                                                        PixelGetColor, color2, %center2X%, %center2Y%
                                                                        if (color1 = color2) {
                                                                            sleep, 50
                                                                            break
                                                                        }
                                                                    }
                                                                    checkArea1 := !checkArea1
                                                                }
                                                            }

                                                            WaitForMovementStop() {
                                                                if (!movementAreaSet)
                                                                    return

                                                                centerX := movementX1 + (movementX2 - movementX1) // 2
                                                                centerY := movementY1 + (movementY2 - movementY1) // 2

                                                                ; Wait for movement to stop with stability checking
                                                                stabilityCount := 0
                                                                PixelGetColor, lastColor, %centerX%, %centerY%, RGB Fast

                                                                Loop {
                                                                    Sleep, 40
                                                                    PixelGetColor, currentColor, %centerX%, %centerY%, RGB Fast

                                                                    if (currentColor = lastColor) {
                                                                        stabilityCount++
                                                                        if (stabilityCount >= 4) { ; 4 stable readings = ~160ms stable
                                                                            break
                                                                        }
                                                                    } else {
                                                                        stabilityCount := 0
                                                                        lastColor := currentColor
                                                                    }
                                                                }

                                                                Sleep, 50 ; Small final delay
                                                            }

                                                            ReturnToMainCharacter() {
                                                                global selectedKey

                                                                selectedcharacteroptions := "|<>*74$17.zzzzzzzzzzzlE44F44IE0E04404EDxzzzzzzy003zzw"
                                                                selectedcharacteroptions .= "|<>**50$18.zzz51F8W90I108131V1X10q10Q1zzzU"

                                                                follow := "|<>**50$48.0000000000000000000000000000000007sT00000Dsz0000CBDpzz00FBxpjz00FBPJPh00FBLIvp00TBrIur00lhTJuP00UhMp7v00UjDzzy00UU000000zU000000U0000000U0000000U"
                                                                follow .= "|<>**50$49.ldyjzs004rnKTw002OqerO001B7Iup003aveR/U00PLpSak005f6crM002wzzzs00100000007U0000002"

                                                                ; Use the selected key from the dropdown (default F2)
                                                            keyToSend := selectedKey != "" ? selectedKey : "F2"
                                                                ControlSend,, {%keyToSend%}, ahk_id %win1% 
                                                                Sleep, 200

                                                                foundOptions := false
                                                                Loop, 20 {
                                                                    if (FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, selectedcharacteroptions)) {
                                                                        WinGetPos, winX, winY,,, ahk_id %win1%
                                                                        relativeX := X - winX
                                                                        relativeY := Y - winY
                                                                        ControlClick, x%relativeX% y%relativeY%, ahk_id %win1%
                                                                        Sleep, 10
                                                                        foundOptions := true
                                                                        break
                                                                    }
                                                                    Sleep, 50
                                                                }

                                                                if (!foundOptions)
                                                                    return

                                                                Loop, 20 {
                                                                    if (FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, follow)) {
                                                                        WinGetPos, winX, winY,,, ahk_id %win1%
                                                                        relativeX := X - winX
                                                                        relativeY := Y - winY
                                                                        ControlClick, x%relativeX% y%relativeY%, ahk_id %win1%
                                                                        Sleep, 10
                                                                        ; if (moving)
                                                                        ; {
                                                                        ;     WaitForMovementStop()
                                                                        ; }

                                                                        ; Sleep, %returnSleepTime%
                                                                        ; ControlSend,, {Escape}{Escape}{Escape}, ahk_id %win1% 
                                                                        break
                                                                    }
                                                                    Sleep, 50
                                                                }
                                                            }

                                                            Random(min, max) {
                                                                Random, result, %min%, %max%
                                                            return result
                                                        }

                                                        ; Function to set random KeyDelay

                                                        SetRandomKeyDelay() {
                                                            global

                                                            Random, delay, RandomKeyDelayMin, RandomKeyDelayMax
                                                            Random, pressDuration, RandomKeyPressDurationMin, RandomKeyPressDurationMax

                                                            CurrentKeyDelay := delay
                                                            CurrentPressDuration := pressDuration

                                                            SetKeyDelay, %delay%, %pressDuration%
                                                        }

                                                        ; Disable node/waypoint dragging - nodes and waypoints are click-through
                                                        ; SetTimer, MonitorNodeDragging, 50

                                                        MonitorNodeDragging:
                                                            ; Dragging disabled - nodes and waypoints are now click-through only
                                                        return

                                                        ; Old dragging code kept for reference but disabled
    /*
    ; Check if left mouse button is pressed over a node or waypoint GUI
    if (GetKeyState("LButton", "P")) {
        if (!NodeBeingDragged && !WaypointBeingDragged) {
            ; Check if mouse is over any node or waypoint GUI
            MouseGetPos,,, hoveredWin
            hoveredWinTitle := ""
            WinGetTitle, hoveredWinTitle, ahk_id %hoveredWin%
            
            ; Check if it's a target node GUI
            if (InStr(hoveredWinTitle, "TargetNode")) {
                ; Extract node ID from window title (format: "TargetNode1", "TargetNode2", etc.)
                nodeID := StrReplace(hoveredWinTitle, "TargetNode", "")
                if (nodeID > 0) {
                    NodeBeingDragged := true
                    DraggedNodeID := nodeID
                    ; Pause update timer while dragging
                    SetTimer, UpdateAllTargetNodes, Off
                }
            }
            ; Check if it's a waypoint GUI
            else if (InStr(hoveredWinTitle, "WaypointGUI")) {
                ; Extract waypoint index from window title (format: "WaypointGUI1", "WaypointGUI2", etc.)
                waypointIndex := StrReplace(hoveredWinTitle, "WaypointGUI", "")
                if (waypointIndex > 0) {
                    WaypointBeingDragged := true
                    DraggedWaypointIndex := waypointIndex
                    ; Pause update timer while dragging
                    SetTimer, UpdateAllWaypoints, Off
                }
            }
        }
    } else {
        ; Left button released
        if (NodeBeingDragged) {
            ; Update the world coordinates of the dragged node
            UpdateNodeWorldCoordinates(DraggedNodeID)
            NodeBeingDragged := false
            DraggedNodeID := 0
            ; Resume update timer after a longer delay to let position settle
            SetTimer, ResumeNodeUpdates, -1000
        }
        if (WaypointBeingDragged) {
            ; Update the world coordinates of the dragged waypoint
            UpdateWaypointWorldCoordinates(DraggedWaypointIndex)
            WaypointBeingDragged := false
            DraggedWaypointIndex := 0
            ; Resume update timer after a longer delay to let position settle
            SetTimer, ResumeWaypointUpdates, -1000
        }
    }
                                                        */
                                                        return

                                                        ResumeNodeUpdates:
                                                            if (TargetNodes.Length() > 0) {
                                                                SetTimer, UpdateAllTargetNodes, 500
                                                            }
                                                        return

                                                        ResumeWaypointUpdates:
                                                            if (Waypoints.Length() > 0) {
                                                                SetTimer, UpdateAllWaypoints, 500
                                                            }
                                                        return

                                                        WM_LBUTTONDOWN() {
                                                            PostMessage, 0xA1, 2
                                                        return
                                                    }

                                                    SetMovementMode:
                                                        Gui, Submit, NoHide
                                                        if (ClickMode) {
                                                            MovementMode := "click"
                                                            GuiControl,, MovementStatus, Mode: Click-to-Move
                                                        } else if (WASDMode) {
                                                            MovementMode := "wasd"
                                                            GuiControl,, MovementStatus, Mode: WASD Movement
                                                        }
                                                    return

                                                    SaveClickDistance:
                                                        Gui, Submit, NoHide
                                                        if (MaxClickEdit > 0 && MaxClickEdit <= 200) {
                                                            MaxClickDistance := MaxClickEdit
                                                            MsgBox, 0,, Max click distance set to %MaxClickDistance% pixels, 1
                                                        } else {
                                                            MsgBox, 0, Error, Please enter a value between 1-200 pixels!
                                                        }
                                                    return

                                                    SaveTolerance:
                                                        Gui, Submit, NoHide
                                                        if (ToleranceX > 0 && ToleranceY > 0) {
                                                            DistanceToleranceX := ToleranceX
                                                            DistanceToleranceY := ToleranceY
                                                            MsgBox, 0,, Tolerance set to X:%DistanceToleranceX% Y:%DistanceToleranceY%, 1
                                                        } else {
                                                            MsgBox, 0, Error, Please enter valid positive numbers!
                                                        }
                                                    return

                                                    WaypointCmds:
                                                        if (!SelectedRouteFile) {
                                                            MsgBox, 0, Error, Please select a route file first!
                                                            return
                                                        }
                                                        ShowWaypointCommandsGUI()
                                                    return

                                                    ShowWaypointCommandsGUI() {
                                                        global
                                                        Gui, Commands: New, +ToolWindow, Waypoint Commands
                                                        Gui, Commands: Color, 0x2d2d30
                                                        Gui, Commands: Font, s8 cWhite, Segoe UI

                                                        Gui, Commands: Add, Text, x10 y10 w400 h15 c0x007ACC Center, WAYPOINT COMMAND EDITOR

                                                        ; Waypoint selection section
                                                        Gui, Commands: Add, Text, x10 y35 w80 h15 cWhite, Waypoint Number:
                                                        Gui, Commands: Add, Edit, x95 y32 w40 h22 vWaypointNum Background0xFFFFFF cBlack
                                                        Gui, Commands: Add, Button, x140 y30 w70 h25 gLoadWaypointCmd, Load
                                                        Gui, Commands: Add, Button, x215 y30 w70 h25 gShowExamples, Examples
                                                        Gui, Commands: Add, Button, x290 y30 w70 h25 gListWaypoints, List Points

                                                        ; Command editing area
                                                        Gui, Commands: Add, Text, x10 y65 w400 h15 cWhite, Command Editor (simple commands, functions, and full scripts):
                                                        Gui, Commands: Add, Edit, x10 y85 w400 h140 vCommandText Multi VScroll Background0xFFFFFF cBlack

                                                        ; Action buttons
                                                        Gui, Commands: Add, Button, x10 y235 w75 h25 gSaveWaypointCmd, Save
                                                        Gui, Commands: Add, Button, x90 y235 w75 h25 gClearWaypointCmd, Clear
                                                        Gui, Commands: Add, Button, x170 y235 w75 h25 gTestWaypointCmd, Test
                                                        Gui, Commands: Add, Button, x330 y235 w80 h25 gCloseCommandGUI, Close

                                                        ; Status line
                                                        Gui, Commands: Add, Text, x10 y270 w400 h15 vCommandStatus cWhite, Ready to edit commands

                                                        Gui, Commands: Show, w420 h295
                                                    }

                                                    LoadWaypointCmd:
                                                        Gui, Commands: Submit, NoHide
                                                        if (WaypointNum && WaypointCommands.HasKey(WaypointNum)) {
                                                            GuiControl, Commands:, CommandText, % WaypointCommands[WaypointNum]
                                                            GuiControl, Commands:, CommandStatus, Loaded command for waypoint %WaypointNum%
                                                        } else {
                                                            ; Try loading directly from INI in case it wasn't loaded into memory
                                                            IniRead, command, %SelectedRouteFile%, Commands, Waypoint%WaypointNum%, ERROR
                                                            if (command != "ERROR") {
                                                                ; Convert delimiter back to newlines
                                                                command := StrReplace(command, "||NEWLINE||", "`n")
                                                                WaypointCommands[WaypointNum] := command
                                                                GuiControl, Commands:, CommandText, %command%
                                                                GuiControl, Commands:, CommandStatus, Loaded command for waypoint %WaypointNum%
                                                            } else {
                                                                GuiControl, Commands:, CommandText,
                                                                GuiControl, Commands:, CommandStatus, No command found for waypoint %WaypointNum%
                                                                }
                                                        }
                                                    return

                                                    SaveWaypointCmd:
                                                        Gui, Commands: Submit, NoHide
                                                        if (WaypointNum && CommandText) {
                                                            ; Convert newlines to a delimiter for INI storage
                                                            commandForStorage := StrReplace(CommandText, "`n", "||NEWLINE||")
                                                            commandForStorage := StrReplace(commandForStorage, "`r", "") ; Remove carriage returns

                                                            WaypointCommands[WaypointNum] := CommandText
                                                            ; Save command to the INI file with delimiter
                                                            IniWrite, %commandForStorage%, %SelectedRouteFile%, Commands, Waypoint%WaypointNum%
                                                            GuiControl, Commands:, CommandStatus, ✅ Command saved for waypoint %WaypointNum%
                                                                MsgBox, 0,, Command saved for waypoint %WaypointNum%, 1
                                                        } else {
                                                            GuiControl, Commands:, CommandStatus, ❌ Error: Please enter waypoint number and command!
                                                            MsgBox, 0, Error, Please enter waypoint number and command!
                                                        }
                                                    return

                                                    ClearWaypointCmd:
                                                        Gui, Commands: Submit, NoHide
                                                        if (WaypointNum && WaypointCommands.HasKey(WaypointNum)) {
                                                            WaypointCommands.Delete(WaypointNum)
                                                            ; Remove command from INI file
                                                            IniDelete, %SelectedRouteFile%, Commands, Waypoint%WaypointNum%
                                                            GuiControl, Commands:, CommandText,
                                                            GuiControl, Commands:, CommandStatus, 🗑️ Command cleared for waypoint %WaypointNum%
                                                                MsgBox, 0,, Command cleared for waypoint %WaypointNum%, 1
                                                        } else {
                                                            GuiControl, Commands:, CommandStatus, ❌ No command to clear for waypoint %WaypointNum%
                                                            }
                                                    return

                                                    ListWaypoints:
                                                        waypointCount := Waypoints.Length()
                                                        if (waypointCount = 0) {
                                                            GuiControl, Commands:, CommandStatus, ❌ No waypoints loaded in current route
                                                            return
                                                        }

                                                        waypointList := "Available waypoints:`n"
                                                        for index, waypoint in Waypoints {
                                                            hasCommand := WaypointCommands.HasKey(index) ? " 📝" : ""
                                                                waypointList .= "Waypoint " . index . ": X=" . waypoint.x . " Y=" . waypoint.y . hasCommand . "`n"
                                                            }

                                                            MsgBox, 0, Waypoint List, %waypointList%
                                                            return

                                                            TestWaypointCmd:
                                                                Gui, Commands: Submit, NoHide
                                                                if (CommandText) {
                                                                    MsgBox, 4,, Test this waypoint command?`n`nThis will execute the command immediately.
                                                                    IfMsgBox Yes
                                                                    {
                                                                        ; Create a temporary waypoint entry and execute it
                                                                        tempWaypoint := 999
                                                                        WaypointCommands[tempWaypoint] := CommandText
                                                                        ExecuteWaypointCommands(tempWaypoint)
                                                                        WaypointCommands.Delete(tempWaypoint)
                                                                    }
                                                                } else {
                                                                    MsgBox, 0, Error, Please enter a command to test!
                                                                }
                                                            return

                                                            ShowExamples:
                                                                exampleText := ""
                                                                exampleText .= "==== AVAILABLE COMMANDS ====`n`n"

                                                                exampleText .= "BASIC:`n"
                                                                exampleText .= " sleep,milliseconds - Wait/delay`n"
                                                                exampleText .= " send,{key} - Send keypress to active window`n"
                                                                exampleText .= " controlsend,{key} - Send key to game window (background)`n"
                                                                exampleText .= " msgbox,message - Show popup message`n"
                                                                exampleText .= " tooltip,text - Display tooltip`n"
                                                                exampleText .= " winactivate - Bring game window to front`n"
                                                                exampleText .= " coords - Show current coordinates`n`n"
                                                                exampleText .= " CheckAndExecuteTimerFlags() - Check and execute timer-based flags (AKA buffs/Dura/Etc)`n`n"

                                                                exampleText .= "CLICKING:`n"
                                                                exampleText .= " click,x,y - Click at screen coordinates`n"
                                                                exampleText .= " controlclick,x,y - Click at window coordinates (background)`n"
                                                                exampleText .= " holyground(delay, key, nodeNum) - Click at designated node`n"
                                                                exampleText .= " worldclick,nodeNum - Click at saved node location`n"
                                                                exampleText .= " shiftclick,nodeNum - Shift+click at node (for looting)`n`n"

                                                                exampleText .= "PATTERNS:`n"
                                                                exampleText .= " clickpattern,patternName - Find and click pattern`n"
                                                                exampleText .= " controlclickpattern,patternName - Find and ctrl+click pattern`n"
                                                                exampleText .= " loopclickuntilpatternfound,node1,node2,maxclickcount,pattern - Click nodes until pattern appears`n"
                                                                exampleText .= " loopclickuntilpatternmissing,node,pattern,max,back - Click until pattern gone`n"
                                                                exampleText .= " ifpatternfoundgoto,pattern,waypointNum - Skip to waypoint if pattern visible`n`n"
                                                                exampleText .= " loopsearchuntilpatternfound,tries,pattern:`n"

                                                                exampleText .= "COMBAT:`n"
                                                                exampleText .= " trycastheal - Cast heal skill (from patterns)`n"
                                                                exampleText .= " trycastdps - Cast DPS skill (with cooldown)`n"
                                                                exampleText .= " loopcastuntilmobdead - Auto-combat until mob dies`n"
                                                                exampleText .= " checkmobhealth - Check if mob health bar exists`n"
                                                                exampleText .= " farmuntilpattern,patternName - Tab+kill mobs until pattern shows`n`n"

                                                                exampleText .= "NAVIGATION:`n"
                                                                exampleText .= " gotowaypoint,waypointNum - Jump to specific waypoint`n"
                                                                exampleText .= " goto,waypointNum - Same as gotowaypoint`n"
                                                                exampleText .= " nextwaypoint - Skip to next waypoint`n"
                                                                exampleText .= " previouswaypoint - Go back one waypoint`n`n"

                                                                exampleText .= "SPECIAL:`n"
                                                                exampleText .= " sendhotkey,key - Trigger hotkey in other scripts`n"
                                                                exampleText .= " reenterbd5 - Auto re-enter BD dungeon`n`n"

                                                                exampleText .= "==== USAGE ====`n"
                                                                exampleText .= "Combine commands with | symbol:`n"
                                                                exampleText .= " sleep,1000 | send,{1} | worldclick,5`n`n"

                                                                exampleText .= "Use in waypoint commands field`n"
                                                                exampleText .= "or in route .ini files"

                                                                MsgBox, 0, Available Commands, %exampleText%
                                                            return

                                                            CloseCommandGUI:
                                                                Gui, Commands: Destroy
                                                            return

                                                            TransparencyChange:
                                                                Gui, Submit, NoHide
                                                                guiTransparency := TransparencySlider
                                                                GuiControl,, TransparencyText, %guiTransparency%
                                                                WinSet, Transparent, %guiTransparency%, Advanced Navigation Control
                                                            return

                                                            CheckWindowActivity:
                                                                if (TargetGameWindow) {
                                                                    WinGetActiveTitle, activeTitle
                                                                    WinGet, activeID, ID, A

                                                                    isTargetActive := (activeID = TargetGameWindow)
                                                                    isGUIActive := (activeTitle = "Advanced Navigation Control")
                                                                    shouldShowGUI := isTargetActive || isGUIActive

                                                                    if (shouldShowGUI && !WasWindowActive) {
                                                                        Gui, 1:Show,, Advanced Navigation Control
                                                                        WinSet, AlwaysOnTop, On, Advanced Navigation Control
                                                                    } else if (!shouldShowGUI && WasWindowActive) {
                                                                        WinSet, AlwaysOnTop, Off, Advanced Navigation Control
                                                                        Gui, 1:Hide
                                                                    }

                                                                    WasWindowActive := shouldShowGUI
                                                                }
                                                            return

                                                            UpdateCoordinatesDisplay:
                                                                if (TargetGameWindow) {
                                                                    GetCurrentCoordinates(coordX, coordY)
                                                                    if (coordX != "" && coordY != "") {
                                                                        GuiControl,, CurrentCoords, Current: X: %coordX% Y: %coordY%
                                                                    } else {
                                                                        GuiControl,, CurrentCoords, Current: X: --- Y: ---
                                                                    }
                                                                } else {
                                                                    GuiControl,, CurrentCoords, Current: X: --- Y: ---
                                                                }
                                                            return

                                                            UpdateRadiusGUI:
                                                                GuiControl,, RadiusEdit, %CameraRadius%
                                                            return

                                                            f8::
                                                                Gosub, AddWaypoint
                                                            return

                                                            ; f9::RecordCalibrationClick()  ; Disabled - calibration feature hidden

                                                            #If CameraLocked && TargetGameWindow && WinActive("ahk_id " . TargetGameWindow)
                                                            RButton::return
                                                        WheelUp::return
                                                        WheelDown::return
                                                        #If

                                                        ToggleWaypoints:
                                                            Gui, Submit, NoHide
                                                            ShowWaypoints := ShowWaypointsCheck

                                                            ; Show or hide all waypoint GUIs
                                                            for waypointIndex, guiName in WaypointGUIs {
                                                                if (ShowWaypoints) {
                                                                    Gui, %guiName%:Show, NA
                                                                } else {
                                                                    Gui, %guiName%:Hide
                                                                }
                                                            }
                                                        return

                                                        ToggleTargetNodes:
                                                            Gui, Submit, NoHide
                                                            ShowTargetNodes := ShowTargetNodesCheck

                                                            ; Show or hide all target node GUIs
                                                            for nodeID, guiName in NodeGUIs {
                                                                if (ShowTargetNodes) {
                                                                    Gui, %guiName%:Show, NA
                                                                } else {
                                                                    Gui, %guiName%:Hide
                                                                }
                                                            }
                                                        return

                                                        AddTargetNode:
                                                            if (!TargetGameWindow) {
                                                                MsgBox, No target window selected!
                                                                return
                                                            }

                                                            ; Cancel waypoint placement mode if active
                                                            if (PlacingWaypointMode) {
                                                                PlacingWaypointMode := false
                                                                SetTimer, CheckForWaypointPlacement, Off
                                                            }

                                                            ; Enable continuous placement mode like waypoints
                                                            PlacingNodeMode := true
                                                            ToolTip, Right-click in the game window to add target nodes. Press ESC to finish., 1
                                                            SetTimer, CheckForNodePlacement, 50
                                                        return

                                                        CheckForNodePlacement:
                                                            if (!PlacingNodeMode) {
                                                                SetTimer, CheckForNodePlacement, Off
                                                                ToolTip,, 1
                                                                return
                                                            }

                                                            ; Check for ESC to cancel
                                                            if (GetKeyState("Escape", "P")) {
                                                                PlacingNodeMode := false
                                                                SetTimer, CheckForNodePlacement, Off
                                                                ToolTip,, 1
                                                                return
                                                            }

                                                            ; Check if right mouse button is pressed
                                                            if (GetKeyState("RButton", "P")) {
                                                                ; Get mouse position when right-clicked (screen coordinates)
                                                                MouseGetPos, screenX, screenY, clickedWin

                                                                ; Verify click was in game window
                                                                if (clickedWin != TargetGameWindow) {
                                                                    ToolTip, Wrong window! Clicked: %clickedWin%`nTarget: %TargetGameWindow%, 1
                                                                    SetTimer, ClearTooltip, -3000
                                                                    KeyWait, RButton
                                                                    return
                                                                }

                                                                ; Get current player coordinates
                                                                GetCurrentCoordinates(playerX, playerY)
                                                                if (playerX = "" || playerY = "") {
                                                                    ToolTip, Could not get current coordinates!, 1
                                                                    KeyWait, RButton
                                                                    return
                                                                }

                                                                ; Get game window position (including title bar and borders)
                                                                WinGetPos, winX, winY, winW, winH, ahk_id %TargetGameWindow%

                                                                ; IMPORTANT: We need to use CoordMode to ensure we're getting screen coordinates
                                                                ; MouseGetPos already gives screen coords, which is what we want for GUI placement

                                                                ; Calculate pixel offset from character center (window-relative coordinates)
                                                                baseScreenX := winX + 516
                                                                baseScreenY := winY + 410
                                                                screenRelativeX := screenX - baseScreenX
                                                                screenRelativeY := screenY - baseScreenY

                                                                ; Reverse NavigateToCoordinatesClick calculations
                                                                ; NOTE: NavigateToCoordinatesClick uses "clickY = baseClickY - rotatedY" (MINUS!)
                                                                ; So to reverse: rotatedY = baseClickY - clickY = -(clickY - baseClickY) = -screenRelativeY
                                                                rotatedX := screenRelativeX
                                                                rotatedY := -screenRelativeY ; NEGATIVE because of the minus in NavigateToCoordinatesClick!

                                                                ; Undo rotation (inverse of NavigateToCoordinatesClick rotation with -CameraAngle)
                                                                cos_angle := Cos(-CameraAngle)
                                                                sin_angle := Sin(-CameraAngle)

                                                                ; Forward rotation: rotatedX = scaledX * cos - scaledY * sin
                                                                ; Forward rotation: rotatedY = scaledX * sin + scaledY * cos
                                                                ; Inverse: scaledX = rotatedX * cos + rotatedY * sin
                                                                ; Inverse: scaledY = -rotatedX * sin + rotatedY * cos
                                                                scaledX := rotatedX * cos_angle + rotatedY * sin_angle
                                                                scaledY := -rotatedX * sin_angle + rotatedY * cos_angle

                                                                ; Undo distance correction (NavigateToCoordinatesClick: scaledX *= 0.94, scaledY *= 1.19)
                                                                scaledX := scaledX / 0.94
                                                                scaledY := scaledY / 1.19

                                                                ; Calculate Y scaling (same formula as NavigateToCoordinatesClick)
                                                                if (CameraRadius <= 900) {
                                                                    pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                                } else if (CameraRadius <= 1000) {
                                                                    t := (CameraRadius - 900) / 100
                                                                    pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                                } else if (CameraRadius <= 1500) {
                                                                    t := (CameraRadius - 1000) / 500
                                                                    pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                                } else {
                                                                    t := (CameraRadius - 1500) / 500
                                                                    pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                                                }

                                                                ; Undo scaling (reverse of: scaledX = -deltaX * 1.21, scaledY = -deltaY * pixelsPerGameUnitY)
                                                                worldDeltaX := -scaledX / 1.21
                                                                worldDeltaY := -scaledY / pixelsPerGameUnitY

                                                                ; Calculate world coordinates
                                                                nodeWorldX := Round(playerX + worldDeltaX, 2)
                                                                nodeWorldY := Round(playerY + worldDeltaY, 2)

                                                                ; Get node ID (reuse deleted IDs if available)
                                                                if (AvailableNodeIDs.Length() > 0) {
                                                                    ; Pop the lowest available ID (get last item and remove it)
                                                                    nodeID := AvailableNodeIDs.Pop()
                                                                } else {
                                                                    ; No deleted IDs available, use next sequential ID
                                                                    nodeID := NextNodeID
                                                                    NextNodeID++
                                                                }

                                                                node := {id: nodeID, worldX: nodeWorldX, worldY: nodeWorldY}
                                                                TargetNodes.Push(node)

                                                                ; Create visual node directly at click position (not recalculated)
                                                                guiName := "TargetNode" . nodeID

                                                                ; Use global NodeSize variable
                                                                nodeW := NodeSize
                                                                nodeH := NodeSize

                                                                Gui, %guiName%:New, +AlwaysOnTop +ToolWindow -Caption
                                                                Gui, %guiName%:Color, FF0000
                                                                Gui, %guiName%:Font, s8 cWhite Bold
                                                                nodeIDText := nodeID
                                                                Gui, %guiName%:Add, Text, x0 y0 w%nodeW% h%nodeH% Center BackgroundTrans, %nodeIDText%

                                                                ; Place GUI at exact click position (MouseGetPos gives screen coords, which is what we need)
                                                                ; Center the node on the cursor
                                                                halfSize := NodeSize // 2
                                                                nodeX := screenX - halfSize
                                                                nodeY := screenY - halfSize

                                                                ; Show the GUI at the click position
                                                                Gui, %guiName%:Show, x%nodeX% y%nodeY% w%nodeW% h%nodeH% NoActivate
                                                                WinSet, Transparent, 150, %guiName%
                                                                ; Make it click-through using DllCall
                                                                WinGet, nodeHwnd, ID, %guiName%
                                                                ; Get current extended style
                                                                exStyle := DllCall("GetWindowLong", "Ptr", nodeHwnd, "Int", -20, "UInt")
                                                                ; Add WS_EX_TRANSPARENT (0x20) and WS_EX_LAYERED (0x80000)
                                                                exStyle := exStyle | 0x20 | 0x80000
                                                                ; Set the new extended style
                                                                DllCall("SetWindowLong", "Ptr", nodeHwnd, "Int", -20, "UInt", exStyle)

                                                                ; Store GUI name
                                                                NodeGUIs[nodeID] := guiName

                                                                ; Start update timer if not already running
                                                                SetTimer, UpdateAllTargetNodes, 500

                                                                ; Update status
                                                                nodeCount := TargetNodes.Length()
                                                                GuiControl,, NodeStatus, Nodes: %nodeCount% placed

                                                                ; Save nodes to file
                                                                SaveNodes()

                                                                ; Show confirmation and stay in placement mode
                                                                ToolTip, Node #%nodeID% placed at X:%nodeWorldX% Y:%nodeWorldY%`nRight-click for more or press ESC to finish, 1
                                                                    SetTimer, ClearTooltip, -2000

                                                                ; Wait for mouse button release before continuing
                                                                KeyWait, RButton

                                                                ; Stay in placement mode for adding more nodes
                                                            }
                                                        return

                                                        PlaceNodeAtClick:
                                                            ; This is now unused but kept for compatibility
                                                        return

                                                        ReloadNodes:
                                                            if (!SelectedRouteFile) {
                                                                MsgBox, No route file selected! Please select a route first.
                                                                return
                                                            }

                                                            ; Clear existing node GUIs
                                                            for nodeID in NodeGUIs {
                                                                guiName := NodeGUIs[nodeID]
                                                                if (guiName != "") {
                                                                    Gui, %guiName%:Destroy
                                                                    Sleep, 10
                                                                }
                                                            }

                                                            ; Clear arrays
                                                            TargetNodes := []
                                                            NodeGUIs := {}

                                                            ; Reload nodes from file
                                                            LoadNodes()

                                                            ; Update status
                                                            nodeCount := TargetNodes.Length()
                                                            GuiControl,, NodeStatus, Nodes: %nodeCount% placed

                                                            MsgBox, Nodes reloaded from file!`n%nodeCount% nodes loaded.
                                                        return

                                                        ClearAllNodes:
                                                            ; Destroy all node GUIs with delay to prevent errors
                                                            for nodeID in NodeGUIs {
                                                                guiName := NodeGUIs[nodeID]
                                                                if (guiName != "") {
                                                                    Gui, %guiName%:Destroy
                                                                    Sleep, 50 ; Add delay between destroying each GUI
                                                                }
                                                            }

                                                            ; Clear arrays
                                                            TargetNodes := []
                                                            NodeGUIs := {}
                                                            NextNodeID := 1
                                                            AvailableNodeIDs := []

                                                            ; Stop the update timer
                                                            SetTimer, UpdateAllTargetNodes, Off

                                                            ; Save cleared nodes to file
                                                            SaveNodes()

                                                            ; Update status
                                                            GuiControl,, NodeStatus, Nodes: 0 placed
                                                            MsgBox, All nodes cleared!
                                                        return

                                                        DeleteNode:
                                                            Gui, Submit, NoHide

                                                            if (DeleteNodeID = "" || DeleteNodeID < 1) {
                                                                MsgBox, Please enter a valid node ID number!
                                                                return
                                                            }

                                                            ; Find the node in the array
                                                            nodeIndex := 0
                                                            for index, node in TargetNodes {
                                                                if (node.id = DeleteNodeID) {
                                                                    nodeIndex := index
                                                                    break
                                                                }
                                                            }

                                                            if (nodeIndex = 0) {
                                                                MsgBox, Node #%DeleteNodeID% not found!
                                                                return
                                                            }

                                                            ; Destroy the GUI
                                                            guiName := NodeGUIs[DeleteNodeID]
                                                            if (guiName != "") {
                                                                Gui, %guiName%:Destroy
                                                            }

                                                            ; Remove from arrays
                                                            TargetNodes.RemoveAt(nodeIndex)
                                                            NodeGUIs.Delete(DeleteNodeID)

                                                            ; Add the deleted ID to available IDs (for reuse) and sort
                                                            AvailableNodeIDs.Push(DeleteNodeID)

                                                            ; Sort available IDs in descending order (so we pop the lowest)
                                                            Loop % AvailableNodeIDs.Length() - 1 {
                                                                i := A_Index
                                                                Loop % AvailableNodeIDs.Length() - i {
                                                                    j := A_Index
                                                                    if (AvailableNodeIDs[j] < AvailableNodeIDs[j+1]) {
                                                                        temp := AvailableNodeIDs[j]
                                                                        AvailableNodeIDs[j] := AvailableNodeIDs[j+1]
                                                                        AvailableNodeIDs[j+1] := temp
                                                                    }
                                                                }
                                                            }

                                                            ; Save to file
                                                            SaveNodes()

                                                            ; Update status
                                                            nodeCount := TargetNodes.Length()
                                                            GuiControl,, NodeStatus, Nodes: %nodeCount% placed
                                                            GuiControl,, DeleteNodeID, ; Clear the input field

                                                            ;MsgBox, Node #%DeleteNodeID% deleted!
                                                        return

                                                        ApplyClickThrough:
                                                            ; Manually apply click-through to all existing node and waypoint GUIs
                                                            fixedCount := 0

                                                            ; Fix all node GUIs
                                                            for nodeID, guiName in NodeGUIs {
                                                                WinGet, hwnd, ID, %guiName%
                                                                if (hwnd) {
                                                                    MakeWindowClickThroughByHandle(hwnd)
                                                                    fixedCount++
                                                                }
                                                            }

                                                            ; Fix all waypoint GUIs
                                                            for waypointIndex, guiName in WaypointGUIs {
                                                                WinGet, hwnd, ID, %guiName%
                                                                if (hwnd) {
                                                                    MakeWindowClickThroughByHandle(hwnd)
                                                                    fixedCount++
                                                                }
                                                            }

                                                            MsgBox, Applied click-through to %fixedCount% windows!
                                                        return

                                                        DebugCalibration:
                                                            ; Create debugnav.ini path
                                                            debugINI := A_ScriptDir . "\debugnav.ini"

                                                            ; Auto-sync TargetGameWindow with win1 if not set
                                                            if (!TargetGameWindow && win1) {
                                                                TargetGameWindow := win1
                                                            }

                                                            if (!TargetGameWindow) {
                                                                MsgBox, No game window selected! Please select a window first.
                                                                return
                                                            }

                                                            ; Step 1: Capture current position
                                                            MsgBox, 64, Debug Calibration - Step 1, Step 1: Stand at your current position.`n`nPress OK when ready to capture your coordinates.

                                                            GetCurrentCoordinates(startX, startY)
                                                            if (startX = "" || startY = "") {
                                                                MsgBox, 16, Error, Could not read coordinates! Make sure they are visible.
                                                                return
                                                            }

                                                            MsgBox, 64, Captured, Starting Position Captured:`nX: %startX%`nY: %startY%`n`nNow move your character to a new position.

                                                            ; Step 2: Move and capture new position
                                                            MsgBox, 64, Debug Calibration - Step 2, Step 2: Move to a new position (recommend 50-100 units away).`n`nPress OK when ready to capture new coordinates.

                                                            GetCurrentCoordinates(endX, endY)
                                                            if (endX = "" || endY = "") {
                                                                MsgBox, 16, Error, Could not read coordinates! Make sure they are visible.
                                                                return
                                                            }

                                                            ; Step 3: Right-click where you moved to
                                                            MsgBox, 64, Debug Calibration - Step 3, New Position Captured:`nX: %endX%`nY: %endY%`n`nNow RIGHT-CLICK on the exact spot your character is standing.

                                                            ; Activate the game window
                                                            ;WinActivate, ahk_id %TargetGameWindow%
                                                            Sleep, 200

                                                            ; Wait for right-click
                                                            KeyWait, RButton, D

                                                            ; Get the click position
                                                            CoordMode, Mouse, Screen
                                                            MouseGetPos, clickX, clickY, clickWinID

                                                            if (clickWinID != TargetGameWindow) {
                                                                MsgBox, Click was not in the game window! Calibration cancelled.
                                                                return
                                                            }

                                                            ; Get window position
                                                            WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%

                                                            ; Calculate window-relative click position
                                                            relativeClickX := clickX - winX
                                                            relativeClickY := clickY - winY

                                                            ; Calculate deltas
                                                            worldDeltaX := endX - startX
                                                            worldDeltaY := endY - startY

                                                            ; ===== COMPREHENSIVE COORDINATE CONVERSION CALCULATIONS =====

                                                            ; Base screen center
                                                            baseScreenX := winX + 516
                                                            baseScreenY := winY + 410

                                                            ; Screen pixel deltas from center
                                                            pixelDeltaX := clickX - baseScreenX
                                                            pixelDeltaY := clickY - baseScreenY

                                                            ; Calculate Y scaling based on camera radius (EXACT copy from AddTargetNode)
                                                            if (CameraRadius <= 900) {
                                                                pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                            } else if (CameraRadius <= 1000) {
                                                                t := (CameraRadius - 900) / (1000 - 900)
                                                                pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                            } else if (CameraRadius <= 1500) {
                                                                t := (CameraRadius - 1000) / (1500 - 1000)
                                                                pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                            } else {
                                                                pixelsPerGameUnitY := 0.75
                                                            }

                                                            ; Inverse rotation (undo camera angle)
                                                            cos_angle := Cos(CameraAngle)
                                                            sin_angle := Sin(CameraAngle)
                                                            unrotatedX := pixelDeltaX * cos_angle + pixelDeltaY * sin_angle
                                                            unrotatedY := -pixelDeltaX * sin_angle + pixelDeltaY * cos_angle

                                                            ; Undo distance correction
                                                            unscaledX := unrotatedX / 0.94
                                                            unscaledY := unrotatedY / 1.19

                                                            ; Undo base scaling to get world deltas
                                                            calculatedWorldDeltaX := -unscaledX / 1.21
                                                            calculatedWorldDeltaY := unscaledY / pixelsPerGameUnitY

                                                            ; Calculate what the world coordinates SHOULD be based on the click
                                                            calculatedWorldX := startX + calculatedWorldDeltaX
                                                            calculatedWorldY := startY + calculatedWorldDeltaY

                                                            ; Calculate the error between where we are vs where click says we should be
                                                            errorWorldX := endX - calculatedWorldX
                                                            errorWorldY := endY - calculatedWorldY

                                                            ; Calculate what screen position the endX/endY SHOULD produce
                                                            ; (Forward conversion to verify)
                                                            forwardDeltaX := endX - startX
                                                            forwardDeltaY := endY - startY

                                                            ; Apply base scaling
                                                            forwardScaledX := -forwardDeltaX * 1.21
                                                            forwardScaledY := forwardDeltaY * pixelsPerGameUnitY

                                                            ; Apply distance correction
                                                            forwardScaledX := forwardScaledX * 0.94
                                                            forwardScaledY := forwardScaledY * 1.19

                                                            ; Apply rotation
                                                            forwardRotatedX := forwardScaledX * cos_angle - forwardScaledY * sin_angle
                                                            forwardRotatedY := forwardScaledX * sin_angle + forwardScaledY * cos_angle

                                                            ; Calculate expected screen position
                                                            expectedScreenX := baseScreenX + Round(forwardRotatedX)
                                                            expectedScreenY := baseScreenY + Round(forwardRotatedY)

                                                            ; Calculate screen position error
                                                            screenErrorX := clickX - expectedScreenX
                                                            screenErrorY := clickY - expectedScreenY

                                                            ; ===== SAVE ALL DATA TO INI =====
                                                            FileEncoding, UTF-8

                                                            ; Clear existing file
                                                            FileDelete, %debugINI%

                                                            ; Write starting position
                                                            IniWrite, %startX%, %debugINI%, Position1, WorldX
                                                            IniWrite, %startY%, %debugINI%, Position1, WorldY

                                                            ; Write ending position (actual)
                                                            IniWrite, %endX%, %debugINI%, Position2_Actual, WorldX
                                                            IniWrite, %endY%, %debugINI%, Position2_Actual, WorldY

                                                            ; Write calculated position (from click)
                                                            IniWrite, %calculatedWorldX%, %debugINI%, Position2_Calculated, WorldX
                                                            IniWrite, %calculatedWorldY%, %debugINI%, Position2_Calculated, WorldY

                                                            ; Write click data
                                                            IniWrite, %clickX%, %debugINI%, Click, ScreenX
                                                            IniWrite, %clickY%, %debugINI%, Click, ScreenY
                                                            IniWrite, %relativeClickX%, %debugINI%, Click, WindowRelativeX
                                                            IniWrite, %relativeClickY%, %debugINI%, Click, WindowRelativeY

                                                            ; Write expected screen position
                                                            IniWrite, %expectedScreenX%, %debugINI%, ExpectedClick, ScreenX
                                                            IniWrite, %expectedScreenY%, %debugINI%, ExpectedClick, ScreenY

                                                            ; Write deltas (actual movement)
                                                            IniWrite, %worldDeltaX%, %debugINI%, Deltas_Actual, WorldDeltaX
                                                            IniWrite, %worldDeltaY%, %debugINI%, Deltas_Actual, WorldDeltaY

                                                            ; Write calculated deltas (from click conversion)
                                                            IniWrite, %calculatedWorldDeltaX%, %debugINI%, Deltas_Calculated, WorldDeltaX
                                                            IniWrite, %calculatedWorldDeltaY%, %debugINI%, Deltas_Calculated, WorldDeltaY

                                                            ; Write errors
                                                            IniWrite, %errorWorldX%, %debugINI%, Errors, WorldErrorX
                                                            IniWrite, %errorWorldY%, %debugINI%, Errors, WorldErrorY
                                                            IniWrite, %screenErrorX%, %debugINI%, Errors, ScreenErrorX
                                                            IniWrite, %screenErrorY%, %debugINI%, Errors, ScreenErrorY

                                                            ; Write intermediate calculations
                                                            IniWrite, %pixelDeltaX%, %debugINI%, Intermediate, PixelDeltaX_FromCenter
                                                            IniWrite, %pixelDeltaY%, %debugINI%, Intermediate, PixelDeltaY_FromCenter
                                                            IniWrite, %unrotatedX%, %debugINI%, Intermediate, UnrotatedX
                                                            IniWrite, %unrotatedY%, %debugINI%, Intermediate, UnrotatedY
                                                            IniWrite, %unscaledX%, %debugINI%, Intermediate, UnscaledX
                                                            IniWrite, %unscaledY%, %debugINI%, Intermediate, UnscaledY
                                                            IniWrite, %pixelsPerGameUnitY%, %debugINI%, Intermediate, PixelsPerGameUnitY

                                                            ; Write window position
                                                            IniWrite, %winX%, %debugINI%, Window, X
                                                            IniWrite, %winY%, %debugINI%, Window, Y
                                                            IniWrite, %baseScreenX%, %debugINI%, Window, BaseCenterX
                                                            IniWrite, %baseScreenY%, %debugINI%, Window, BaseCenterY

                                                            ; Write camera data
                                                            IniWrite, %CameraAngle%, %debugINI%, Camera, Angle
                                                            IniWrite, %CameraRadius%, %debugINI%, Camera, Radius
                                                            IniWrite, %cos_angle%, %debugINI%, Camera, CosAngle
                                                            IniWrite, %sin_angle%, %debugINI%, Camera, SinAngle

                                                            FileEncoding

                                                            ; Show comprehensive summary
                                                            summaryMsg := "DEBUG CALIBRATION SAVED to debugnav.ini`n`n"
                                                            summaryMsg .= "=== WORLD POSITIONS ===`n"
                                                            summaryMsg .= "Start: X=" . startX . " Y=" . startY . "`n"
                                                            summaryMsg .= "End (Actual): X=" . endX . " Y=" . endY . "`n"
                                                            summaryMsg .= "End (Calculated from click): X=" . Round(calculatedWorldX, 2) . " Y=" . Round(calculatedWorldY, 2) . "`n"
                                                            summaryMsg .= "Actual Delta: X=" . Round(worldDeltaX, 2) . " Y=" . Round(worldDeltaY, 2) . "`n"
                                                            summaryMsg .= "Calculated Delta: X=" . Round(calculatedWorldDeltaX, 2) . " Y=" . Round(calculatedWorldDeltaY, 2) . "`n`n"
                                                            summaryMsg .= "=== WORLD COORDINATE ERROR ===`n"
                                                            summaryMsg .= "Error X: " . Round(errorWorldX, 2) . " units`n"
                                                            summaryMsg .= "Error Y: " . Round(errorWorldY, 2) . " units`n`n"
                                                            summaryMsg .= "=== SCREEN POSITIONS ===`n"
                                                            summaryMsg .= "Click (Actual): X=" . clickX . " Y=" . clickY . "`n"
                                                            summaryMsg .= "Click (Expected): X=" . expectedScreenX . " Y=" . expectedScreenY . "`n"
                                                            summaryMsg .= "Screen Error: X=" . screenErrorX . " Y=" . screenErrorY . " pixels`n"
                                                            summaryMsg .= "Window Relative: X=" . relativeClickX . " Y=" . relativeClickY . "`n`n"
                                                            summaryMsg .= "=== CAMERA ===`n"
                                                            summaryMsg .= "Angle: " . Round(CameraAngle, 4) . "`n"
                                                            summaryMsg .= "Radius: " . CameraRadius . "`n"
                                                            summaryMsg .= "Y Scale Factor: " . Round(pixelsPerGameUnitY, 4)

                                                            MsgBox, 64, Calibration Complete, %summaryMsg%
                                                        return

                                                        DebugNodeClicks:
                                                            ; Create debugnodes.ini path
                                                            debugNodesINI := A_ScriptDir . "\debugnodes.ini"

                                                            ; Auto-sync TargetGameWindow with win1 if not set
                                                            if (!TargetGameWindow && win1) {
                                                                TargetGameWindow := win1
                                                            }

                                                            if (!TargetGameWindow) {
                                                                MsgBox, No game window selected! Please select a window first.
                                                                return
                                                            }

                                                            ; Clear existing file
                                                            FileDelete, %debugNodesINI%
                                                            FileEncoding, UTF-8

                                                            ; Capture starting position
                                                            GetCurrentCoordinates(startX, startY)
                                                            if (startX = "" || startY = "") {
                                                                MsgBox, 16, Error, Could not read starting coordinates!
                                                                return
                                                            }

                                                            IniWrite, %startX%, %debugNodesINI%, Start, WorldX
                                                            IniWrite, %startY%, %debugNodesINI%, Start, WorldY
                                                            IniWrite, %CameraAngle%, %debugNodesINI%, Start, CameraAngle
                                                            IniWrite, %CameraRadius%, %debugNodesINI%, Start, CameraRadius

                                                            ; Get window position
                                                            WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                                            IniWrite, %winX%, %debugNodesINI%, Window, X
                                                            IniWrite, %winY%, %debugNodesINI%, Window, Y

                                                            ; Process 3 nodes
                                                            Loop, 3 {
                                                                nodeNum := A_Index

                                                                ; Step 1: Ask user to place node
                                                                MsgBox, 64, Node %nodeNum% - Step 1, Node %nodeNum%: RIGHT-CLICK to place a temporary node where you want to test.

                                                                ;WinActivate, ahk_id %TargetGameWindow%
                                                                Sleep, 200

                                                                ; Wait for right-click to place node
                                                                KeyWait, RButton, D
                                                                CoordMode, Mouse, Screen
                                                                MouseGetPos, placeClickX, placeClickY, clickWinID

                                                                if (clickWinID != TargetGameWindow) {
                                                                    MsgBox, Click was not in game window! Debug cancelled.
                                                                    return
                                                                }

                                                                ; Save placement click position
                                                                IniWrite, %placeClickX%, %debugNodesINI%, Node%nodeNum%, PlaceClickX
                                                                IniWrite, %placeClickY%, %debugNodesINI%, Node%nodeNum%, PlaceClickY

                                                                ; Calculate world coordinates using our inverse conversion
                                                                baseScreenX := winX + 516
                                                                baseScreenY := winY + 410
                                                                screenRelativeX := placeClickX - baseScreenX
                                                                screenRelativeY := placeClickY - baseScreenY

                                                                rotatedX := screenRelativeX
                                                                rotatedY := screenRelativeY

                                                                cos_angle := Cos(-CameraAngle)
                                                                sin_angle := Sin(-CameraAngle)

                                                                scaledX := rotatedX * cos_angle + rotatedY * sin_angle
                                                                scaledY := -rotatedX * sin_angle + rotatedY * cos_angle

                                                                scaledX := scaledX / 0.94
                                                                scaledY := scaledY / 1.19

                                                                if (CameraRadius <= 900) {
                                                                    pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                                } else if (CameraRadius <= 1000) {
                                                                    t := (CameraRadius - 900) / 100
                                                                    pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                                } else if (CameraRadius <= 1500) {
                                                                    t := (CameraRadius - 1000) / 500
                                                                    pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                                } else {
                                                                    t := (CameraRadius - 1500) / 500
                                                                    pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                                                }

                                                                worldDeltaX := -scaledX / 1.21
                                                                worldDeltaY := -scaledY / pixelsPerGameUnitY

                                                                calculatedWorldX := Round(startX + worldDeltaX, 2)
                                                                calculatedWorldY := Round(startY + worldDeltaY, 2)

                                                                IniWrite, %calculatedWorldX%, %debugNodesINI%, Node%nodeNum%, CalculatedWorldX
                                                                IniWrite, %calculatedWorldY%, %debugNodesINI%, Node%nodeNum%, CalculatedWorldY

                                                                ; Create a visible hollow bounding box at the click position (30x30 box)
                                                                boxSize := 30
                                                                halfSize := boxSize // 2
                                                                boxX := placeClickX - halfSize
                                                                boxY := placeClickY - halfSize
                                                                borderThickness := 2

                                                                ; Top border
                                                                topGuiName := "DebugNode" . nodeNum . "Top"
                                                                Gui, %topGuiName%:New, +AlwaysOnTop +ToolWindow -Caption +E0x20
                                                                Gui, %topGuiName%:Color, 0000FF
                                                                Gui, %topGuiName%:Show, x%boxX% y%boxY% w%boxSize% h%borderThickness% NoActivate
                                                                WinSet, Transparent, 200, %topGuiName%

                                                                ; Bottom border
                                                                bottomY := boxY + boxSize - borderThickness
                                                                bottomGuiName := "DebugNode" . nodeNum . "Bottom"
                                                                Gui, %bottomGuiName%:New, +AlwaysOnTop +ToolWindow -Caption +E0x20
                                                                Gui, %bottomGuiName%:Color, 0000FF
                                                                Gui, %bottomGuiName%:Show, x%boxX% y%bottomY% w%boxSize% h%borderThickness% NoActivate
                                                                WinSet, Transparent, 200, %bottomGuiName%

                                                                ; Left border
                                                                leftGuiName := "DebugNode" . nodeNum . "Left"
                                                                Gui, %leftGuiName%:New, +AlwaysOnTop +ToolWindow -Caption +E0x20
                                                                Gui, %leftGuiName%:Color, 0000FF
                                                                Gui, %leftGuiName%:Show, x%boxX% y%boxY% w%borderThickness% h%boxSize% NoActivate
                                                                WinSet, Transparent, 200, %leftGuiName%

                                                                ; Right border
                                                                rightX := boxX + boxSize - borderThickness
                                                                rightGuiName := "DebugNode" . nodeNum . "Right"
                                                                Gui, %rightGuiName%:New, +AlwaysOnTop +ToolWindow -Caption +E0x20
                                                                Gui, %rightGuiName%:Color, 0000FF
                                                                Gui, %rightGuiName%:Show, x%rightX% y%boxY% w%borderThickness% h%boxSize% NoActivate
                                                                WinSet, Transparent, 200, %rightGuiName%

                                                                ; Add number label in the center
                                                                labelX := placeClickX - 8
                                                                labelY := placeClickY - 8
                                                                labelGuiName := "DebugNode" . nodeNum . "Label"
                                                                Gui, %labelGuiName%:New, +AlwaysOnTop +ToolWindow -Caption +E0x20
                                                                Gui, %labelGuiName%:Color, 0x000000
                                                                Gui, %labelGuiName%:Font, s10 cBlue Bold
                                                                Gui, %labelGuiName%:Add, Text, x0 y0 w16 h16 Center BackgroundTrans, %nodeNum%
                                                                Gui, %labelGuiName%:Show, x%labelX% y%labelY% w16 h16 NoActivate
                                                                WinSet, Transparent, 200, %labelGuiName%

                                                                Sleep, 500

                                                                ; Step 2: Click at the calculated world coordinates using ClickAtWorldCoordinates
                                                                MsgBox, 64, Node %nodeNum% - Step 2, Node %nodeNum%: The script will now click at the calculated world coordinates using ClickAtWorldCoordinates (same as worldclick command).`n`nWatch where it clicks!

                                                                ; Destroy the bounding box before clicking so it doesn't interfere with visibility
                                                                guiName := "DebugNode" . nodeNum . "Top"
                                                                Gui, %guiName%:Destroy
                                                                guiName := "DebugNode" . nodeNum . "Bottom"
                                                                Gui, %guiName%:Destroy
                                                                guiName := "DebugNode" . nodeNum . "Left"
                                                                Gui, %guiName%:Destroy
                                                                guiName := "DebugNode" . nodeNum . "Right"
                                                                Gui, %guiName%:Destroy
                                                                guiName := "DebugNode" . nodeNum . "Label"
                                                                Gui, %guiName%:Destroy

                                                                ; Use ClickAtWorldCoordinates to see where it actually clicks (same as worldclick command)
                                                                ClickAtWorldCoordinates(calculatedWorldX, calculatedWorldY)

                                                                Sleep, 1000

                                                                ; Step 3: Ask user to click where it actually should be
                                                                MsgBox, 64, Node %nodeNum% - Step 3, Node %nodeNum%: Now RIGHT-CLICK on the CENTER of where the node actually is (where your character moved to).

                                                                ;WinActivate, ahk_id %TargetGameWindow%
                                                                Sleep, 200

                                                                KeyWait, RButton, D
                                                                MouseGetPos, actualClickX, actualClickY, clickWinID2

                                                                if (clickWinID2 <> TargetGameWindow) {
                                                                    MsgBox, Click was not in game window! Debug cancelled.
                                                                    return
                                                                }

                                                                IniWrite, %actualClickX%, %debugNodesINI%, Node%nodeNum%, ActualCenterClickX
                                                                IniWrite, %actualClickY%, %debugNodesINI%, Node%nodeNum%, ActualCenterClickY

                                                                ; Calculate error
                                                                errorX := actualClickX - placeClickX
                                                                errorY := actualClickY - placeClickY

                                                                IniWrite, %errorX%, %debugNodesINI%, Node%nodeNum%, ErrorPixelsX
                                                                IniWrite, %errorY%, %debugNodesINI%, Node%nodeNum%, ErrorPixelsY

                                                                ; Capture current world position after movement
                                                                Sleep, 500
                                                                GetCurrentCoordinates(afterWorldX, afterWorldY)
                                                                if (afterWorldX != "" && afterWorldY != "") {
                                                                    IniWrite, %afterWorldX%, %debugNodesINI%, Node%nodeNum%, ActualWorldX
                                                                    IniWrite, %afterWorldY%, %debugNodesINI%, Node%nodeNum%, ActualWorldY

                                                                    worldErrorX := afterWorldX - calculatedWorldX
                                                                    worldErrorY := afterWorldY - calculatedWorldY

                                                                    IniWrite, %worldErrorX%, %debugNodesINI%, Node%nodeNum%, WorldErrorX
                                                                    IniWrite, %worldErrorY%, %debugNodesINI%, Node%nodeNum%, WorldErrorY
                                                                }

                                                                Sleep, 500
                                                            }

                                                            ; Clean up temporary debug node bounding boxes
                                                            Loop, 3 {
                                                                nodeNum := A_Index
                                                                guiName := "DebugNode" . nodeNum . "Top"
                                                                Gui, %guiName%:Destroy
                                                                guiName := "DebugNode" . nodeNum . "Bottom"
                                                                Gui, %guiName%:Destroy
                                                                guiName := "DebugNode" . nodeNum . "Left"
                                                                Gui, %guiName%:Destroy
                                                                guiName := "DebugNode" . nodeNum . "Right"
                                                                Gui, %guiName%:Destroy
                                                                guiName := "DebugNode" . nodeNum . "Label"
                                                                Gui, %guiName%:Destroy
                                                            }

                                                            FileEncoding

                                                            MsgBox, 64, Debug Complete, Debug data saved to debugnodes.ini!`n`nCheck the file for click accuracy data for all 3 nodes.
                                                                return

                                                        MoveWaypointByNumber:
                                                            ; Ask user for waypoint number
                                                            InputBox, waypointNumToMove, Move Waypoint, Enter the waypoint number to move:, , 300, 150
                                                            if (ErrorLevel) {
                                                                return ; User cancelled
                                                            }

                                                            ; Validate input
                                                            if (waypointNumToMove = "" || waypointNumToMove < 1) {
                                                                MsgBox, Invalid waypoint number!
                                                                return
                                                            }

                                                            ; Check if waypoint exists
                                                            waypointCount := Waypoints.Length()
                                                            if (waypointNumToMove > waypointCount) {
                                                                MsgBox, Waypoint #%waypointNumToMove% does not exist! (Only %waypointCount% waypoints in current path)
                                                                return
                                                            }

                                                            ; Auto-sync TargetGameWindow with win1 if not set
                                                            if (!TargetGameWindow && win1) {
                                                                TargetGameWindow := win1
                                                            }

                                                            if (!TargetGameWindow) {
                                                                MsgBox, No game window selected! Please select a window first.
                                                                return
                                                            }

                                                            ; Activate the game window
                                                            WinActivate, ahk_id %TargetGameWindow%
                                                            Sleep, 200

                                                            ; Show instruction
                                                            MsgBox, 64, Move Waypoint, Right-click on the new position for waypoint #%waypointNumToMove% in the game window., 3

                                                            ; Wait for right-click
                                                            KeyWait, RButton, D

                                                            ; Get the click position (use CoordMode to ensure we get screen coordinates)
                                                            CoordMode, Mouse, Screen
                                                            MouseGetPos, clickX, clickY, clickWinID

                                                            ; Verify click was in game window
                                                            if (clickWinID != TargetGameWindow) {
                                                                MsgBox, Click was not in the game window! Move cancelled.
                                                                return
                                                            }

                                                            ; Get current player coordinates
                                                            GetCurrentCoordinates(playerX, playerY)
                                                            if (playerX = "" || playerY = "") {
                                                                MsgBox, Could not read current coordinates! Make sure coordinates are visible.
                                                                return
                                                            }

                                                            ; Get game window position
                                                            WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%

                                                            ; Calculate pixel offset from character center (window-relative coordinates)
                                                            baseScreenX := winX + 516
                                                            baseScreenY := winY + 410
                                                            screenRelativeX := clickX - baseScreenX
                                                            screenRelativeY := clickY - baseScreenY

                                                            ; Reverse NavigateToCoordinatesClick calculations
                                                            ; NOTE: NavigateToCoordinatesClick uses "clickY = baseClickY - rotatedY" (MINUS!)
                                                            ; So to reverse: rotatedY = baseClickY - clickY = -(clickY - baseClickY) = -screenRelativeY
                                                            rotatedX := screenRelativeX
                                                            rotatedY := -screenRelativeY ; NEGATIVE because of the minus in NavigateToCoordinatesClick!

                                                            ; Undo rotation (inverse of NavigateToCoordinatesClick rotation with -CameraAngle)
                                                            cos_angle := Cos(-CameraAngle)
                                                            sin_angle := Sin(-CameraAngle)

                                                            ; Forward rotation: rotatedX = scaledX * cos - scaledY * sin
                                                            ; Forward rotation: rotatedY = scaledX * sin + scaledY * cos
                                                            ; Inverse: scaledX = rotatedX * cos + rotatedY * sin
                                                            ; Inverse: scaledY = -rotatedX * sin + rotatedY * cos
                                                            scaledX := rotatedX * cos_angle + rotatedY * sin_angle
                                                            scaledY := -rotatedX * sin_angle + rotatedY * cos_angle

                                                            ; Undo distance correction (NavigateToCoordinatesClick: scaledX *= 0.94, scaledY *= 1.19)
                                                            scaledX := scaledX / 0.94
                                                            scaledY := scaledY / 1.19

                                                            ; Calculate Y scaling (same formula as NavigateToCoordinatesClick)
                                                            if (CameraRadius <= 900) {
                                                                pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                            } else if (CameraRadius <= 1000) {
                                                                t := (CameraRadius - 900) / 100
                                                                pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                            } else if (CameraRadius <= 1500) {
                                                                t := (CameraRadius - 1000) / 500
                                                                pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                            } else {
                                                                t := (CameraRadius - 1500) / 500
                                                                pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                                            }

                                                            ; Undo scaling (reverse of: scaledX = -deltaX * 1.21, scaledY = -deltaY * pixelsPerGameUnitY)
                                                            worldDeltaX := -scaledX / 1.21
                                                            worldDeltaY := -scaledY / pixelsPerGameUnitY

                                                            ; Calculate world coordinates
                                                            newWorldX := Round(playerX + worldDeltaX, 2)
                                                            newWorldY := Round(playerY + worldDeltaY, 2)

                                                            ; Update the waypoint
                                                            Waypoints[waypointNumToMove].x := newWorldX
                                                            Waypoints[waypointNumToMove].y := newWorldY

                                                            ; Destroy old GUI if it exists
                                                            oldGuiName := WaypointGUIs[waypointNumToMove]
                                                            if (oldGuiName != "") {
                                                                Gui, %oldGuiName%:Destroy
                                                                WaypointGUIs.Delete(waypointNumToMove)
                                                            }

                                                            ; Save waypoint to INI file
                                                            if (SelectedRouteFile) {
                                                                FileEncoding, UTF-8
                                                                IniWrite, %newWorldX%, %SelectedRouteFile%, Waypoints, X%waypointNumToMove%
                                                                IniWrite, %newWorldY%, %SelectedRouteFile%, Waypoints, Y%waypointNumToMove%
                                                                FileEncoding
                                                            }

                                                            ; Create visual waypoint directly at click position
                                                            guiName := "Waypoint" . waypointNumToMove
                                                            WaypointGUIs[waypointNumToMove] := guiName

                                                            Gui, %guiName%:New, +AlwaysOnTop +ToolWindow -Caption
                                                            Gui, %guiName%:Color, 00FF00
                                                            Gui, %guiName%:Font, s8 cWhite Bold

                                                            waypointText := waypointNumToMove
                                                            Gui, %guiName%:Add, Text, x0 y0 w%WaypointSize% h%WaypointSize% Center BackgroundTrans, %waypointText%

                                                            ; Place GUI at exact click position - center the waypoint on the cursor
                                                            halfSize := WaypointSize // 2
                                                            waypointX := clickX - halfSize
                                                            waypointY := clickY - halfSize

                                                            ; Show the GUI at the click position
                                                            Gui, %guiName%:Show, x%waypointX% y%waypointY% w%WaypointSize% h%WaypointSize% NA
                                                            WinSet, Transparent, 150, %guiName%

                                                            ; Make it click-through
                                                            WinGet, waypointHwnd, ID, %guiName%
                                                            if (waypointHwnd) {
                                                                exStyle := DllCall("GetWindowLong", "Ptr", waypointHwnd, "Int", -20, "UInt")
                                                                exStyle := exStyle | 0x20 | 0x80000
                                                                DllCall("SetWindowLong", "Ptr", waypointHwnd, "Int", -20, "UInt", exStyle)
                                                            }

                                                            ; Start the update timer if not already running
                                                            SetTimer, UpdateAllWaypoints, 500

                                                            ToolTip, Waypoint #%waypointNumToMove% moved to X:%newWorldX% Y:%newWorldY%, 0, 0
                                                            SetTimer, ClearTooltip, -2000
                                                        return

                                                        ; Update status
                                                        GuiControl,, NodeStatus, Nodes: 0 placed
                                                        MsgBox, All nodes cleared!
                                                        return

                                                        ListNodes:
                                                            if (TargetNodes.Length() = 0) {
                                                                MsgBox, No nodes placed yet!
                                                                return
                                                            }

                                                            nodeList := "PLACED TARGET NODES:`n`n"
                                                            for index, node in TargetNodes {
                                                                nodeList .= "Node #" . node.id . ": X=" . node.worldX . " Y=" . node.worldY . "`n"
                                                            }
                                                            nodeList .= "`nUsage in commands:`nworldclick,1 (clicks node #1)`nworldclick,2 (clicks node #2)`netc."

                                                            MsgBox, %nodeList%
                                                        return

                                                        MoveNode:
                                                            ; Ask user for node number
                                                            InputBox, nodeNumToMove, Move Node, Enter the node ID to move:, , 300, 150
                                                            if (ErrorLevel) {
                                                                return ; User cancelled
                                                            }

                                                            ; Validate input
                                                            if (nodeNumToMove = "" || nodeNumToMove < 1) {
                                                                MsgBox, Invalid node ID!
                                                                return
                                                            }

                                                            ; Check if node exists
                                                            nodeExists := false
                                                            for index, node in TargetNodes {
                                                                if (node.id = nodeNumToMove) {
                                                                    nodeExists := true
                                                                    break
                                                                }
                                                            }

                                                            if (!nodeExists) {
                                                                MsgBox, Node #%nodeNumToMove% does not exist!
                                                                return
                                                            }

                                                            ; Auto-sync TargetGameWindow with win1 if not set
                                                            if (!TargetGameWindow && win1) {
                                                                TargetGameWindow := win1
                                                            }

                                                            if (!TargetGameWindow) {
                                                                MsgBox, No game window selected! Please select a window first.
                                                                return
                                                            }

                                                            ; Activate the game window
                                                            WinActivate, ahk_id %TargetGameWindow%
                                                            Sleep, 200

                                                            ; Show instruction
                                                            MsgBox, 64, Move Node, Right-click on the new position for node #%nodeNumToMove% in the game window., 3

                                                            ; Wait for right-click
                                                            KeyWait, RButton, D

                                                            ; Get the click position (use CoordMode to ensure we get screen coordinates)
                                                            CoordMode, Mouse, Screen
                                                            MouseGetPos, clickX, clickY, clickWinID

                                                            ; Verify click was in game window
                                                            if (clickWinID <> TargetGameWindow) {
                                                                MsgBox, Click was not in the game window! Move cancelled.
                                                                return
                                                            }

                                                            ; Get current player coordinates
                                                            GetCurrentCoordinates(playerX, playerY)
                                                            if (playerX = "" || playerY = "") {
                                                                MsgBox, Could not read current coordinates! Make sure coordinates are visible.
                                                                return
                                                            }

                                                            ; Get game window position
                                                            WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%

                                                            ; Calculate pixel offset from character center (window-relative coordinates)
                                                            baseScreenX := winX + 516
                                                            baseScreenY := winY + 410
                                                            screenRelativeX := clickX - baseScreenX
                                                            screenRelativeY := clickY - baseScreenY

                                                            ; Reverse NavigateToCoordinatesClick calculations
                                                            ; NOTE: NavigateToCoordinatesClick uses "clickY = baseClickY - rotatedY" (MINUS!)
                                                            ; So to reverse: rotatedY = baseClickY - clickY = -(clickY - baseClickY) = -screenRelativeY
                                                            rotatedX := screenRelativeX
                                                            rotatedY := -screenRelativeY ; NEGATIVE because of the minus in NavigateToCoordinatesClick!

                                                            ; Undo rotation (inverse of NavigateToCoordinatesClick rotation with -CameraAngle)
                                                            cos_angle := Cos(-CameraAngle)
                                                            sin_angle := Sin(-CameraAngle)

                                                            ; Forward rotation: rotatedX = scaledX * cos - scaledY * sin
                                                            ; Forward rotation: rotatedY = scaledX * sin + scaledY * cos
                                                            ; Inverse: scaledX = rotatedX * cos + rotatedY * sin
                                                            ; Inverse: scaledY = -rotatedX * sin + rotatedY * cos
                                                            scaledX := rotatedX * cos_angle + rotatedY * sin_angle
                                                            scaledY := -rotatedX * sin_angle + rotatedY * cos_angle

                                                            ; Undo distance correction (NavigateToCoordinatesClick: scaledX *= 0.94, scaledY *= 1.19)
                                                            scaledX := scaledX / 0.94
                                                            scaledY := scaledY / 1.19

                                                            ; Calculate Y scaling (same formula as NavigateToCoordinatesClick)
                                                            if (CameraRadius <= 900) {
                                                                pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                            } else if (CameraRadius <= 1000) {
                                                                t := (CameraRadius - 900) / 100
                                                                pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                            } else if (CameraRadius <= 1500) {
                                                                t := (CameraRadius - 1000) / 500
                                                                pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                            } else {
                                                                t := (CameraRadius - 1500) / 500
                                                                pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                                            }

                                                            ; Undo scaling (reverse of: scaledX = -deltaX * 1.21, scaledY = -deltaY * pixelsPerGameUnitY)
                                                            worldDeltaX := -scaledX / 1.21
                                                            worldDeltaY := -scaledY / pixelsPerGameUnitY

                                                            ; Calculate world coordinates
                                                            newWorldX := Round(playerX + worldDeltaX, 2)
                                                            newWorldY := Round(playerY + worldDeltaY, 2)

                                                            ; Update the node in the array
                                                            for index, node in TargetNodes {
                                                                if (node.id = nodeNumToMove) {
                                                                    TargetNodes[index].worldX := newWorldX
                                                                    TargetNodes[index].worldY := newWorldY
                                                                    break
                                                                }
                                                            }

                                                            ; Destroy old GUI if it exists
                                                            oldGuiName := NodeGUIs[nodeNumToMove]
                                                            if (oldGuiName != "") {
                                                                Gui, %oldGuiName%:Destroy
                                                            }

                                                            ; Save nodes to file
                                                            SaveNodes()

                                                            ; Create visual node directly at click position (like AddTargetNode does)
                                                            guiName := "TargetNode" . nodeNumToMove
                                                            NodeGUIs[nodeNumToMove] := guiName

                                                            ; Use global NodeSize variable
                                                            nodeW := NodeSize
                                                            nodeH := NodeSize

                                                            Gui, %guiName%:New, +AlwaysOnTop +ToolWindow -Caption
                                                            Gui, %guiName%:Color, FF0000
                                                            Gui, %guiName%:Font, s8 cWhite Bold
                                                            nodeIDText := nodeNumToMove
                                                            Gui, %guiName%:Add, Text, x0 y0 w%nodeW% h%nodeH% Center BackgroundTrans, %nodeIDText%

                                                            ; Place GUI at exact click position - center the node on the cursor
                                                            halfSize := NodeSize // 2
                                                            nodeX := clickX - halfSize
                                                            nodeY := clickY - halfSize

                                                            ; Show the GUI at the click position
                                                            Gui, %guiName%:Show, x%nodeX% y%nodeY% w%nodeW% h%nodeH% NoActivate
                                                            WinSet, Transparent, 150, %guiName%

                                                            ; Make it click-through
                                                            WinGet, nodeHwnd, ID, %guiName%
                                                            if (nodeHwnd) {
                                                                MakeWindowClickThroughByHandle(nodeHwnd)
                                                            }

                                                            ; Start the update timer if not already running
                                                            SetTimer, UpdateAllTargetNodes, 500

                                                            ToolTip, Node #%nodeNumToMove% moved to X:%newWorldX% Y:%newWorldY%, 0, 0
                                                            SetTimer, ClearTooltip, -2000
                                                        return

                                                        MonitorNodeMoves:
                                                            if (!NodeMoveMode)
                                                                return

                                                            ; Check if left mouse button is pressed over a node GUI
                                                            if (GetKeyState("LButton", "P")) {
                                                                if (!NodeBeingDragged) {
                                                                    ; Check if mouse is over any node GUI
                                                                    MouseGetPos,,, hoveredWin
                                                                    hoveredWinTitle := ""
                                                                    WinGetTitle, hoveredWinTitle, ahk_id %hoveredWin%

                                                                    ; Check if it's a target node GUI
                                                                    if (InStr(hoveredWinTitle, "TargetNode")) {
                                                                        ; Extract node ID from window title
                                                                        nodeID := StrReplace(hoveredWinTitle, "TargetNode", "")
                                                                        if (nodeID > 0) {
                                                                            NodeBeingDragged := true
                                                                            DraggedNodeID := nodeID
                                                                            ToolTip, Moving Node #%nodeID%... Release to set position. Press ESC when all moves are done., 0, 0, 1
                                                                        }
                                                                    }
                                                                }
                                                            } else {
                                                                ; Left button released
                                                                if (NodeBeingDragged) {
                                                                    ; Update the world coordinates of the dragged node
                                                                    UpdateNodeWorldCoordinatesInMoveMode(DraggedNodeID)
                                                                    NodeBeingDragged := false
                                                                    DraggedNodeID := 0
                                                                    ToolTip, MOVE MODE: Drag nodes to reposition them. Press ESC to save and exit., 0, 0, 1
                                                                }
                                                            }
                                                        return

                                                        MsgBox, %nodeList%
                                                        return

                                                        ShowRouteInfo:
                                                            info := "=== ROUTE DEBUG INFO ===`n`n"

                                                            if (SelectedRouteFile) {
                                                                info .= "📁 Route File: " . SelectedRouteFile . "`n"
                                                                info .= " File Exists: " . (FileExist(SelectedRouteFile) ? "YES" : "NO") . "`n`n"
                                                            } else {
                                                                info .= "❌ NO ROUTE FILE SELECTED!`n"
                                                                info .= " → Click 'Select Route' to load existing route`n"
                                                                info .= " → Click 'New Path' to create new route`n`n"
                                                            }

                                                            info .= "🟢 Waypoints in memory: " . Waypoints.Length() . "`n"

                                                            if (SelectedRouteFile && FileExist(SelectedRouteFile)) {
                                                                IniRead, fileWaypointCount, %SelectedRouteFile%, Waypoints, Count, 0
                                                                info .= "📄 Waypoints in file: " . fileWaypointCount . "`n`n"

                                                                if (fileWaypointCount > 0) {
                                                                    info .= "First 3 waypoints from file:`n"
                                                                    Loop, 3 {
                                                                        if (A_Index > fileWaypointCount)
                                                                            break
                                                                        IniRead, x, %SelectedRouteFile%, Waypoints, X%A_Index%, ERROR
                                                                        IniRead, y, %SelectedRouteFile%, Waypoints, Y%A_Index%, ERROR
                                                                        info .= " #" . A_Index . ": X=" . x . " Y=" . y . "`n"
                                                                    }
                                                                }
                                                            }

                                                            info .= "`n🔴 Target Nodes: " . TargetNodes.Length()
                                                            info .= "`n🎮 Game Window: " . (TargetGameWindow ? "Selected" : "NOT SELECTED")

                                                            MsgBox, 0, Route Information, %info%, 10
                                                        return

                                                        AddWaypoint:
                                                            if (!SelectedRouteFile) {
                                                                MsgBox, No route file selected! Create or select a route first.`n`nPlease click "Select Route" to load an existing route`nor click "New Path" to create a new route.
                                                                return
                                                            }

                                                            if (!TargetGameWindow) {
                                                                MsgBox, No target window selected! Please click "Select Window" first.
                                                                return
                                                            }

                                                            ; Cancel node placement mode if active
                                                            if (PlacingNodeMode) {
                                                                PlacingNodeMode := false
                                                                SetTimer, CheckForNodePlacement, Off
                                                            }

                                                            PlacingWaypointMode := true
                                                            ToolTip, Right-click in the game window to add a waypoint. Press ESC to cancel., 1
                                                            SetTimer, CheckForWaypointPlacement, 100
                                                        return

                                                        CheckForWaypointPlacement:
                                                            if (!PlacingWaypointMode) {
                                                                SetTimer, CheckForWaypointPlacement, Off
                                                                ToolTip,, 1
                                                                return
                                                            }

                                                            if (GetKeyState("Escape", "P")) {
                                                                PlacingWaypointMode := false
                                                                SetTimer, CheckForWaypointPlacement, Off
                                                                ToolTip,, 1
                                                                return
                                                            }

                                                            if (GetKeyState("RButton", "P")) {
                                                                ; Get mouse position
                                                                MouseGetPos, mouseX, mouseY, mouseWin

                                                                ; Debug: Show what window we clicked
                                                                ToolTip, Clicked window: %mouseWin%`nTarget: %TargetGameWindow%`nMouse: %mouseX%`, %mouseY%, 1

                                                                ; Verify we clicked in the game window (compare window IDs)
                                                                if (mouseWin != TargetGameWindow) {
                                                                    ToolTip, Wrong window! Clicked: %mouseWin%`nTarget: %TargetGameWindow%, 1
                                                                    SetTimer, ClearTooltip, -3000
                                                                    return
                                                                }

                                                                ; Get window position
                                                                WinGetPos, winX, winY, winW, winH, ahk_id %TargetGameWindow%

                                                                ; Get player's current position
                                                                GetCurrentCoordinates(playerX, playerY)
                                                                if (playerX = "" || playerY = "") {
                                                                    ToolTip, Could not get current coordinates!, 1
                                                                    return
                                                                }

                                                                ; Calculate relative screen position from character center
                                                                charScreenX := winX + 516
                                                                charScreenY := winY + 410

                                                                screenDeltaX := mouseX - charScreenX
                                                                screenDeltaY := mouseY - charScreenY

                                                                ; Reverse rotation (use global CameraAngle)
                                                                rotatedX := screenDeltaX * Cos(-CameraAngle) - screenDeltaY * Sin(-CameraAngle)
                                                                rotatedY := screenDeltaX * Sin(-CameraAngle) + screenDeltaY * Cos(-CameraAngle)

                                                                ; Reverse distance correction
                                                                scaledX := rotatedX / 0.94
                                                                scaledY := rotatedY / 1.19

                                                                ; Reverse coordinate scaling
                                                                deltaX := -scaledX / 1.21 ; Negative because X was negated
                                                                deltaY := scaledY / 0.95

                                                                ; Calculate world coordinates
                                                                worldX := playerX + deltaX
                                                                worldY := playerY + deltaY

                                                                ; Add waypoint to array
                                                                Waypoints.Push({x: worldX, y: worldY})
                                                                waypointIndex := Waypoints.Length()

                                                                ; Make LOCAL copies to prevent any interference
                                                                saveWaypointIndex := waypointIndex
                                                                saveWorldX := worldX
                                                                saveWorldY := worldY

                                                                ; LOG FILE for debugging
                                                                logFile := A_ScriptDir . "\waypoint_save_log.txt"
                                                                FormatTime, timeStamp, , yyyy-MM-dd HH:mm:ss
                                                                FileAppend, [%timeStamp%] Attempting to save Waypoint #%saveWaypointIndex%`n, %logFile%

                                                                ; Save to file with ROBUST verification and retry logic
                                                                maxRetries := 3
                                                                saveSuccess := false

                                                                Loop, %maxRetries% {
                                                                    attemptNum := A_Index

                                                                    FileAppend, [%timeStamp%] Attempt %attemptNum%: Writing Count=%saveWaypointIndex% X=%saveWorldX% Y=%saveWorldY%`n, %logFile%

                                                                    ; Write all three values using LOCAL copies
                                                                    IniWrite, %saveWaypointIndex%, %SelectedRouteFile%, Waypoints, Count
                                                                    Sleep, 20
                                                                    IniWrite, %saveWorldX%, %SelectedRouteFile%, Waypoints, X%saveWaypointIndex%
                                                                    Sleep, 20
                                                                    IniWrite, %saveWorldY%, %SelectedRouteFile%, Waypoints, Y%saveWaypointIndex%
                                                                    Sleep, 100 ; Wait for filesystem

                                                                    ; VERIFY that both X and Y were written successfully using LOCAL copies
                                                                    IniRead, verifyX, %SelectedRouteFile%, Waypoints, X%saveWaypointIndex%, ERROR
                                                                    IniRead, verifyY, %SelectedRouteFile%, Waypoints, Y%saveWaypointIndex%, ERROR
                                                                    IniRead, verifyCount, %SelectedRouteFile%, Waypoints, Count, ERROR

                                                                    ; Trim any whitespace
                                                                    verifyX := Trim(verifyX)
                                                                    verifyY := Trim(verifyY)
                                                                    verifyCount := Trim(verifyCount)

                                                                    FileAppend, [%timeStamp%] Attempt %attemptNum%: Verification Count=%verifyCount% X=%verifyX% Y=%verifyY%`n, %logFile%

                                                                    ; Check if both values are valid AND count matches
                                                                    if (verifyX != "ERROR" && verifyY != "ERROR" && verifyX != "" && verifyY != "" && verifyCount = saveWaypointIndex) {
                                                                        ; Also verify the values match what we tried to write
                                                                        if (Abs(verifyX - saveWorldX) < 0.01 && Abs(verifyY - saveWorldY) < 0.01) {
                                                                            saveSuccess := true
                                                                            FileAppend, [%timeStamp%] SUCCESS on attempt %attemptNum%`n`n, %logFile%
                                                                            break
                                                                        } else {
                                                                            FileAppend, [%timeStamp%] Values don't match! Expected X=%saveWorldX% Y=%saveWorldY%`n, %logFile%
                                                                        }
                                                                    } else {
                                                                        FileAppend, [%timeStamp%] Missing values or count mismatch! Count=%verifyCount% (expected %saveWaypointIndex%) X=%verifyX% Y=%verifyY%`n, %logFile%
                                                                    }

                                                                    ; If not last attempt, wait before retry
                                                                    if (attemptNum < maxRetries) {
                                                                        Sleep, 200
                                                                    }
                                                                }

                                                                if (!saveSuccess) {
                                                                    ; All retries failed! Remove from array and show error
                                                                    Waypoints.Pop()
                                                                    ; Also try to clean up partial writes using LOCAL copies
                                                                    IniDelete, %SelectedRouteFile%, Waypoints, X%saveWaypointIndex%
                                                                    IniDelete, %SelectedRouteFile%, Waypoints, Y%saveWaypointIndex%
                                                                    ; Restore previous count
                                                                    prevCount := saveWaypointIndex - 1
                                                                    IniWrite, %prevCount%, %SelectedRouteFile%, Waypoints, Count

                                                                    FileAppend, [%timeStamp%] ❌ FAILED after %maxRetries% attempts - removed from array`n`n, %logFile%

                                                                    ToolTip, ❌ FAILED TO SAVE WAYPOINT after %maxRetries% attempts!`nX=%verifyX% Y=%verifyY%`nFile may be locked or disk full!`nCheck waypoint_save_log.txt, 1
                                                                    SetTimer, ClearTooltip, -5000
                                                                    KeyWait, RButton
                                                                    return
                                                                }

                                                                ; Create visual waypoint only after successful save using LOCAL copies
                                                                CreateVisualWaypoint(saveWaypointIndex, saveWorldX, saveWorldY)

                                                                ; Start update timer if not already running
                                                                SetTimer, UpdateAllWaypoints, 500

                                                                ; Update GUI
                                                                SplitPath, SelectedRouteFile, fileName
                                                                GuiControl,, RouteStatus, Route: %fileName% (%saveWaypointIndex% waypoints)
                                                                GuiControl, Enable, PrevWaypointBtn
                                                                GuiControl, Enable, NextWaypointBtn
                                                                GuiControl, Enable, GotoBtn

                                                                ; Show success tooltip
                                                                ToolTip, ✓ Waypoint %saveWaypointIndex% saved: X=%saveWorldX% Y=%saveWorldY%`nRight-click for more or press ESC to finish, 1
                                                                    SetTimer, ClearTooltip, -2000

                                                                ; Wait for mouse button release before continuing
                                                                KeyWait, RButton

                                                                ; Stay in placement mode for adding more waypoints
                                                                ; User can press ESC to exit
                                                            }
                                                        return
                                                        ; Replace your LoadWaypoints function with this improved version:
                                                        LoadWaypoints() {
                                                            if (!SelectedRouteFile || !FileExist(SelectedRouteFile)) {
                                                                return
                                                            }

                                                            IniRead, waypointCount, %SelectedRouteFile%, Waypoints, Count, 0
                                                            Waypoints := []
                                                            WaypointCommands := {} ; Clear existing commands

                                                            ; Debug: Show what count was read
                                                            debugInfo := "Loading from: " . SelectedRouteFile . "`n"
                                                            debugInfo .= "File says: " . waypointCount . " waypoints`n`n"

                                                            ; Load waypoints - only add to array if both X and Y are valid
                                                            actualCount := 0
                                                            skippedWaypoints := ""
                                                            Loop, %waypointCount% {
                                                                IniRead, x, %SelectedRouteFile%, Waypoints, X%A_Index%, ERROR
                                                                IniRead, y, %SelectedRouteFile%, Waypoints, Y%A_Index%, ERROR

                                                                ; Clean up any whitespace
                                                                x := Trim(x)
                                                                y := Trim(y)

                                                                ; Check if coordinates are valid (not ERROR, not empty, and numeric)
                                                                if (x != "ERROR" && y != "ERROR" && x != "" && y != "" && x is number && y is number) {
                                                                    Waypoints.Push({x: x+0, y: y+0}) ; +0 converts to number
                                                                    actualCount++

                                                                    ; Load commands for this waypoint and convert delimiters back to newlines
                                                                    IniRead, command, %SelectedRouteFile%, Commands, Waypoint%A_Index%, ERROR
                                                                    if (command != "ERROR" && command != "") {
                                                                        ; Convert delimiter back to newlines
                                                                        command := StrReplace(command, "||NEWLINE||", "`n")
                                                                        WaypointCommands[A_Index] := command
                                                                    }
                                                                } else {
                                                                    ; Track which waypoints were skipped and why
                                                                    reason := ""
                                                                    if (x = "ERROR" || x = "")
                                                                        reason .= "Missing X "
                                                                    if (y = "ERROR" || y = "")
                                                                        reason .= "Missing Y "
                                                                    if (x != "ERROR" && x != "" && !(x is number))
                                                                        reason .= "Invalid X "
                                                                    if (y != "ERROR" && y != "" && !(y is number))
                                                                        reason .= "Invalid Y "
                                                                    skippedWaypoints .= "WP#" . A_Index . ": " . reason . "`n"
                                                                }
                                                            }

                                                            ; Check if actual loaded waypoints match the count
                                                            loadedCount := Waypoints.Length()

                                                            ; Build detailed debug message
                                                            debugInfo .= "Successfully loaded: " . loadedCount . " waypoints`n"
                                                            if (skippedWaypoints != "") {
                                                                debugInfo .= "`nSKIPPED WAYPOINTS:`n" . skippedWaypoints
                                                            }

                                                            ; Show debug info
                                                            MsgBox, 0, Load Complete, %debugInfo%, 8

                                                            ; DON'T auto-correct the count - let user see the discrepancy
                                                            ; If we auto-correct, we might be hiding a real problem
                                                            ; User should manually fix the INI file or clear and recreate waypoints

                                                            ; Don't create visual waypoints here - let the update timer create them on-demand
                                                            ; This prevents GUI creation conflicts when loading many waypoints
                                                            DestroyAllVisualWaypoints()

                                                            ; Start the update timer - it will create GUIs as needed for nearby waypoints
                                                            if (Waypoints.Length() > 0) {
                                                                SetTimer, UpdateAllWaypoints, 500
                                                            }
                                                        }

                                                        SaveNodes() {
                                                            if (!SelectedRouteFile) {
                                                                MsgBox, No route file selected!
                                                                return
                                                            }

                                                            ; Clear existing nodes from file
                                                            IniDelete, %SelectedRouteFile%, Nodes

                                                            ; Save node count
                                                            nodeCount := TargetNodes.Length()
                                                            IniWrite, %nodeCount%, %SelectedRouteFile%, Nodes, Count

                                                            ; Save each node
                                                            for index, node in TargetNodes {
                                                                IniWrite, % node.id, %SelectedRouteFile%, Nodes, ID%index%
                                                                IniWrite, % node.worldX, %SelectedRouteFile%, Nodes, X%index%
                                                                IniWrite, % node.worldY, %SelectedRouteFile%, Nodes, Y%index%
                                                            }

                                                            ; Update NextNodeID
                                                            IniWrite, %NextNodeID%, %SelectedRouteFile%, Nodes, NextID
                                                        }

                                                        LoadNodes() {
                                                            if (!SelectedRouteFile || !FileExist(SelectedRouteFile)) {
                                                                return
                                                            }

                                                            ; Clear existing nodes with delay to prevent errors
                                                            for nodeID in NodeGUIs {
                                                                guiName := NodeGUIs[nodeID]
                                                                if (guiName != "") {
                                                                    Gui, %guiName%:Destroy
                                                                    Sleep, 50 ; Add delay between destroying each GUI
                                                                }
                                                            }
                                                            TargetNodes := []
                                                            NodeGUIs := {}

                                                            ; Read node count
                                                            IniRead, nodeCount, %SelectedRouteFile%, Nodes, Count, 0

                                                            if (nodeCount = 0) {
                                                                NextNodeID := 1
                                                                return
                                                            }

                                                            ; Load each node (just the data, not the visuals)
                                                            Loop, %nodeCount% {
                                                                IniRead, nodeID, %SelectedRouteFile%, Nodes, ID%A_Index%, ERROR
                                                                IniRead, worldX, %SelectedRouteFile%, Nodes, X%A_Index%, ERROR
                                                                IniRead, worldY, %SelectedRouteFile%, Nodes, Y%A_Index%, ERROR

                                                                if (nodeID != "ERROR" && worldX != "ERROR" && worldY != "ERROR") {
                                                                    node := {id: nodeID, worldX: worldX+0, worldY: worldY+0}
                                                                    TargetNodes.Push(node)
                                                                }
                                                            }

                                                            ; Load NextNodeID
                                                            IniRead, savedNextID, %SelectedRouteFile%, Nodes, NextID, 1
                                                            NextNodeID := savedNextID

                                                            ; Start the update timer - it will create GUIs as needed for nearby nodes
                                                            if (TargetNodes.Length() > 0) {
                                                                SetTimer, UpdateAllTargetNodes, 500
                                                            }
                                                        }

                                                        SelectRoute:
                                                            FileSelectFile, selectedFile, 1,, Select Route File, INI Files (*.ini)
                                                            if (selectedFile != "") {
                                                                SelectedRouteFile := selectedFile
                                                                NavSelectedRouteFile := selectedFile ; Also set the nav variable

                                                                ; Load waypoints and nodes
                                                                LoadWaypoints()
                                                                LoadNodes()

                                                                ; Update status
                                                                SplitPath, selectedFile, fileName
                                                                waypointCount := Waypoints.Length()
                                                                nodeCount := TargetNodes.Length()
                                                                GuiControl,, RouteStatus, Route: %fileName% (%waypointCount% waypoints)
                                                                GuiControl,, NodeStatus, Nodes: %nodeCount% placed
                                                                GuiControl,, NavRouteStatus, Route: %fileName% (%waypointCount% waypoints)

                                                                ; Enable navigation buttons if waypoints exist
                                                                if (waypointCount > 0) {
                                                                    GuiControl, Enable, PrevWaypointBtn
                                                                    GuiControl, Enable, NextWaypointBtn
                                                                    GuiControl, Enable, GotoBtn
                                                                }

                                                                MsgBox, Route loaded: %fileName%`nWaypoints: %waypointCount%`nNodes: %nodeCount%
                                                                UpdateStatusBar()
                                                            }
                                                        return

                                                        ClearWaypoints:
                                                            if (!SelectedRouteFile) {
                                                                MsgBox, No route file selected!
                                                                return
                                                            }

                                                            MsgBox, 4,, Clear all waypoints and commands from current route?
                                                            IfMsgBox Yes
                                                            {
                                                                ; Destroy visual waypoints
                                                                DestroyAllVisualWaypoints()

                                                                Waypoints := []
                                                                WaypointCommands := {} ; Clear commands too
                                                                IniWrite, 0, %SelectedRouteFile%, Waypoints, Count
                                                                Loop, 200 {
                                                                    IniDelete, %SelectedRouteFile%, Waypoints, X%A_Index%
                                                                    IniDelete, %SelectedRouteFile%, Waypoints, Y%A_Index%
                                                                    ; Also clear any commands for these waypoints
                                                                    IniDelete, %SelectedRouteFile%, Commands, Waypoint%A_Index%
                                                                }
                                                                MsgBox, All waypoints and commands cleared!
                                                            }
                                                        return

                                                        OpenFunctionBlockingGUI:
                                                            ; Destroy existing GUI if it exists to avoid conflicts
                                                            Gui, FuncBlock:Destroy

                                                            ; Create the Function Blocking Settings GUI
                                                            Gui, FuncBlock:Add, Text,, Function Blocking During Navigation
                                                            Gui, FuncBlock:Add, Text, x10 y30 w80 h20, Block From WP:
                                                            Gui, FuncBlock:Add, Edit, x95 y30 w40 h20 vFBTimerBlockStart
                                                            Gui, FuncBlock:Add, Text, x140 y30 w30 h25, to WP:
                                                            Gui, FuncBlock:Add, Edit, x175 y30 w40 h20 vFBTimerBlockEnd

                                                            Gui, FuncBlock:Add, Text, x10 y60 w60 h15, Functions:
                                                            Gui, FuncBlock:Add, Checkbox, x10 y80 w80 h25 vFBBlockHealing, Block Healing
                                                            Gui, FuncBlock:Add, Checkbox, x100 y80 w80 h25 vFBBlockDPS, Block DPS
                                                            Gui, FuncBlock:Add, Checkbox, x190 y80 w100 h25 vFBBlockKeySequence, Block Buffs
                                                            Gui, FuncBlock:Add, Checkbox, x10 y110 w100 h25 vFBBlockGnoll, Block Gnoll Buff
                                                            Gui, FuncBlock:Add, Checkbox, x120 y110 w120 h25 vFBBlockDeathTyrant, Block Death Tyrant
                                                            Gui, FuncBlock:Add, Checkbox, x10 y140 w120 h25 vFBBlockPotionDestroyer, Block Potion Destroyer

                                                            Gui, FuncBlock:Add, Button, x10 y170 w100 h25 gFBAddTimerBlock, Add Block Rule
                                                            Gui, FuncBlock:Add, Button, x120 y170 w100 h25 gFBClearTimerBlocks, Clear All Rules
                                                            Gui, FuncBlock:Add, Button, x230 y170 w60 h25 gFBClose, Close

                                                            Gui, FuncBlock:Add, Text, x10 y205 w280 h40 vFBTimerBlockStatus, No blocking rules set
                                                            Gui, FuncBlock:Add, Text, x10 y250 w280 h10, Note: Blocks timers until certain waypoints are reached.

                                                            ; Show the GUI
                                                            Gui, FuncBlock:Show, w300 h270, Function Blocking Settings
                                                        return

                                                        FBClose:
                                                            Gui, FuncBlock:Destroy
                                                        return

                                                        FBAddTimerBlock:
                                                            Gui, FuncBlock:Submit, NoHide

                                                            ; Validate input
                                                            if (FBTimerBlockStart = "" || FBTimerBlockEnd = "" || FBTimerBlockStart < 1 || FBTimerBlockEnd < 1) {
                                                                MsgBox, Please enter valid waypoint numbers (1 or higher)
                                                                return
                                                            }

                                                            if (FBTimerBlockStart > FBTimerBlockEnd) {
                                                                MsgBox, Start waypoint must be less than or equal to end waypoint
                                                                return
                                                            }

                                                            ; Build function list based on checkboxes
                                                            functionsToBlock := []
                                                            if (FBBlockHealing) {
                                                                functionsToBlock.Push("CheckHealth")
                                                            }
                                                            if (FBBlockDPS) {
                                                                functionsToBlock.Push("DPSLoop")
                                                            }
                                                            if (FBBlockKeySequence) {
                                                                functionsToBlock.Push("CheckExecutions")
                                                            }
                                                            if (FBBlockGnoll) {
                                                                functionsToBlock.Push("gnoll")
                                                            }
                                                            if (FBBlockDeathTyrant) {
                                                                functionsToBlock.Push("DeathTyrant")
                                                            }
                                                            if (FBBlockPotionDestroyer) {
                                                                functionsToBlock.Push("DestroySkyPotions")
                                                            }

                                                            if (functionsToBlock.Length() = 0) {
                                                                MsgBox, Please select at least one function to block
                                                                return
                                                            }

                                                            ; Add the blocking rule
                                                            SetNavFunctionBlock(FBTimerBlockStart, FBTimerBlockEnd, functionsToBlock)

                                                            ; Update status display
                                                            functionNames := ""
                                                            for index, func in functionsToBlock {
                                                                functionNames .= func . (index < functionsToBlock.Length() ? ", " : "")
                                                            }
                                                            GuiControl, FuncBlock:, FBTimerBlockStatus, WP %FBTimerBlockStart%-%FBTimerBlockEnd%: %functionNames%

                                                            ; Clear input fields
                                                            GuiControl, FuncBlock:, FBTimerBlockStart,
                                                            GuiControl, FuncBlock:, FBTimerBlockEnd,
                                                            GuiControl, FuncBlock:, FBBlockHealing, 0
                                                            GuiControl, FuncBlock:, FBBlockDPS, 0
                                                            GuiControl, FuncBlock:, FBBlockKeySequence, 0
                                                            GuiControl, FuncBlock:, FBBlockGnoll, 0
                                                            GuiControl, FuncBlock:, FBBlockDeathTyrant, 0
                                                            GuiControl, FuncBlock:, FBBlockPotionDestroyer, 0

                                                            MsgBox, Function blocking rule added: Waypoints %FBTimerBlockStart%-%FBTimerBlockEnd%
                                                        return

                                                        FBClearTimerBlocks:
                                                            global NavFunctionBlockRanges
                                                            NavFunctionBlockRanges := {}
                                                            GuiControl, FuncBlock:, FBTimerBlockStatus, No blocking rules set
                                                            MsgBox, All function blocking rules cleared
                                                        return

                                                        AddTimerBlock:
                                                            Gui, Submit, NoHide

                                                            ; Validate input
                                                            if (TimerBlockStart = "" || TimerBlockEnd = "" || TimerBlockStart < 1 || TimerBlockEnd < 1) {
                                                                MsgBox, Please enter valid waypoint numbers (1 or higher)
                                                                return
                                                            }

                                                            if (TimerBlockStart > TimerBlockEnd) {
                                                                MsgBox, Start waypoint must be less than or equal to end waypoint
                                                                return
                                                            }

                                                            ; Build function list based on checkboxes
                                                            functionsToBlock := []
                                                            if (BlockHealing) {
                                                                functionsToBlock.Push("CheckHealth")
                                                            }
                                                            if (BlockDPS) {
                                                                functionsToBlock.Push("DPSLoop")
                                                            }
                                                            if (BlockKeySequence) {
                                                                functionsToBlock.Push("CheckExecutions")
                                                            }

                                                            if (functionsToBlock.Length() = 0) {
                                                                MsgBox, Please select at least one function to block
                                                                return
                                                            }

                                                            ; Add the blocking rule
                                                            SetNavFunctionBlock(TimerBlockStart, TimerBlockEnd, functionsToBlock)

                                                            ; Update status display
                                                            functionNames := ""
                                                            for index, func in functionsToBlock {
                                                                functionNames .= func . (index < functionsToBlock.Length() ? ", " : "")
                                                            }
                                                            GuiControl,, TimerBlockStatus, WP %TimerBlockStart%-%TimerBlockEnd%: %functionNames%

                                                            ; Clear input fields
                                                            GuiControl,, TimerBlockStart,
                                                            GuiControl,, TimerBlockEnd,
                                                            GuiControl,, BlockHealing, 0
                                                            GuiControl,, BlockDPS, 0
                                                            GuiControl,, BlockKeySequence, 0

                                                            MsgBox, Function blocking rule added: Waypoints %TimerBlockStart%-%TimerBlockEnd%
                                                        return

                                                        ClearTimerBlocks:
                                                            global NavFunctionBlockRanges
                                                            NavFunctionBlockRanges := {}
                                                            GuiControl,, TimerBlockStatus, No blocking rules set
                                                            MsgBox, All function blocking rules cleared
                                                        return

                                                        DeleteWaypoint:
                                                            Gui, Submit, NoHide

                                                            if (DeleteWaypointID = "" || DeleteWaypointID < 1) {
                                                                MsgBox, Please enter a valid waypoint number!
                                                                return
                                                            }

                                                            waypointTotal := Waypoints.Length()
                                                            if (DeleteWaypointID > waypointTotal) {
                                                                MsgBox, Waypoint #%DeleteWaypointID% does not exist! (Only %waypointTotal% waypoints)
                                                                return
                                                            }

                                                            ; Destroy the GUI for this waypoint
                                                            guiName := WaypointGUIs[DeleteWaypointID]
                                                            if (guiName != "") {
                                                                Gui, %guiName%:Destroy
                                                            }
                                                            WaypointGUIs.Delete(DeleteWaypointID)

                                                            ; Remove waypoint from array
                                                            Waypoints.RemoveAt(DeleteWaypointID)

                                                            ; Remove command for this waypoint
                                                            WaypointCommands.Delete(DeleteWaypointID)

                                                            ; Now we need to rebuild the GUIs map since indices shifted
                                                            ; Destroy all remaining waypoint GUIs
                                                            for waypointIndex, guiName in WaypointGUIs {
                                                                if (guiName != "") {
                                                                    Gui, %guiName%:Destroy
                                                                }
                                                            }
                                                            WaypointGUIs := {}

                                                            ; Rebuild commands map (shift indices down)
                                                            newCommands := {}
                                                            for waypointIndex, cmd in WaypointCommands {
                                                                if (waypointIndex < DeleteWaypointID) {
                                                                    newCommands[waypointIndex] := cmd
                                                                } else if (waypointIndex > DeleteWaypointID) {
                                                                    newCommands[waypointIndex - 1] := cmd
                                                                }
                                                            }
                                                            WaypointCommands := newCommands

                                                            ; Save updated waypoints to file
                                                            if (!SelectedRouteFile) {
                                                                MsgBox, No route file selected!
                                                                return
                                                            }

                                                            ; First clear all waypoint data
                                                            Loop, 200 {
                                                                IniDelete, %SelectedRouteFile%, Waypoints, X%A_Index%
                                                                IniDelete, %SelectedRouteFile%, Waypoints, Y%A_Index%
                                                                IniDelete, %SelectedRouteFile%, Commands, Waypoint%A_Index%
                                                            }

                                                            ; Write updated waypoints
                                                            waypointCount := Waypoints.Length()
                                                            IniWrite, %waypointCount%, %SelectedRouteFile%, Waypoints, Count

                                                            for index, waypoint in Waypoints {
                                                                wpX := waypoint.x
                                                                wpY := waypoint.y
                                                                IniWrite, %wpX%, %SelectedRouteFile%, Waypoints, X%index%
                                                                IniWrite, %wpY%, %SelectedRouteFile%, Waypoints, Y%index%
                                                            }

                                                            ; Write updated commands
                                                            for waypointIndex, cmd in WaypointCommands {
                                                                IniWrite, %cmd%, %SelectedRouteFile%, Commands, Waypoint%waypointIndex%
                                                            }

                                                            ; Update status
                                                            waypointCount := Waypoints.Length()
                                                            SplitPath, SelectedRouteFile, fileName
                                                            GuiControl,, RouteStatus, Route: %fileName% (%waypointCount% waypoints)
                                                            GuiControl,, DeleteWaypointID, ; Clear input field

                                                            ; Restart update timer to recreate GUIs
                                                            if (waypointCount > 0) {
                                                                SetTimer, UpdateAllWaypoints, 500
                                                            }

                                                            ;MsgBox, Waypoint #%DeleteWaypointID% deleted! Remaining waypoints renumbered.
                                                        return

                                                        DestroyAllVisualWaypoints() {
                                                            global WaypointGUIs, Waypoints

                                                            ; Destroy all waypoint GUIs with delay to prevent errors
                                                            for waypointIndex, guiName in WaypointGUIs {
                                                                Gui, %guiName%:Destroy
                                                                Sleep, 50 ; Add delay between destroying each GUI
                                                            }
                                                            WaypointGUIs := {}

                                                            ; Stop update timer if no waypoints
                                                            if (Waypoints.Length() = 0) {
                                                                SetTimer, UpdateAllWaypoints, Off
                                                            }
                                                        }

                                                        StartTravel() {
                                                            if (SelectedRouteFile = "") {
                                                                MsgBox, 0, Error, Please select a route first!
                                                                return
                                                            }
                                                            waypointCount := Waypoints.Length()
                                                            if (waypointCount = 0) {
                                                                MsgBox, No waypoints loaded. Please select a route first.
                                                                return
                                                            }
                                                            IsTraveling := true
                                                            SingleWaypointMode := false ; Full route travel
                                                            CurrentWaypoint := 1
                                                            GuiControl, Disable, StartBtn
                                                            GuiControl, Enable, StopBtn
                                                            SetTimer, UpdateCoordinatesDisplay, 50
                                                            SetTimer, TravelLoop, 50
                                                        }

                                                        StopTravel:
                                                            IsTraveling := false
                                                            SetTimer, UpdateCoordinatesDisplay, off
                                                            SetTimer, TravelLoop, Off
                                                            ReleaseAllWASDKeys()
                                                            GuiControl, Enable, StartBtn
                                                            GuiControl, Disable, StopBtn
                                                            GuiControl,, RouteStatus, Travel stopped
                                                        return

                                                        PrevWaypoint:
                                                            waypointCount := Waypoints.Length()
                                                            if (waypointCount = 0) {
                                                                MsgBox, No waypoints loaded!
                                                                return
                                                            }
                                                            targetWaypoint := CurrentWaypoint - 1
                                                            if (targetWaypoint < 1) {
                                                                targetWaypoint := waypointCount
                                                            }
                                                            GoToWaypoint(targetWaypoint)
                                                        return

                                                        NextWaypoint:
                                                            waypointCount := Waypoints.Length()
                                                            if (waypointCount = 0) {
                                                                MsgBox, No waypoints loaded!
                                                                return
                                                            }
                                                            targetWaypoint := CurrentWaypoint + 1
                                                            if (targetWaypoint > waypointCount) {
                                                                targetWaypoint := 1
                                                            }
                                                            GoToWaypoint(targetWaypoint)
                                                        return

                                                        GotoSpecificWaypoint:
                                                            Gui, Submit, NoHide
                                                            waypointCount := Waypoints.Length()
                                                            if (waypointCount = 0) {
                                                                MsgBox, No waypoints loaded!
                                                                return
                                                            }
                                                            if (GotoWaypoint > 0 && GotoWaypoint <= waypointCount) {
                                                                GoToWaypoint(GotoWaypoint)
                                                            } else {
                                                                MsgBox, Invalid waypoint number! Valid range: 1-%waypointCount%
                                                            }
                                                        return

                                                        GoToWaypoint(waypointNum) {
                                                            waypointCount := Waypoints.Length()
                                                            if (waypointNum < 1 || waypointNum > waypointCount) {
                                                                return
                                                            }
                                                            IsTraveling := true
                                                            SingleWaypointMode := true ; Single waypoint travel
                                                            CurrentWaypoint := waypointNum
                                                            GuiControl, Disable, StartBtn
                                                            GuiControl, Enable, StopBtn
                                                            GuiControl,, RouteStatus, Going to waypoint %waypointNum%
                                                            SetTimer, TravelLoop, 50
                                                        }

                                                        TravelLoop:
                                                            waypointCount := Waypoints.Length()
                                                            if (!IsTraveling || CurrentWaypoint > waypointCount) {
                                                                IsTraveling := false
                                                                SetTimer, TravelLoop, Off
                                                                ; Release all WASD keys when travel stops
                                                                ReleaseAllWASDKeys()
                                                                GuiControl, Enable, StartBtn
                                                                GuiControl, Disable, StopBtn
                                                                ; Reset stuck detection
                                                                LastStuckCheckTime := 0
                                                                StuckMoveAttempts := 0
                                                                ; Restore any blocked functions when travel ends
                                                                RestoreBlockedFunctions()
                                                                return
                                                            }

                                                            ; Check if we should block/unblock functions at this waypoint
                                                            CheckWaypointFunctionBlocking()

                                                            waypoint := Waypoints[CurrentWaypoint]
                                                            GetCurrentCoordinates(coordsX, coordsY)

                                                            ; Wait until coordinates are successfully read
                                                            if (coordsX = "" || coordsY = "") {
                                                                Sleep, 100
                                                                return
                                                            }

                                                            ; Check if stuck (coordinates haven't changed for 3+ seconds)
                                                            ; Only check if NOT executing commands
                                                            currentTime := A_TickCount

                                                            if (!IsExecutingCommand) {
                                                                if (LastStuckCheckTime = 0) {
                                                                    ; Initialize stuck check
                                                                    LastStuckCheckTime := currentTime
                                                                    LastStuckCheckX := coordsX
                                                                    LastStuckCheckY := coordsY
                                                                } else if (currentTime - LastStuckCheckTime >= 3000) {
                                                                    ; 3 seconds have passed, check if position changed
                                                                    distance := Sqrt((coordsX - LastStuckCheckX)**2 + (coordsY - LastStuckCheckY)**2)

                                                                    if (distance < 5) {
                                                                        ; Stuck! Try to unstuck
                                                                        unstuckResult := TryUnstuck()

                                                                        if (!unstuckResult && StuckMoveAttempts = 0) {
                                                                            ; Failed after 3 attempts, waypoint was incremented
                                                                            ; Try one more time with new waypoint, if fails go back
                                                                            Sleep, 1000
                                                                            GetCurrentCoordinates(checkX, checkY)
                                                                            checkDistance := Sqrt((checkX - coordsX)**2 + (checkY - coordsY)**2)

                                                                            if (checkDistance < 5) {
                                                                                ; Still stuck, go to previous waypoint
                                                                                CurrentWaypoint := CurrentWaypoint - 2
                                                                                if (CurrentWaypoint < 1) {
                                                                                    CurrentWaypoint := 1
                                                                                }
                                                                                ToolTip, Next waypoint also stuck. Going to previous waypoint %CurrentWaypoint%..., 0, 0
                                                                                SetTimer, ClearTooltip, -3000
                                                                            }
                                                                        }
                                                                    }

                                                                    ; Reset stuck check timer
                                                                    LastStuckCheckTime := currentTime
                                                                    LastStuckCheckX := coordsX
                                                                    LastStuckCheckY := coordsY
                                                                }
                                                            } else {
                                                                ; Reset stuck check when executing commands
                                                                LastStuckCheckTime := 0
                                                                StuckMoveAttempts := 0
                                                            }

                                                            ; Use configurable distance tolerance
                                                            if (Abs(coordsX - waypoint.x) <= DistanceToleranceX && Abs(coordsY - waypoint.y) <= DistanceToleranceY) {
                                                                ; Reset stuck detection when waypoint reached
                                                                LastStuckCheckTime := 0
                                                                StuckMoveAttempts := 0

                                                                ; Execute waypoint commands if they exist
                                                                ExecuteWaypointCommands(CurrentWaypoint)

                                                                if (SingleWaypointMode) {
                                                                    ; Single waypoint mode - stop when reached
                                                                    IsTraveling := false
                                                                    SetTimer, TravelLoop, Off
                                                                    ReleaseAllWASDKeys()
                                                                    GuiControl, Enable, StartBtn
                                                                    GuiControl, Disable, StopBtn
                                                                    GuiControl,, RouteStatus, Reached waypoint %CurrentWaypoint%
                                                                    SingleWaypointMode := false
                                                                    return
                                                                } else {
                                                                    ; Full route mode - continue to next waypoint
                                                                    CurrentWaypoint++
                                                                    NewText := "Reached waypoint " . (CurrentWaypoint-1) . "/" . waypointCount
                                                                    GuiControl,, RouteStatus, %NewText%

                                                                    if (CurrentWaypoint > waypointCount) {
                                                                        CurrentWaypoint := 1
                                                                    }
                                                                }
                                                            } else {
                                                                ; Use the selected movement mode
                                                                if (MovementMode = "click") {
                                                                    NavigateToCoordinatesClick(waypoint.x, waypoint.y)
                                                                } else {
                                                                    NavigateToCoordinatesWASD(waypoint.x, waypoint.y)
                                                                }
                                                            }
                                                        return

                                                        ExecuteWaypointCommands(waypointNum) {
                                                            global IsExecutingCommand

                                                            if (!WaypointCommands.HasKey(waypointNum)) {
                                                                ; Debug: Show if no command exists for this waypoint
                                                                ; MsgBox, 0, Debug, No command for waypoint %waypointNum%, 1
                                                                return
                                                            }

                                                            ; Set flag to indicate commands are executing
                                                            IsExecutingCommand := true

                                                            commandText := WaypointCommands[waypointNum]
                                                            ; Debug: Show what command is being executed
                                                            ; MsgBox, 0, Debug, Executing command for waypoint %waypointNum%: %commandText%, 2

                                                            ; Check if it's a function call or contains complex AHK code
                                                            ; Must have () to be considered a function call, not just any word
                                                            if (RegExMatch(commandText, "^[a-zA-Z_][a-zA-Z0-9_]*\s*\(.*\)\s*$") || InStr(commandText, "`n") || InStr(commandText, "FindText") || InStr(commandText, "if (")) {
                                                                ; Execute as script block (including function calls)
                                                                ExecuteScriptBlock(commandText)
                                                                IsExecutingCommand := false
                                                                return
                                                            }

                                                            ; Parse simple commands separated by |
                                                            commands := StrSplit(commandText, "|")
                                                            for index, command in commands {
                                                                command := Trim(command)
                                                                if (command = "") {
                                                                    continue
                                                                }

                                                                ; Parse command type and parameters
                                                                commandParts := StrSplit(command, ",", " ")
                                                                commandType := Trim(commandParts[1])

                                                                ; Convert to lowercase for case-insensitive matching
                                                                commandTypeLower := ""
                                                                StringLower, commandTypeLower, commandType

                                                                if (commandTypeLower = "sleep") {
                                                                    sleepTime := Trim(commandParts[2])
                                                                    Sleep, %sleepTime%
                                                                } else if (commandTypeLower = "send") {
                                                                    keys := Trim(commandParts[2])
                                                                    Send, %keys%
                                                                } else if (commandTypeLower = "controlsend") {
                                                                    ; Format: controlsend, {keys} OR controlsend, {keys}, win2
                                                                    ; Default uses win1 (TargetGameWindow), or specify win2
                                                                    keys := Trim(commandParts[2])
                                                                    targetWin := TargetGameWindow ; Default to win1

                                                                    if (commandParts.Length() >= 3) {
                                                                        winSpec := Trim(commandParts[3])
                                                                        if (winSpec = "win2" && win2) {
                                                                            targetWin := win2
                                                                        }
                                                                    }

                                                                    if (targetWin) {
                                                                        ControlSend,, %keys%, ahk_id %targetWin%
                                                                    } else {
                                                                        MsgBox, Error: Window not set! Use "Select Win2" button first.
                                                                    }
                                                                } else if (commandTypeLower = "sendlevel") {
                                                                    level := Trim(commandParts[2])
                                                                    SendLevel %level%
                                                                } else if (commandTypeLower = "msgbox") {
                                                                    message := Trim(commandParts[2])
                                                                    MsgBox, 0, Waypoint Command, %message%, 2
                                                                } else if (commandTypeLower = "click") {
                                                                    if (commandParts.Length() >= 3) {
                                                                        clickX := Trim(commandParts[2])
                                                                        clickY := Trim(commandParts[3])

                                                                        ; Use SendMessage for clicking
                                                                        lParam := (clickY << 16) | (clickX & 0xFFFF)
                                                                        SendMessage, 0x0200, 0, %lParam%, , ahk_id %win1% ; WM_MOUSEMOVE
                                                                        Sleep, 20
                                                                        SendMessage, 0x0201, 1, %lParam%, , ahk_id %win1% ; WM_LBUTTONDOWN
                                                                        Sleep, 20
                                                                        SendMessage, 0x0202, 0, %lParam%, , ahk_id %win1% ; WM_LBUTTONUP
                                                                        Sleep, 30
                                                                    }
                                                                } else if (commandTypeLower = "controlclick") {
                                                                    ; Click at window-relative coordinates in win1
                                                                    ; Format: controlclick,X,Y where X and Y are window coordinates (not screen)
                                                                    if (commandParts.Length() >= 3) {
                                                                        winClickX := Trim(commandParts[2])
                                                                        winClickY := Trim(commandParts[3])

                                                                        if (TargetGameWindow) {
                                                                            ; Send click messages to the game window at the specified coordinates
                                                                            ; WM_LBUTTONDOWN = 0x201, WM_LBUTTONUP = 0x202
                                                                            SendMessage, 0x201, 1, % (winClickY << 16) | (winClickX & 0xFFFF), , ahk_id %TargetGameWindow%
                                                                            Sleep, 20
                                                                            SendMessage, 0x202, 0, % (winClickY << 16) | (winClickX & 0xFFFF), , ahk_id %TargetGameWindow%
                                                                            Sleep, 30
                                                                        } else {
                                                                            MsgBox, 0, Error, No game window selected!, 2
                                                                        }
                                                                    }
                                                                } else if (commandTypeLower = "worldclick") {
                                                                    ; Click at in-game world coordinates (not screen coordinates)
                                                                    ; Format: worldclick,X,Y where X and Y are game world coordinates
                                                                    ; OR: worldclick,1 to click at node #1, worldclick,2 for node #2, etc.
                                                                    if (commandParts.MaxIndex() >= 2) {
                                                                        nodeNum := Trim(commandParts[2])
                                                                        clickatnode(nodeNum)
                                                                    } else {

                                                                    }
                                                                } else if (commandTypeLower = "holyground") {
                                                                    ; Format: holyground,delay,key,node OR holyground,delay,key,node1,node2 OR holyground,delay,key,node1,node2,node3
                                                                    if (commandParts.MaxIndex() >= 4) {
                                                                        delay := Trim(commandParts[2])
                                                                        key := Trim(commandParts[3])
                                                                        nodeNum1 := Trim(commandParts[4])

                                                                        ; Check if we have 1, 2, or 3 nodes
                                                                        if (commandParts.MaxIndex() >= 6) {
                                                                            ; 3 nodes provided
                                                                            nodeNum2 := Trim(commandParts[5])
                                                                            nodeNum3 := Trim(commandParts[6])
                                                                            holyground(delay, key, nodeNum1, nodeNum2, nodeNum3)
                                                                        } else if (commandParts.MaxIndex() >= 5) {
                                                                            ; 2 nodes provided
                                                                            nodeNum2 := Trim(commandParts[5])
                                                                            holyground(delay, key, nodeNum1, nodeNum2)
                                                                        } else {
                                                                            ; Only 1 node provided
                                                                            holyground(delay, key, nodeNum1)
                                                                        }
                                                                    } else {
                                                                        MsgBox, 0, Error, holyground requires at least 3 parameters: delay`,key`,node, 3
                                                                    }
                                                                } else if (commandTypeLower = "winactivate") {
                                                                    WinActivate, ahk_id %TargetGameWindow%
                                                                } else if (commandTypeLower = "coords") {
                                                                    ; Get and display current coordinates
                                                                    GetCurrentCoordinates(cx, cy)
                                                                    MsgBox, 0, Current Position, X: %cx% Y: %cy%, 2
                                                                } else if (commandTypeLower = "tooltip") {
                                                                    message := Trim(commandParts[2])
                                                                    ToolTip, %message%
                                                                    SetTimer, ClearTooltip, -3000
                                                                } else if (commandTypeLower = "trycastheal") {
                                                                    ; Try to cast the highest priority heal skill available
                                                                    ; Usage: trycastheal
                                                                    TryCastHealingSkill()()
                                                                } else if (commandTypeLower = "trycastdps") {
                                                                    ; Try to cast a DPS skill (respects 1-second global cooldown)
                                                                    ; Usage: trycastdps
                                                                    TryCastDPSSkills()()
                                                                } else if (commandTypeLower = "loopcastuntilmobdead") {
                                                                    ; Loop casting heal and DPS until mob health bar is not found
                                                                    ; Usage: loopcastuntilmobdead
                                                                    LoopCastUntilMobDead()
                                                                } else if (commandTypeLower = "checkmobhealth") {
                                                                    ; Check if mob health bar exists, skip remaining commands if not found
                                                                    ; Usage: checkmobhealth
                                                                    if (!CheckMobHealth()) {
                                                                        ; Mob health not found, stop processing this waypoint's commands
                                                                        return
                                                                    }
                                                                } else if (commandTypeLower = "reenterbd5") {
                                                                    ; BD5 dungeon re-entry sequence
                                                                    ; Usage: reenterbd5
                                                                    ReEnterBD5()
                                                                } else if (commandTypeLower = "loopclickuntilpatternmissing") {
                                                                    ; Loop click a node until a FindText pattern is no longer found
                                                                    ; If pattern still found after maxClicks, move back N waypoints and retry
                                                                    ; Usage: loopclickuntilpatternmissing,nodeNum,patternName,maxClicks,backSteps
                                                                    ; Example: loopclickuntilpatternmissing,10,bd5quest,2,1
                                                                    ; OR with inline pattern: loopclickuntilpatternmissing,10,|<>pattern...,2,1
                                                                    if (commandParts.Length() >= 5) {
                                                                        nodeNum := Trim(commandParts[2])
                                                                        patternNameOrText := Trim(commandParts[3])
                                                                        maxClicks := Trim(commandParts[4])
                                                                        backSteps := Trim(commandParts[5])
                                                                        LoopClickUntilPatternMissing(nodeNum, patternNameOrText, maxClicks, backSteps)
                                                                    } else {
                                                                        MsgBox, 0, Error, loopclickuntilpatternmissing requires 4 parameters: nodeNum,patternName,maxClicks,backSteps, 3
                                                                    }
                                                                } else if (commandTypeLower = "loopclickuntilpatternfound") {
                                                                    ; New command: Loop clicking nodes until pattern appears, then control-click it
                                                                    ; Usage: loopclickuntilpatternfound,nodeNum1,nodeNum2,patternName
                                                                    ; Example: loopclickuntilpatternfound,28,28,entrance5
                                                                    if (commandParts.MaxIndex() >= 5) {
                                                                        nodeNum1 := Trim(commandParts[2])
                                                                        nodeNum2 := Trim(commandParts[3])
                                                                        maxclicks := Trim(commandParts[4])
                                                                        patternName := Trim(commandParts[5])
                                                                        LoopClickUntilPatternFound(nodeNum1, nodeNum2, maxclicks, patternName)
                                                                    } else {
                                                                        MsgBox, 0, Error, loopclickuntilpatternfound requires 4 parameters: nodeNum1,nodeNum2,maxclickcount,patternName, 3
                                                                    }
                                                                } else if (commandTypeLower = "loopsearchuntilpatternfound") {
                                                                    ; New command: Loop clicking nodes until pattern appears, then control-click it
                                                                    ; Usage: loopsearchuntilpatternfound,nodeNum1,nodeNum2,patternName
                                                                    ; Example: loopsearchuntilpatternfound,28,28,entrance5
                                                                    if (commandParts.MaxIndex() >= 3) {
                                                                        tries := Trim(commandParts[2])
                                                                        patternName := Trim(commandParts[3])
                                                                        LoopSearchUntilPatternFound(tries, patternName)
                                                                    } else {
                                                                        MsgBox, 0, Error, loopsearchuntilpatternfound requires 3 parameters: tries,patternName, 3
                                                                    }
                                                                } else if (commandTypeLower = "clickpattern") {
                                                                    ; New command: Find and click a pattern directly
                                                                    ; Usage: clickpattern,patternName
                                                                    ; Example: clickpattern,entrance5
                                                                    if (commandParts.MaxIndex() >= 2) {
                                                                        patternName := Trim(commandParts[2])
                                                                        ClickPattern(patternName)
                                                                    } else {
                                                                        MsgBox, 0, Error, clickpattern requires 1 parameter: patternName, 3
                                                                    }
                                                                } else if (commandTypeLower = "controlclickpattern") {
                                                                    ; New command: Find and control-click a pattern directly
                                                                    ; Usage: controlclickpattern,patternName  
                                                                    ; Example: controlclickpattern,entrance5
                                                                    if (commandParts.MaxIndex() >= 2) {
                                                                        patternName := Trim(commandParts[2])
                                                                        ClickPattern(patternName, true)
                                                                    } else {
                                                                        MsgBox, 0, Error, controlclickpattern requires 1 parameter: patternName, 3
                                                                    }
                                                                } else if (commandTypeLower = "farmuntilpattern") {
                                                                    ; Loop tab targeting and kill mobs until pattern appears
                                                                    ; Usage: farmuntilpattern,patternName
                                                                    ; Example: farmuntilpattern,entrance5
                                                                    if (commandParts.MaxIndex() >= 2) {
                                                                        stopPattern := Trim(commandParts[2])
                                                                        FarmUntilPattern(stopPattern)
                                                                    } else {
                                                                        MsgBox, 0, Error, farmuntilpattern requires 1 parameter: patternName, 3
                                                                    }
                                                                } else if (commandTypeLower = "sendhotkey") {
                                                                    ; Send a hotkey to trigger hotkeys in other scripts
                                                                    ; Usage: sendhotkey,key
                                                                    ; Example: sendhotkey,F1
                                                                    if (commandParts.MaxIndex() >= 2) {
                                                                        keyToSend := Trim(commandParts[2])
                                                                        SendLevel, 1
                                                                        Send, {%keyToSend%}
                                                                        SendLevel, 0
                                                                    } else {
                                                                        MsgBox, 0, Error, sendhotkey requires 1 parameter: key, 3
                                                                    }
                                                                } else if (commandTypeLower = "shiftclick") {
                                                                    ; Click at a node while holding Shift
                                                                    ; Usage: shiftclick,nodeNum
                                                                    ; Example: shiftclick,10
                                                                    if (commandParts.MaxIndex() >= 2) {
                                                                        nodeNum := Trim(commandParts[2])
                                                                        ShiftClickAtNode(nodeNum)
                                                                    } else {
                                                                        MsgBox, 0, Error, shiftclick requires 1 parameter: nodeNum, 3
                                                                    }
                                                                } else if (commandTypeLower = "ifpatternfoundgoto") {
                                                                    ; Check if pattern is found, if so jump to a specific waypoint
                                                                    ; Usage: ifpatternfoundgoto,patternName,waypointNumber
                                                                    ; Example: ifpatternfoundgoto,entrance5,10
                                                                    if (commandParts.MaxIndex() >= 3) {
                                                                        patternName := Trim(commandParts[2])
                                                                        targetWaypoint := Trim(commandParts[3])

                                                                        ; Check if pattern is found
                                                                        if (CheckPatternExists(patternName)) {
                                                                            ; Pattern found! Jump to the specified waypoint
                                                                            CurrentWaypoint := targetWaypoint
                                                                            ToolTip, Pattern '%patternName%' found! Jumping to waypoint %targetWaypoint%, 0, 0
                                                                            SetTimer, ClearTooltip, -2000
                                                                        }
                                                                    } else {
                                                                        MsgBox, 0, Error, ifpatternfoundgoto requires 2 parameters: patternName`,waypointNumber, 3
                                                                    }
                                                                } else if (commandTypeLower = "enablecritical") {
                                                                    ; Enable Critical mode to block all timers
                                                                    ; Usage: enablecritical
                                                                    EnableCriticalMode()
                                                                } else if (commandTypeLower = "disablecritical") {
                                                                    ; Disable Critical mode to allow timers
                                                                    ; Usage: disablecritical
                                                                    DisableCriticalMode()
                                                                } else if (commandtypelower = "gotowaypoint") {
                                                                    if (commandParts.Length() >= 2) {
                                                                        targetWaypoint := Trim(commandParts[2])
                                                                        GoToWaypoint(targetWaypoint)
                                                                    }

                                                                } else if (commandTypeLower = "CheckAndExecuteTimerFlags()"){
                                                                    CheckAndExecuteTimerFlags()

                                                                } else {
                                                                    ; Unknown command - show debug info
                                                                    MsgBox, 0, Debug, Unknown command: %commandType%`nFull command: %command%, 3
                                                                }
                                                            }

                                                            ; Reset flag when commands are done executing
                                                            IsExecutingCommand := false
                                                        }

                                                        ExecuteScriptBlock(scriptCode) {
                                                            ; Get current coordinates for use in scripts
                                                            GetCurrentCoordinates(currentX, currentY)

                                                            ; Make variables accessible
                                                            global win1, win2, Text, TargetGameWindow

                                                            ; Execute the script code directly
                                                            ; Note: This is a simple approach - complex scripts may need eval functionality

                                                            ; For simple command execution, you could parse and execute commands
                                                            ; For complex scripts, you might need a different approach

                                                            ; Simple example: Check if it's a call to CheckAndExecuteTimerFlags
                                                            if InStr(scriptCode, "CheckAndExecuteTimerFlags()") {
                                                                CheckAndExecuteTimerFlags()
                                                                return
                                                            }

                                                            ; For other scripts, you might need to use #Include or other methods
                                                            ; depending on what types of scripts you're running
                                                        }

                                                        NavigateToCoordinatesClick(targetX, targetY) {
                                                            static lastX := ""
                                                            static lastY := ""
                                                            static stuckCount := 0

                                                            GetCurrentCoordinates(coords1X, coords1Y)
                                                            Sleep, 10
                                                            GetCurrentCoordinates(coords2X, coords2Y)
                                                            Sleep, 10
                                                            GetCurrentCoordinates(coords3X, coords3Y)

                                                            if (coords1X != coords2X || coords1Y != coords2Y || coords2X != coords3X || coords2Y != coords3Y) {
                                                                Sleep, 50
                                                                return
                                                            }

                                                            currentX := coords3X
                                                            currentY := coords3Y

                                                            ;Optional: Offset in front of target, rotated by camera
                                                            ; offset := 280
                                                            ; offsetX := offset * Cos(CameraAngle)
                                                            ; offsetY := offset * Sin(CameraAngle)
                                                            ; targetX := targetX + offsetX
                                                            ; targetY := targetY + offsetY

                                                            if (Abs(currentX - targetX) <= DistanceToleranceX && Abs(currentY - targetY) <= DistanceToleranceY) {
                                                                return
                                                            }
                                                            if (currentX = lastX && currentY = lastY) { 
                                                                stuckCount++ 
                                                            } else { 
                                                                stuckCount := 0 
                                                            } 
                                                            lastX := currentX 
                                                            lastY := currentY

                                                            baseClickX := 516 
                                                            baseClickY := 410

                                                            deltaX := targetX - currentX 
                                                            deltaY := targetY - currentY

                                                            ; Calculate distance to target (in game units)  
                                                            distance := Sqrt(deltaX*deltaX + deltaY*deltaY)

                                                            ; Calibrated pixel conversion - UPDATED WITH NAVMESH CALIBRATION
                                                            ; X-axis: calibrated to 1.21 (was 0.55)
                                                            ; Y-axis: calibrated base to 0.95 (was 1.05)
                                                            ; Distance scaling: X=0.94, Y=1.19 for distance-dependent correction

                                                            ; Base X-axis scaling (calibrated)
                                                            pixelsPerGameUnitX := 1.21

                                                            ; Y-axis: piecewise linear based on camera radius (calibrated base)
                                                            if (CameraRadius <= 900) {
                                                                pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                            } else if (CameraRadius <= 1000) {
                                                                ; Interpolate between R900(0.95) and R1000(1.13)
                                                                t := (CameraRadius - 900) / 100
                                                                pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                            } else if (CameraRadius <= 1500) {
                                                                ; Interpolate between R1000(1.13) and R1500(0.75)
                                                                t := (CameraRadius - 1000) / 500
                                                                pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                            } else {
                                                                ; Extrapolate from R1500(0.75) and R2000(0.32)
                                                                t := (CameraRadius - 1500) / 500
                                                                pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                                            }

                                                            ; Scale deltas with base scaling
                                                            scaledX := -deltaX * pixelsPerGameUnitX 
                                                            scaledY := -deltaY * pixelsPerGameUnitY

                                                            ; Apply distance-based correction (calibrated: X=0.94, Y=1.19)
                                                            scaledX := scaledX * 0.94
                                                            scaledY := scaledY * 1.19

                                                            cos_angle := Cos(-CameraAngle) 
                                                            sin_angle := Sin(-CameraAngle)

                                                            rotatedX := scaledX * cos_angle - scaledY * sin_angle 
                                                            rotatedY := scaledX * sin_angle + scaledY * cos_angle

                                                            currentMaxDistance := MaxClickDistance 
                                                            if (distance < 20) { 
                                                                currentMaxDistance := MaxClickDistance * 0.3 
                                                            } else if (distance < 50) { 
                                                                currentMaxDistance := MaxClickDistance * 0.6 
                                                            }

                                                            pixelDistance := Sqrt(rotatedX*rotatedX + rotatedY*rotatedY) 
                                                            if (pixelDistance > currentMaxDistance) { 
                                                                scale := currentMaxDistance / pixelDistance 
                                                                rotatedX *= scale 
                                                                rotatedY *= scale 
                                                            }

                                                            minClickThreshold := 3 
                                                            if (Abs(rotatedX) < minClickThreshold && Abs(rotatedY) < minClickThreshold && distance > DistanceToleranceX) { 
                                                                if (Abs(rotatedX) > 0) { 
                                                                    rotatedX := (rotatedX > 0) ? minClickThreshold : -minClickThreshold 
                                                                } 
                                                                if (Abs(rotatedY) > 0) { 
                                                                    rotatedY := (rotatedY > 0) ? minClickThreshold : -minClickThreshold 
                                                                } 
                                                            }

                                                            if (stuckCount > 3) { 
                                                                Random, randX, -20, 20 
                                                                Random, randY, -20, 20 
                                                                rotatedX += randX 
                                                                rotatedY += randY 
                                                                stuckCount := 0 
                                                            }

                                                            clickX := baseClickX + rotatedX 
                                                            clickY := baseClickY - rotatedY ; If Y increases downward on screen; flip sign if needed

                                                            sendmessage, 0x201, 1, % (clickY << 16) | (clickX & 0xFFFF), , ahk_id %TargetGameWindow% ; WM_LBUTTONDOWN  
                                                            Sleep, 20
                                                            sendmessage, 0x202, 0, % (clickY << 16) | (clickX & 0xFFFF), , ahk_id %TargetGameWindow% ; WM_LBUTTONUP  
                                                            sleep, 30

                                                        }

                                                        ClickAtWorldCoordinates(targetX, targetY) {
                                                            ; Click at in-game world coordinates without moving the character
                                                            ; Uses EXACT same conversion as NavigateToCoordinatesClick for consistency

                                                            if (!TargetGameWindow) {
                                                                return
                                                            }

                                                            ; Get current position
                                                            GetCurrentCoordinates(currentX, currentY)
                                                            if (currentX = "" || currentY = "") {
                                                                return
                                                            }

                                                            ; Calculate delta from current position to target
                                                            deltaX := targetX - currentX
                                                            deltaY := targetY - currentY

                                                            ; Use EXACT same pixel conversion as NavigateToCoordinatesClick
                                                            pixelsPerGameUnitX := 1.21

                                                            ; Y-axis: piecewise linear based on camera radius (SAME as NavigateToCoordinatesClick)
                                                            if (CameraRadius <= 900) {
                                                                pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                            } else if (CameraRadius <= 1000) {
                                                                t := (CameraRadius - 900) / 100
                                                                pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                            } else if (CameraRadius <= 1500) {
                                                                t := (CameraRadius - 1000) / 500
                                                                pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                            } else {
                                                                t := (CameraRadius - 1500) / 500
                                                                pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                                            }

                                                            ; Scale the deltas - SAME as NavigateToCoordinatesClick
                                                            scaledX := -deltaX * pixelsPerGameUnitX
                                                            scaledY := -deltaY * pixelsPerGameUnitY

                                                            ; Apply distance correction - SAME as NavigateToCoordinatesClick
                                                            scaledX := scaledX * 0.94
                                                            scaledY := scaledY * 1.19

                                                            ; Apply camera rotation - SAME as NavigateToCoordinatesClick
                                                            cos_angle := Cos(-CameraAngle)
                                                            sin_angle := Sin(-CameraAngle)

                                                            rotatedX := scaledX * cos_angle - scaledY * sin_angle
                                                            rotatedY := scaledX * sin_angle + scaledY * cos_angle

                                                            ; Use the same base click position as NavigateToCoordinatesClick
                                                            baseClickX := 516
                                                            baseClickY := 410

                                                            ; Calculate final screen coordinates with offset correction
                                                            clickX := baseClickX + Round(rotatedX) - 7 ; 3 pixels right from -10 = -7
                                                            clickY := baseClickY - Round(rotatedY) - 29 ; 4 pixels up from -25 = -29
                                                            sendmessage, 0x200, 0, % (clickY << 16) | (clickX & 0xFFFF), , ahk_id %TargetGameWindow% ; WM_MOUSEMOVE
                                                            Sleep, 70
                                                            Sleep, 70 ; Send click messages to the game window without moving the mouse
                                                            sendmessage, 0x201, 1, % (clickY << 16) | (clickX & 0xFFFF), , ahk_id %TargetGameWindow% ; WM_LBUTTONDOWN
                                                            Sleep, 20
                                                            sendmessage, 0x202, 0, % (clickY << 16) | (clickX & 0xFFFF), , ahk_id %TargetGameWindow% ; WM_LBUTTONUP
                                                            Sleep, 30
                                                        }

                                                        TryUnstuck() {
                                                            global CurrentWaypoint, Waypoints, StuckMoveAttempts

                                                            ToolTip, Stuck detected! Attempting to unstuck (attempt %StuckMoveAttempts%/3)..., 0, 0

                                                            ; Get current position
                                                            GetCurrentCoordinates(currentX, currentY)
                                                            if (currentX = "" || currentY = "") {
                                                                return false
                                                            }

                                                            ; Generate random direction (0-360 degrees)
                                                            Random, randomAngle, 0, 360
                                                            randomAngleRad := randomAngle * 3.14159265 / 180

                                                            ; Move 50 game units in random direction
                                                            offsetX := 50 * Cos(randomAngleRad)
                                                            offsetY := 50 * Sin(randomAngleRad)

                                                            unstuckX := currentX + offsetX
                                                            unstuckY := currentY + offsetY

                                                            ; Click to move in that direction
                                                            ToolTip, Attempting random move to unstuck (angle: %randomAngle% degrees)..., 0, 0
                                                            ClickAtWorldCoordinates(unstuckX, unstuckY)
                                                            Sleep, 1000

                                                            ; Check if we moved
                                                            GetCurrentCoordinates(newX, newY)
                                                            if (newX = "" || newY = "") {
                                                                return false
                                                            }

                                                            distance := Sqrt((newX - currentX)**2 + (newY - currentY)**2)

                                                            if (distance > 10) {
                                                                ; Successfully moved
                                                                ToolTip, Unstuck successful! Moved %distance% units., 0, 0
                                                                SetTimer, ClearTooltip, -2000
                                                                StuckMoveAttempts := 0
                                                                return true
                                                            }

                                                            ; Still stuck
                                                            StuckMoveAttempts++

                                                            if (StuckMoveAttempts >= 3) {
                                                                ; Failed 3 times, try next waypoint
                                                                ToolTip, Failed to unstuck after 3 attempts. Trying next waypoint..., 0, 0
                                                                SetTimer, ClearTooltip, -2000
                                                                StuckMoveAttempts := 0
                                                                CurrentWaypoint++

                                                                ; If next waypoint also fails, go to previous
                                                                ; This will be handled by the caller
                                                                return false
                                                            }

                                                        return false
                                                    }

                                                    NavigateToCoordinatesWASD(targetX, targetY) {
                                                        GetCurrentCoordinates(currentX, currentY)

                                                        if (currentX = "" || currentY = "") {
                                                        return
                                                    }

                                                    deltaX := targetX - currentX
                                                    deltaY := targetY - currentY

                                                    ; Determine which keys should be pressed
                                                    newWASDState := {w: false, a: false, s: false, d: false}

                                                    ; Use the EXACT SAME logic as click movement
                                                    cos_angle := Cos(-CameraAngle)
                                                    sin_angle := Sin(-CameraAngle)

                                                    ; IMPORTANT: Negate deltas BEFORE rotation, just like click movement does!
                                                    ; Click movement: scaledX := -deltaX * pixels, scaledY := -deltaY * pixels
                                                    ; For WASD we don't scale, but we still need to negate
                                                    negDeltaX := -deltaX
                                                    negDeltaY := -deltaY

                                                    ; Apply rotation with negated deltas
                                                    rotatedX := negDeltaX * cos_angle - negDeltaY * sin_angle
                                                    rotatedY := negDeltaX * sin_angle + negDeltaY * cos_angle

                                                    threshold := 5

                                                    ; Now the rotated values directly tell us which keys to press
                                                    ; Positive rotatedY means move forward (W), negative means backward (S)
                                                    ; Positive rotatedX means move right (D), negative means left (A)
                                                    if (Abs(rotatedY) > threshold) {
                                                        if (rotatedY > 0) {
                                                            newWASDState.w := true ; Move forward/up
                                                        } else {
                                                            newWASDState.s := true ; Move backward/down
                                                        }
                                                    }

                                                    if (Abs(rotatedX) > threshold) {
                                                        if (rotatedX > 0) {
                                                            newWASDState.d := true ; Move right
                                                        } else {
                                                            newWASDState.a := true ; Move left
                                                        }
                                                    }

                                                    ; Update key states
                                                    UpdateWASDKeys(newWASDState)
                                                }

                                                UpdateWASDKeys(newState) {
                                                    ; Release keys that should no longer be pressed
                                                    for key, currentlyPressed in WASDKeys {
                                                        if (currentlyPressed && !newState[key]) {
                                                            Send, {%key% up}
                                                            WASDKeys[key] := false
                                                        }
                                                    }

                                                    ; Press keys that should be pressed
                                                    for key, shouldPress in newState {
                                                        if (shouldPress && !WASDKeys[key]) {
                                                            Send, {%key% down}
                                                            WASDKeys[key] := true
                                                        }
                                                    }
                                                }

                                                ReleaseAllWASDKeys() {
                                                    for key, isPressed in WASDKeys {
                                                        if (isPressed) {
                                                            Send, {%key% up}
                                                            WASDKeys[key] := false
                                                        }
                                                    }
                                                }

                                                ReloadScript() {
                                                    ReleaseAllWASDKeys() ; Make sure to release keys before reload
                                                    Reload
                                                }

                                                CopyCoords:
                                                    if (TargetGameWindow) {
                                                        GetCurrentCoordinates(coordX, coordY)
                                                        if (coordX != "" && coordY != "") {
                                                            Clipboard := coordX " " coordY
                                                            ToolTip, Coordinates copied: %coordX% %coordY%
                                                            SetTimer, RemoveCoordsToolTip, 2000
                                                        } else {
                                                            ToolTip, Unable to read coordinates
                                                            SetTimer, RemoveCoordsToolTip, 2000
                                                        }
                                                    } else {
                                                        MsgBox, Please select a game window first!
                                                    }
                                                Return

                                                RemoveCoordsToolTip:
                                                    ToolTip
                                                    SetTimer, RemoveCoordsToolTip, Off
                                                Return

                                                CheckPreviousSettings() {
                                                    ; Check for saved window settings
                                                    IniRead, savedPID, pathingsettings.ini, Settings, WindowPID, ERROR
                                                    IniRead, savedNavPID, navpathingsettings.ini, Settings, WindowPID, ERROR
                                                    IniRead, savedWin2PID, pathingsettings.ini, Settings, Win2PID, ERROR

                                                    ; Check for saved camera files
                                                    IniRead, savedNavCameraFile, navpathingsettings.ini, Settings, CameraFile, ERROR
                                                    IniRead, savedMainCameraFile, pathingsettings.ini, Settings, CameraFile, ERROR

                                                    ; Determine the best saved window (prefer navigation, then main)
                                                    bestPID := ""
                                                    bestWinID := ""
                                                    bestTitle := ""

                                                    if (savedNavPID != "ERROR") {
                                                        WinGet, winID, ID, ahk_pid %savedNavPID%
                                                        if (winID) {
                                                            bestPID := savedNavPID
                                                            bestWinID := winID
                                                            WinGetTitle, bestTitle, ahk_id %winID%
                                                        }
                                                    }

                                                    if (bestWinID = "" && savedPID != "ERROR") {
                                                        WinGet, winID, ID, ahk_pid %savedPID%
                                                        if (winID) {
                                                            bestPID := savedPID
                                                            bestWinID := winID
                                                            WinGetTitle, bestTitle, ahk_id %winID%
                                                        }
                                                    }

                                                    ; Determine the best camera file (prefer navigation, then main)
                                                    bestCameraFile := ""
                                                    cameraSource := ""

                                                    if (savedNavCameraFile != "ERROR" && FileExist(savedNavCameraFile)) {
                                                        bestCameraFile := savedNavCameraFile
                                                        cameraSource := "Navigation"
                                                    }
                                                    else if (savedMainCameraFile != "ERROR" && FileExist(savedMainCameraFile)) {
                                                        bestCameraFile := savedMainCameraFile
                                                        cameraSource := "Main"
                                                    }

                                                    ; If we have either window or camera file, offer to use previous settings
                                                    if (bestWinID != "" || bestCameraFile != "") {
                                                        promptText := "Use previous settings?"
                                                        if (bestWinID != "") {
                                                            promptText .= "`nWindow: " . bestTitle . " (PID: " . bestPID . ")"
                                                        }
                                                        if (bestCameraFile != "") {
                                                            SplitPath, bestCameraFile, fileName
                                                            promptText .= "`n" . cameraSource . " Camera File: " . fileName
                                                        }

                                                        MsgBox, 3, Previous Settings Found, %promptText%`n`nYes = Use previous settings`nNo = Set up fresh`nCancel = Camera only (if available)
                                                            IfMsgBox Yes
                                                        {
                                                            ; Use all previous settings
                                                            if (bestWinID != "") {
                                                                TargetGameWindow := bestWinID
                                                                TargetGamePID := bestPID
                                                                win1 := bestWinID
                                                                NavTargetGameWindow := bestWinID
                                                                NavTargetGamePID := bestPID
                                                                FindText().BindWindow(bestWinID)

                                                                ; Get window position on startup
                                                                WinGetPos, winX, winY,,, ahk_id %bestWinID%
                                                                if (winX != "" && winY != "") {
                                                                    ToolTip, Window auto-loaded at position: %winX%`, %winY%, 0, 0
                                                                    SetTimer, RemoveWindowPosTooltip, -2000
                                                                }
                                                            }

                                                            if (bestCameraFile != "") {
                                                                LoadSavedCameraFile(bestCameraFile)
                                                            }

                                                            ; Load win2 if it was saved
                                                            if (savedWin2PID != "ERROR") {
                                                                WinGet, win2ID, ID, ahk_pid %savedWin2PID%
                                                                if (win2ID) {
                                                                    win2 := win2ID
                                                                    win2PID := savedWin2PID
                                                                }
                                                            }
                                                        }
                                                        else IfMsgBox No
                                                        {
                                                            ; Start fresh - let user select window/camera through normal flow
                                                        }
                                                        else ; Cancel
                                                        {
                                                            ; Load camera file only if available
                                                            if (bestCameraFile != "") {
                                                                LoadSavedCameraFile(bestCameraFile)
                                                            }
                                                        }
                                                    }
                                                    ; If no previous settings found, continue with normal startup
                                                }

                                                RemoveWindowPosTooltip:
                                                    ToolTip
                                                return

                                                NewPath() {
                                                    InputBox, pathName, New Path, Enter name for new path:,, 300, 130
                                                    if (ErrorLevel || pathName = "") {
                                                        return
                                                    }

                                                    newFileName := pathName . ".ini"
                                                    IniWrite, 0, %newFileName%, Waypoints, Count
                                                    SelectedRouteFile := newFileName
                                                    Waypoints := []
                                                    WaypointCommands := {} ; Clear commands for new path
                                                    GuiControl,, RouteStatus, Route: %newFileName% (0 waypoints)
                                                    ; Enable the Commands button now that a route is selected
                                                    GuiControl, Enable, CommandsButton
                                                    ; Disable waypoint navigation buttons until waypoints are added
                                                    GuiControl, Disable, PrevWaypointBtn
                                                    GuiControl, Disable, NextWaypointBtn
                                                    GuiControl, Disable, GotoBtn
                                                    MsgBox, New path created: %newFileName%
                                                }

                                                SaveRadius() {
                                                    if (!navCameraFile) {
                                                        MsgBox, 0, Error, No camera file loaded!
                                                        return
                                                    }

                                                    ; Read the value directly from the control instead of using Gui Submit
                                                    GuiControlGet, newRadius,, RadiusEdit

                                                    ; Debug: Show what was read
                                                    ;MsgBox, Debug: newRadius = "%newRadius%"`nLength = %length%

                                                    if (newRadius = "" || newRadius < 1 || !newRadius) {
                                                        MsgBox, 0, Error, Please enter a valid number for radius!`n`nYou entered: "%newRadius%"
                                                        return
                                                    }

                                                    FileRead, fileContent, %navCameraFile%
                                                    if (ErrorLevel) {
                                                        MsgBox, Error reading camera file
                                                        return
                                                    }

                                                    newContent := RegExReplace(fileContent, "RADIUS\|[0-9.]+\|", "RADIUS|" . newRadius . "|")

                                                    FileDelete, %navCameraFile%
                                                    FileAppend, %newContent%, %navCameraFile%

                                                    CameraRadius := newRadius
                                                    ; Update the GUI display
                                                    GuiControl,, RadiusEdit, %CameraRadius%

                                                    MsgBox, Radius updated to %newRadius%
                                                }

                                                BD5Cam() {
                                                    global CameraFile, CameraRadius

                                                    if (!navCameraFile) {
                                                        MsgBox, 0, Error, No camera file loaded!`n`nPlease select a camera file first.
                                                        return
                                                    }

                                                    ; BD5 camera settings
                                                    bd5Content := "RADIUS|900.0000|XANGLE|1.473184|ZANGLE|0.006136|"

                                                    ; Delete and recreate the file with new content
                                                    FileDelete, %navCameraFile%
                                                    if (ErrorLevel) {
                                                        MsgBox, Error deleting camera file!`nFile: %CameraFile%
                                                        return
                                                    }

                                                    Sleep, 50

                                                    FileAppend, %bd5Content%, %navCameraFile%
                                                    if (ErrorLevel) {
                                                        MsgBox, Error writing to camera file!`nFile: %navCameraFile%
                                                        return
                                                    }

                                                    ; Update the camera radius variable and GUI
                                                    CameraRadius := 900.000000
                                                    GuiControl,, RadiusEdit, %CameraRadius%

                                                    MsgBox, BD5 camera settings applied!`nRadius: 900`nXAngle: 1.510000`nZAngle: 3.129320`n`nFile: %CameraFile%
                                                }

                                                ; CalibrateLive() {
                                                ;     if (!TargetGameWindow) {
                                                ;         MsgBox, Please select a game window first!
                                                ;         return
                                                ;     }
                                                ;
                                                ;     if (CalibrationActive) {
                                                ;         ; Finish calibration - count only completed clicks
                                                ;         completedClicks := 0
                                                ;         for i, click in CalibrationClicks {
                                                ;             if (!click.needsEnd) {
                                                ;                 completedClicks++
                                                ;             }
                                                ;         }
                                                ;         
                                                ;         if (completedClicks < 2) {
                                                ;             MsgBox, Not enough data! Need at least 2 completed clicks.`n`nCompleted: %completedClicks%`nTotal recorded: %CalibrationClicks.Length()%`n`nCalibration cancelled.
                                                ;             CalibrationActive := false
                                                ;             CalibrationClicks := []
                                                ;             return
                                                ;         }
                                                ;
                                                ;         ; Calculate camera angle and radius from the clicks
                                                ;         CalculateCameraFromClicks()
                                                ;         
                                                ;         CalibrationActive := false
                                                ;         CalibrationClicks := []
                                                ;     } else {
                                                ;         ; Start calibration
                                                ;         CalibrationActive := true
                                                ;         CalibrationClicks := []
                                                ;         
                                                ;         GetCurrentCoordinates(CalibrationStartX, CalibrationStartY)
                                                ;         
                                                ;         if (CalibrationStartX = "" || CalibrationStartY = "") {
                                                ;             MsgBox, Could not read coordinates! Make sure the game window is active and coordinates are visible.
                                                ;             CalibrationActive := false
                                                ;             return
                                                ;         }
                                                ;
                                                ;         MsgBox, 0, Live Calibration Started, 
                                                ;         (
                                                ; Live Camera Calibration Active!
                                                ;
                                                ; Starting position: %CalibrationStartX% %CalibrationStartY%
                                                ;
                                                ; NEW WORKFLOW:
                                                ; 1. Click somewhere in the game (right-click to move)
                                                ; 2. Press F9 IMMEDIATELY after clicking
                                                ; 3. Wait 3 seconds for character to move
                                                ; 4. Repeat steps 1-3 for 3-4 different spots (spread out in different directions)
                                                ; 5. Click "Live Calibrate" button again to finish
                                                ;
                                                ; The script will automatically:
                                                ; - Record your click position when you press F9
                                                ; - Wait 3 seconds and record where you ended up
                                                ; - Calculate camera settings from all movements
                                                ;
                                                ; Press F9 after EACH click, then wait for the movement to complete!
                                                ;         )
                                                ;     }
                                                ; }

                                                ; CalculateCameraFromClicks() {
                                                ;     ; This function uses the calibration click data to reverse-engineer camera settings
                                                ;     ; We have: starting position, click positions, and ending positions
                                                ;     ; We need to find: ZANGLE and optionally RADIUS
                                                ;     
                                                ;     ; Filter out incomplete clicks (where needsEnd is still true)
                                                ;     validClicks := []
                                                ;     for i, click in CalibrationClicks {
                                                ;         if (!click.needsEnd) {
                                                ;             validClicks.Push(click)
                                                ;         }
                                                ;     }
                                                ;     
                                                ;     totalClicks := validClicks.Length()
                                                ;     
                                                ;     ; Need at least 2 movements to calculate
                                                ;     if (totalClicks < 2) {
                                                ;         MsgBox, Calibration failed: Not enough completed movements`n`nTotal recorded: %CalibrationClicks.Length()%`nCompleted: %totalClicks%
                                                ;         return
                                                ;     }
                                                ;
                                                ;     ; Base click position (center of screen)
                                                ;     baseClickX := 516
                                                ;     baseClickY := 410
                                                ;
                                                ;     ; Try different angles and see which one gives the most consistent pixel ratio
                                                ;     bestAngle := 0
                                                ;     bestScore := 999999
                                                ;     
                                                ;     ; Search angles from -π to π
                                                ;     angles := []
                                                ;     Loop, 72 {
                                                ;         angle := -3.14159 + (A_Index - 1) * (6.28318 / 72)
                                                ;         angles.Push(angle)
                                                ;     }
                                                ;
                                                ;     for index, testAngle in angles {
                                                ;         cos_a := Cos(-testAngle)
                                                ;         sin_a := Sin(-testAngle)
                                                ;         
                                                ;         xRatios := []
                                                ;         yRatios := []
                                                ;         
                                                ;         ; Calculate ratios for each click with this angle
                                                ;         for i, click in validClicks {
                                                ;             screenDeltaX := click.clickX - baseClickX
                                                ;             screenDeltaY := click.clickY - baseClickY
                                                ;             
                                                ;             ; Reverse rotation
                                                ;             unrotX := screenDeltaX * cos_a - screenDeltaY * sin_a
                                                ;             unrotY := screenDeltaX * sin_a + screenDeltaY * cos_a
                                                ;             
                                                ;             gameDeltaX := click.endX - click.startX
                                                ;             gameDeltaY := click.endY - click.startY
                                                ;             
                                                ;             ; Skip if no movement
                                                ;             if (Abs(gameDeltaX) < 5 && Abs(gameDeltaY) < 5)
                                                ;                 continue
                                                ;             
                                                ;             ; Calculate ratios (pixels per game unit)
                                                ;             if (Abs(unrotX) > 10 && Abs(gameDeltaX) > 10) {
                                                ;                 ratio := Abs(unrotX / gameDeltaX)
                                                ;                 xRatios.Push(ratio)
                                                ;             }
                                                ;             if (Abs(unrotY) > 10 && Abs(gameDeltaY) > 10) {
                                                ;                 ratio := Abs(unrotY / gameDeltaY)
                                                ;                 yRatios.Push(ratio)
                                                ;             }
                                                ;         }
                                                ;         
                                                ;         ; Calculate variance - lower is better (more consistent)
                                                ;         if (xRatios.Length() > 0 && yRatios.Length() > 0) {
                                                ;             avgX := 0
                                                ;             avgY := 0
                                                ;             for i, val in xRatios
                                                ;                 avgX += val
                                                ;             for i, val in yRatios
                                                ;                 avgY += val
                                                ;             avgX /= xRatios.Length()
                                                ;             avgY /= yRatios.Length()
                                                ;             
                                                ;             variance := 0
                                                ;             for i, val in xRatios
                                                ;                 variance += (val - avgX) ** 2
                                                ;             for i, val in yRatios
                                                ;                 variance += (val - avgY) ** 2
                                                ;             
                                                ;             if (variance < bestScore) {
                                                ;                 bestScore := variance
                                                ;                 bestAngle := testAngle
                                                ;             }
                                                ;         }
                                                ;     }
                                                ; }

                                                ; RecordCalibrationClick() {
                                                ;     if (!CalibrationActive) {
                                                ;         ToolTip, Calibration is not active! Click "Live Calibrate" first.
                                                ;         SetTimer, RemoveToolTip, 2000
                                                ;         return
                                                ;     }
                                                ; }

                                                ; GetCalibrationEndPosition:
                                                ;     ToolTip
                                                ;     SetTimer, RemoveToolTip, Off
                                                ; return

                                                ; RemoveToolTip:
                                                ;     ToolTip
                                                ;     SetTimer, RemoveToolTip, Off
                                                ; return

                                                ActivateCoordinates:
                                                    if (!TargetGameWindow) {
                                                        SelectWindow()
                                                        if (!TargetGameWindow) {
                                                            return
                                                        }
                                                    }

                                                    Clipboard := "/info"
                                                    WinActivate, ahk_id %TargetGameWindow%
                                                    Sleep, 100
                                                    Send, {Enter}
                                                    Sleep, 80
                                                    Send, ^v
                                                    Sleep, 80
                                                    Send, {Enter}

                                                return

                                                ExitApp:
                                                GuiClose:
                                                    SetTimer, CheckExecutions, Off
                                                    SetTimer, CheckHealth, Off
                                                    SetTimer, DPSLoop, Off
                                                    ClearBoundingBoxes()
                                                    ReleaseAllWASDKeys() ; Make sure to release keys before exit
                                                ExitApp

                                                FuncBlockGuiClose:
                                                    Gui, FuncBlock:Destroy
                                                return

                                                SelectWindow() {
                                                    global win1, TargetGameWindow, TargetGamePID, CameraFile
                                                    global NavTargetGameWindow, NavTargetGamePID, NavCameraFile

                                                    MsgBox, Now right click on the game window 
                                                    KeyWait, RButton, D
                                                    MouseGetPos,,, selectedWindow
                                                    WinGetTitle, title, ahk_id %selectedWindow%
                                                    WinGet, pid, PID, ahk_id %selectedWindow%
                                                    MsgBox, You have selected: %title% (PID: %pid%)

                                                    ; Set up for healing system
                                                    FindText().BindWindow(selectedWindow)
                                                    win1 := selectedWindow
                                                    TargetGameWindow := selectedWindow
                                                    TargetGamePID := pid

                                                    ; Set up for navigation system
                                                    NavTargetGameWindow := selectedWindow
                                                    NavTargetGamePID := pid

                                                    ; Handle camera file selection for both systems
                                                    ; Check if there's a saved navigation camera file
                                                    IniRead, savedNavCameraFile, navpathingsettings.ini, Settings, CameraFile, ERROR
                                                    IniRead, savedMainCameraFile, pathingsettings.ini, Settings, CameraFile, ERROR

                                                    selectedCameraFile := ""

                                                    ; Prioritize navigation camera file, then main camera file
                                                    if (savedNavCameraFile != "ERROR" && FileExist(savedNavCameraFile)) {
                                                        MsgBox, 4,, Use previous navigation camera file?`n%savedNavCameraFile%
                                                        IfMsgBox Yes
                                                        {
                                                            selectedCameraFile := savedNavCameraFile
                                                        }
                                                    }
                                                    else if (savedMainCameraFile != "ERROR" && FileExist(savedMainCameraFile)) {
                                                        MsgBox, 4,, Use previous camera file?`n%savedMainCameraFile%
                                                        IfMsgBox Yes
                                                        {
                                                            selectedCameraFile := savedMainCameraFile
                                                        }
                                                    }

                                                    ; If no saved file or user declined, ask for new file
                                                    if (selectedCameraFile = "") {
                                                        FileSelectFile, selectedCameraFile, 1,, Select Camera File, TXT Files (*.txt)
                                                    }

                                                    ; Apply camera file to both systems if selected
                                                    if (selectedCameraFile != "") {
                                                        ; Set up navigation camera
                                                        NavCameraFile := selectedCameraFile
                                                        LoadNavCameraSettings(NavCameraFile)
                                                        GuiControl,, NavCameraFile, Camera: %NavCameraFile%
                                                        GuiControl,, NavRadiusEdit, %NavCameraRadius%

                                                        ; Set up main camera
                                                        CameraFile := selectedCameraFile
                                                        LoadCameraSettings(navCameraFile)

                                                        MsgBox, Camera file loaded for both systems: %selectedCameraFile%
                                                        SaveNavSettings()
                                                        SaveSettings()
                                                        UpdateStatusBar()
                                                    }
                                                return
                                            }

                                            SelectWin2() {
                                                global win2, win2PID

                                                MsgBox, Now right click on the SECOND game window (Win2)
                                                KeyWait, RButton, D
                                                MouseGetPos,,, tempWin
                                                WinGetTitle, title, ahk_id %tempWin%
                                                WinGet, pid, PID, ahk_id %tempWin%
                                                win2 := tempWin
                                                win2PID := pid
                                                MsgBox, Win2 selected: %title% (PID: %pid%)`n`nYou can now use ControlSend commands with win2 in waypoint commands.
                                                return
                                            }

                                            UpdateStatusBar() {
                                                global TargetGameWindow, SelectedRouteFile, TargetNodes
                                                status := ""
                                                if (TargetGameWindow) {
                                                    WinGetTitle, t, ahk_id %TargetGameWindow%
                                                    status .= "Window: " . t
                                                } else {
                                                    status .= "Window: (none)"
                                                }
                                                if (SelectedRouteFile && FileExist(SelectedRouteFile)) {
                                                    SplitPath, SelectedRouteFile, fileName
                                                    status .= " | Route: " . fileName
                                                } else {
                                                    status .= " | Route: (none)"
                                                }
                                                count := (IsObject(TargetNodes) ? TargetNodes.Length() : 0)
                                                status .= " | Nodes: " . count
                                                SB_SetText(status)
                                            }

                                            LoadCameraSettings(filePath) {
                                                FileRead, fileContent, %filePath%
                                                if (ErrorLevel) {
                                                    MsgBox, Error reading camera file
                                                return
                                            }

                                            RegExMatch(fileContent, "RADIUS\|([0-9.]+)\|", radiusMatch)
                                            RegExMatch(fileContent, "ZANGLE\|([0-9.-]+)\|", zangleMatch)

                                            if (radiusMatch1) {
                                                CameraRadius := radiusMatch1
                                                ; Remove the old pixel calculation since it's now done in NavigateToCoordinatesClick
                                                GuiControl,, RadiusEdit, %CameraRadius%
                                            }

                                            if (zangleMatch1) {
                                                CameraAngle := zangleMatch1
                                            }
                                        }

                                        GetCurrentCoordinates(ByRef outX, ByRef outY) {
                                            static lastX := "", lastY := "", lastCheckTime := 0
                                            static cacheTimeout := 25 ; Increased cache timeout to reduce CPU load

                                            ; Use cached values if available and recent
                                            currentTime := A_TickCount
                                            if (lastX != "" && lastY != "" && (currentTime - lastCheckTime) < cacheTimeout) {
                                                outX := lastX
                                                outY := lastY
                                                return
                                            }

                                            outX := ""
                                            outY := ""

                                            WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                            searchX1 := winX + 835
                                            searchY1 := winY + 30
                                            searchX2 := winX + 1019
                                            searchY2 := winY + 48

                                            if (ok := FindText(x, y, searchX1, searchY1, searchX2, searchY2, 0, 0, NavText)) {
                                                results := []
                                                for i, v in ok {
                                                    results.Push({x: v.x, id: v.id})
                                                }

                                                resultsLen := results.MaxIndex()
                                                ; Safety check: limit sorting to prevent infinite loops
                                                if (resultsLen > 0 && resultsLen <= 50) {
                                                    ; Optimized bubble sort with safety limits
                                                    maxIterations := resultsLen * resultsLen ; Prevent infinite loops
                                                    iterations := 0

                                                    Loop % resultsLen - 1 {
                                                        i := A_Index
                                                        Loop % resultsLen - i {
                                                            j := A_Index + i
                                                            iterations++
                                                            if (iterations > maxIterations) {
                                                                break 2 ; Exit both loops if too many iterations
                                                            }
                                                            if (results[i].x > results[j].x) {
                                                                temp := results[i]
                                                                results[i] := results[j]
                                                                results[j] := temp
                                                            }
                                                        }
                                                    }
                                                }

                                                coordX := ""
                                                coordY := ""
                                                spaceFound := false

                                                for i, v in results {
                                                    if (i > 1) {
                                                        prevX := results[i-1].x
                                                        gap := v.x - prevX
                                                        if (gap > 9 && !spaceFound) {
                                                            spaceFound := true
                                                        }
                                                    }

                                                    if (!spaceFound) {
                                                        coordX .= v.id
                                                    } else {
                                                        coordY .= v.id
                                                    }
                                                }

                                                outX := coordX + 0
                                                outY := coordY + 0

                                                ; Update cache
                                                lastX := outX
                                                lastY := outY
                                                lastCheckTime := currentTime
                                            }
                                        }

                                        ShowSearchArea() {
                                            if (!TargetGameWindow) {
                                                MsgBox, 0, Error, Please select a window first!
                                                return
                                            }

                                            WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                            searchX1 := winX + 835
                                            searchY1 := winY + 30
                                            searchX2 := winX + 1019
                                            searchY2 := winY + 48

                                            Gui, New, +ToolWindow -Caption +AlwaysOnTop, Top
                                            Gui, Color, Red
                                            Gui, Show, x%searchX1% y%searchY1% w184 h2, Top

                                            Gui, New, +ToolWindow -Caption +AlwaysOnTop, Bottom
                                            Gui, Color, Red
                                            bottomY := searchY2 - 2
                                            Gui, Show, x%searchX1% y%bottomY% w184 h2, Bottom

                                            Gui, New, +ToolWindow -Caption +AlwaysOnTop, Left
                                            Gui, Color, Red
                                            Gui, Show, x%searchX1% y%searchY1% w2 h18, Left

                                            Gui, New, +ToolWindow -Caption +AlwaysOnTop, Right
                                            Gui, Color, Red
                                            rightX := searchX2 - 2
                                            Gui, Show, x%rightX% y%searchY1% w2 h18, Right

                                            Sleep, 5000
                                            Gui, Top:Destroy
                                            Gui, Bottom:Destroy
                                            Gui, Left:Destroy
                                            Gui, Right:Destroy
                                        }

                                        UpdateCoordinateDisplay()

                                        ; Build message text explicitly
                                        messageText := "Area set to:"
                                        messageText .= "`nX1: " . checkweightX1 . ", Y1: " . checkweightY1
                                        messageText .= "`nX2: " . checkweightX2 . ", Y2: " . checkweightY2
                                        messageText .= "`n`nCoordinates saved!"

                                        MsgBox, 64, Success, %messageText%

                                        Gui, Show
                                        return

                                        CreateVisualTargetNode(node) {
                                            global

                                            ; Check if already exists
                                            if (NodeGUIs[node.id])
                                                return

                                            ; Set flag to prevent update conflicts
                                            CreatingGUI := true

                                            ; Get current player coordinates
                                            GetCurrentCoordinates(playerX, playerY)
                                            if (playerX = "" || playerY = "") {
                                                CreatingGUI := false
                                                return
                                            }

                                            ; Get game window position
                                            WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%

                                            ; Calculate where node should appear based on target world coordinates
                                            deltaX := node.worldX - playerX
                                            deltaY := node.worldY - playerY

                                            ; Use EXACT same calculation as NavigateToCoordinatesClick
                                            ; Calculate Y scaling based on camera radius
                                            if (CameraRadius <= 900) {
                                                pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                            } else if (CameraRadius <= 1000) {
                                                t := (CameraRadius - 900) / 100
                                                pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                            } else if (CameraRadius <= 1500) {
                                                t := (CameraRadius - 1000) / 500
                                                pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                            } else {
                                                t := (CameraRadius - 1500) / 500
                                                pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                            }

                                            ; Apply base scaling
                                            scaledX := -deltaX * 1.21
                                            scaledY := deltaY * pixelsPerGameUnitY ; POSITIVE for display

                                            ; Apply distance correction
                                            scaledX := scaledX * 0.94
                                            scaledY := scaledY * 1.19

                                            ; Apply camera rotation (NO radian conversion)
                                            cos_angle := Cos(-CameraAngle)
                                            sin_angle := Sin(-CameraAngle)
                                            rotatedX := scaledX * cos_angle - scaledY * sin_angle
                                            rotatedY := scaledX * sin_angle + scaledY * cos_angle

                                            ; Calculate screen position - Use PLUS for Y when displaying (opposite of clicking)
                                            screenX := winX + 516 + Round(rotatedX) - (NodeSize // 2)
                                            screenY := winY + 410 + Round(rotatedY) - (NodeSize // 2)

                                            ; Create node GUI with unique name
                                            guiName := "TargetNode" . node.id

                                            ; Simple approach: just create the GUI
                                            Gui, %guiName%:New, +AlwaysOnTop +ToolWindow -Caption
                                            Gui, %guiName%:Color, FF0000
                                            Gui, %guiName%:Font, s8 cWhite Bold

                                            nodeIDText := node.id
                                            Gui, %guiName%:Add, Text, x0 y0 w%NodeSize% h%NodeSize% Center BackgroundTrans, %nodeIDText%
                                            Gui, %guiName%:Show, x%screenX% y%screenY% w%NodeSize% h%NodeSize% NA
                                            WinSet, Transparent, 150, %guiName%
                                            ; Make it click-through using DllCall
                                            WinGet, nodeHwnd, ID, %guiName%
                                            ; Get current extended style
                                            exStyle := DllCall("GetWindowLong", "Ptr", nodeHwnd, "Int", -20, "UInt")
                                            ; Add WS_EX_TRANSPARENT (0x20) and WS_EX_LAYERED (0x80000)
                                            exStyle := exStyle | 0x20 | 0x80000
                                            ; Set the new extended style
                                            DllCall("SetWindowLong", "Ptr", nodeHwnd, "Int", -20, "UInt", exStyle)

                                            ; Store GUI name
                                            NodeGUIs[node.id] := guiName

                                            ; Clear flag
                                            CreatingGUI := false

                                            ; Start update timer if not already running (500ms for better performance)
                                            SetTimer, UpdateAllTargetNodes, 500
                                        }

                                        UpdateNodeWorldCoordinatesInMoveMode(nodeID) {
                                            global

                                            ; Find the node in the array
                                            nodeIndex := 0
                                            for index, node in TargetNodes {
                                                if (node.id = nodeID) {
                                                    nodeIndex := index
                                                    break
                                                }
                                            }

                                            if (nodeIndex = 0)
                                                return

                                            ; Get the current GUI position
                                            guiName := NodeGUIs[nodeID]
                                            if (!guiName)
                                                return

                                            ; Get GUI screen position
                                            WinGetPos, guiX, guiY,,, %guiName%
                                            if (ErrorLevel)
                                                return

                                            ; Calculate center of the GUI
                                            screenX := guiX + (NodeSize // 2)
                                            screenY := guiY + (NodeSize // 2)

                                            ; Get current player coordinates
                                            GetCurrentCoordinates(playerX, playerY)
                                            if (playerX = "" || playerY = "")
                                                return

                                            ; Get game window position
                                            WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                            if (ErrorLevel)
                                                return

                                            ; Calculate pixel offset from character center
                                            baseScreenX := winX + 516
                                            baseScreenY := winY + 410
                                            pixelDeltaX := screenX - baseScreenX
                                            pixelDeltaY := screenY - baseScreenY

                                            ; Reverse the coordinate conversion to get world coordinates
                                            ; Undo rotation
                                            rotatedDeltaX := pixelDeltaX * Cos(CameraAngle) - pixelDeltaY * Sin(CameraAngle)
                                            rotatedDeltaY := pixelDeltaX * Sin(CameraAngle) + pixelDeltaY * Cos(CameraAngle)

                                            ; Undo distance scaling
                                            rotatedDeltaX /= 0.94
                                            rotatedDeltaY /= 1.19

                                            ; Undo base scaling (note: negative for X)
                                            worldDeltaX := -rotatedDeltaX / 1.21
                                            worldDeltaY := rotatedDeltaY / 0.95

                                            ; Calculate new world coordinates
                                            newWorldX := Round(playerX + worldDeltaX, 2)
                                            newWorldY := Round(playerY + worldDeltaY, 2)

                                            ; Update the node in the array (but don't save yet)
                                            TargetNodes[nodeIndex].worldX := newWorldX
                                            TargetNodes[nodeIndex].worldY := newWorldY

                                            ; Mark this node as moved
                                            NodesMovedDuringSession[nodeID] := true

                                            ; Force immediate position update based on new coordinates
                                            deltaX := newWorldX - playerX
                                            deltaY := newWorldY - playerY

                                            ; Apply scaling factors
                                            scaledX := -deltaX * 1.21
                                            scaledY := deltaY * 0.95

                                            ; Apply distance correction
                                            scaledX *= 0.94
                                            scaledY *= 1.19

                                            ; Apply camera rotation
                                            rotatedX := scaledX * Cos(CameraAngle) - scaledY * Sin(CameraAngle)
                                            rotatedY := scaledX * Sin(CameraAngle) + scaledY * Cos(CameraAngle)

                                            ; Calculate screen position
                                            screenX := winX + 516 + Round(rotatedX)
                                            screenY := winY + 410 + Round(rotatedY)

                                            ; Update node position immediately
                                            nodeX := screenX - (NodeSize // 2)
                                            nodeY := screenY - (NodeSize // 2)

                                            Gui, %guiName%:Show, x%nodeX% y%nodeY% NA
                                        }

                                        UpdateNodeWorldCoordinates(nodeID) {
                                            global

                                            ; Find the node in the array
                                            nodeIndex := 0
                                            for index, node in TargetNodes {
                                                if (node.id = nodeID) {
                                                    nodeIndex := index
                                                    break
                                                }
                                            }

                                            if (nodeIndex = 0) {
                                                ToolTip, Error: Node #%nodeID% not found!, 0, 0
                                                SetTimer, ClearTooltip, -2000
                                                return
                                            }

                                            ; Get the current GUI position
                                            guiName := NodeGUIs[nodeID]
                                            if (!guiName) {
                                                ToolTip, Error: GUI for node #%nodeID% not found!, 0, 0
                                                    SetTimer, ClearTooltip, -2000
                                                return
                                            }

                                            ; Get GUI screen position
                                            WinGetPos, guiX, guiY,,, %guiName%
                                            if (ErrorLevel) {
                                                ToolTip, Error: Could not get GUI position for node #%nodeID%!, 0, 0
                                                SetTimer, ClearTooltip, -2000
                                                return
                                            }

                                            ; Calculate center of the GUI
                                            screenX := guiX + (NodeSize // 2)
                                            screenY := guiY + (NodeSize // 2)

                                            ; Get current player coordinates
                                            GetCurrentCoordinates(playerX, playerY)
                                            if (playerX = "" || playerY = "") {
                                                ToolTip, Error: Could not get current coordinates!, 0, 0
                                                SetTimer, ClearTooltip, -2000
                                                return
                                            }

                                            ; Get game window position
                                            WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                            if (ErrorLevel) {
                                                ToolTip, Error: Could not get window position!, 0, 0
                                                SetTimer, ClearTooltip, -2000
                                                return
                                            }

                                            ; Calculate pixel offset from character center
                                            baseScreenX := winX + 516
                                            baseScreenY := winY + 410
                                            pixelDeltaX := screenX - baseScreenX
                                            pixelDeltaY := screenY - baseScreenY

                                            ; Reverse the coordinate conversion to get world coordinates
                                            ; Undo rotation
                                            rotatedDeltaX := pixelDeltaX * Cos(CameraAngle) - pixelDeltaY * Sin(CameraAngle)
                                            rotatedDeltaY := pixelDeltaX * Sin(CameraAngle) + pixelDeltaY * Cos(CameraAngle)

                                            ; Undo distance scaling
                                            rotatedDeltaX /= 0.94
                                            rotatedDeltaY /= 1.19

                                            ; Undo base scaling (note: negative for X)
                                            worldDeltaX := -rotatedDeltaX / 1.21
                                            worldDeltaY := rotatedDeltaY / 0.95

                                            ; Calculate new world coordinates
                                            newWorldX := Round(playerX + worldDeltaX, 2)
                                            newWorldY := Round(playerY + worldDeltaY, 2)

                                            ; Update the node in the array
                                            TargetNodes[nodeIndex].worldX := newWorldX
                                            TargetNodes[nodeIndex].worldY := newWorldY

                                            ; Save updated nodes to file
                                            SaveNodes()

                                            ; Force immediate position update based on new coordinates
                                            ; This ensures the GUI stays at the new position
                                            WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                            if (!ErrorLevel) {
                                                deltaX := newWorldX - playerX
                                                deltaY := newWorldY - playerY

                                                ; Apply scaling factors
                                                scaledX := -deltaX * 1.21
                                                scaledY := deltaY * 0.95

                                                ; Apply distance correction
                                                scaledX *= 0.94
                                                scaledY *= 1.19

                                                ; Apply camera rotation
                                                rotatedX := scaledX * Cos(CameraAngle) - scaledY * Sin(CameraAngle)
                                                rotatedY := scaledX * Sin(CameraAngle) + scaledY * Cos(CameraAngle)

                                                ; Calculate screen position
                                                screenX := winX + 516 + Round(rotatedX)
                                                screenY := winY + 410 + Round(rotatedY)

                                                ; Update node position immediately
                                                nodeX := screenX - (NodeSize // 2)
                                                nodeY := screenY - (NodeSize // 2)

                                                Gui, %guiName%:Show, x%nodeX% y%nodeY% NA
                                            }

                                            ; Show confirmation tooltip
                                            ToolTip, Node #%nodeID% moved to X:%newWorldX% Y:%newWorldY%, 0, 0
                                            SetTimer, ClearTooltip, -2000
                                        }

                                        UpdateWaypointWorldCoordinates(waypointIndex) {
                                            global

                                            ; Check if waypoint exists
                                            if (waypointIndex < 1 || waypointIndex > Waypoints.Length()) {
                                                ToolTip, Error: Waypoint #%waypointIndex% not found!, 0, 0
                                                SetTimer, ClearTooltip, -2000
                                                return
                                            }

                                            ; Get the current GUI position
                                            guiName := WaypointGUIs[waypointIndex]
                                            if (!guiName) {
                                                ToolTip, Error: GUI for waypoint #%waypointIndex% not found!, 0, 0
                                                    SetTimer, ClearTooltip, -2000
                                                return
                                            }

                                            ; Get GUI screen position
                                            WinGetPos, guiX, guiY,,, %guiName%
                                            if (ErrorLevel) {
                                                ToolTip, Error: Could not get GUI position for waypoint #%waypointIndex%!, 0, 0
                                                SetTimer, ClearTooltip, -2000
                                                return
                                            }

                                            ; Calculate center of the GUI
                                            screenX := guiX + (WaypointSize // 2)
                                            screenY := guiY + (WaypointSize // 2)

                                            ; Get current player coordinates
                                            GetCurrentCoordinates(playerX, playerY)
                                            if (playerX = "" || playerY = "") {
                                                ToolTip, Error: Could not get current coordinates!, 0, 0
                                                SetTimer, ClearTooltip, -2000
                                                return
                                            }

                                            ; Get game window position
                                            WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                            if (ErrorLevel) {
                                                ToolTip, Error: Could not get window position!, 0, 0
                                                SetTimer, ClearTooltip, -2000
                                                return
                                            }

                                            ; Calculate pixel offset from character center
                                            baseScreenX := winX + 516
                                            baseScreenY := winY + 410
                                            pixelDeltaX := screenX - baseScreenX
                                            pixelDeltaY := screenY - baseScreenY

                                            ; Reverse the coordinate conversion to get world coordinates
                                            ; Undo rotation
                                            rotatedDeltaX := pixelDeltaX * Cos(CameraAngle) - pixelDeltaY * Sin(CameraAngle)
                                            rotatedDeltaY := pixelDeltaX * Sin(CameraAngle) + pixelDeltaY * Cos(CameraAngle)

                                            ; Undo distance scaling
                                            rotatedDeltaX /= 0.94
                                            rotatedDeltaY /= 1.19

                                            ; Undo base scaling (note: negative for X)
                                            worldDeltaX := -rotatedDeltaX / 1.21
                                            worldDeltaY := rotatedDeltaY / 0.95

                                            ; Calculate new world coordinates
                                            newWorldX := Round(playerX + worldDeltaX, 2)
                                            newWorldY := Round(playerY + worldDeltaY, 2)

                                            ; Update the waypoint in the array
                                            Waypoints[waypointIndex].x := newWorldX
                                            Waypoints[waypointIndex].y := newWorldY

                                            ; Save updated waypoint to route file
                                            if (SelectedRouteFile) {
                                                IniWrite, %newWorldX%, %SelectedRouteFile%, Waypoints, X%waypointIndex%
                                                IniWrite, %newWorldY%, %SelectedRouteFile%, Waypoints, Y%waypointIndex%
                                            }

                                            ; Force immediate position update based on new coordinates
                                            ; This ensures the GUI stays at the new position
                                            deltaX := newWorldX - playerX
                                            deltaY := newWorldY - playerY

                                            ; Apply scaling factors
                                            scaledX := -deltaX * 1.21
                                            scaledY := deltaY * 0.95 ; POSITIVE for display

                                            ; Apply distance correction
                                            scaledX *= 0.94
                                            scaledY *= 1.19

                                            ; Apply camera rotation
                                            rotatedX := scaledX * Cos(CameraAngle) - scaledY * Sin(CameraAngle)
                                            rotatedY := scaledX * Sin(CameraAngle) + scaledY * Cos(CameraAngle)

                                            ; Calculate screen position - Use PLUS for Y when displaying
                                            screenX := winX + 516 + Round(rotatedX)
                                            screenY := winY + 410 + Round(rotatedY)

                                            ; Update waypoint position immediately
                                            waypointX := screenX - (WaypointSize // 2)
                                            waypointY := screenY - (WaypointSize // 2)

                                            Gui, %guiName%:Show, x%waypointX% y%waypointY% NA

                                            ; Show confirmation tooltip
                                            ToolTip, Waypoint #%waypointIndex% moved to X:%newWorldX% Y:%newWorldY%, 0, 0
                                            SetTimer, ClearTooltip, -2000
                                        }

                                        CreateVisualWaypoint(waypointIndex, worldX, worldY) {
                                            global

                                            ; Check if already exists
                                            if (WaypointGUIs[waypointIndex])
                                                return

                                            ; Set flag to prevent update conflicts
                                            CreatingGUI := true

                                            ; Get current player coordinates
                                            GetCurrentCoordinates(playerX, playerY)
                                            if (playerX = "" || playerY = "") {
                                                CreatingGUI := false
                                                return
                                            }

                                            ; Get game window position
                                            WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%

                                            ; Calculate where waypoint should appear based on world coordinates
                                            deltaX := worldX - playerX
                                            deltaY := worldY - playerY

                                            ; Use EXACT same calculation as nodes
                                            ; Calculate Y scaling based on camera radius
                                            if (CameraRadius <= 900) {
                                                pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                            } else if (CameraRadius <= 1000) {
                                                t := (CameraRadius - 900) / 100
                                                pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                            } else if (CameraRadius <= 1500) {
                                                t := (CameraRadius - 1000) / 500
                                                pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                            } else {
                                                t := (CameraRadius - 1500) / 500
                                                pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                            }

                                            ; Apply base scaling
                                            scaledX := -deltaX * 1.21
                                            scaledY := deltaY * pixelsPerGameUnitY ; POSITIVE for display

                                            ; Apply distance correction
                                            scaledX := scaledX * 0.94
                                            scaledY := scaledY * 1.19

                                            ; Apply camera rotation (NO radian conversion)
                                            cos_angle := Cos(-CameraAngle)
                                            sin_angle := Sin(-CameraAngle)
                                            rotatedX := scaledX * cos_angle - scaledY * sin_angle
                                            rotatedY := scaledX * sin_angle + scaledY * cos_angle

                                            ; Calculate screen position - Use PLUS for Y when displaying (opposite of clicking)
                                            screenX := winX + 516 + Round(rotatedX) - (WaypointSize // 2)
                                            screenY := winY + 410 + Round(rotatedY) - (WaypointSize // 2)

                                            ; Create waypoint GUI with unique name (GREEN color)
                                            guiName := "Waypoint" . waypointIndex

                                            ; Simple approach: just create the GUI
                                            Gui, %guiName%:New, +AlwaysOnTop +ToolWindow -Caption
                                            Gui, %guiName%:Color, 00FF00
                                            Gui, %guiName%:Font, s8 cWhite Bold

                                            waypointText := waypointIndex
                                            Gui, %guiName%:Add, Text, x0 y0 w%WaypointSize% h%WaypointSize% Center BackgroundTrans, %waypointText%
                                            Gui, %guiName%:Show, x%screenX% y%screenY% w%WaypointSize% h%WaypointSize% NA
                                            WinSet, Transparent, 150, %guiName%
                                            ; Make it click-through using DllCall
                                            WinGet, waypointHwnd, ID, %guiName%
                                            ; Get current extended style
                                            exStyle := DllCall("GetWindowLong", "Ptr", waypointHwnd, "Int", -20, "UInt")
                                            ; Add WS_EX_TRANSPARENT (0x20) and WS_EX_LAYERED (0x80000)
                                            exStyle := exStyle | 0x20 | 0x80000
                                            ; Set the new extended style
                                            DllCall("SetWindowLong", "Ptr", waypointHwnd, "Int", -20, "UInt", exStyle)

                                            ; Store GUI name
                                            WaypointGUIs[waypointIndex] := guiName

                                            ; Clear flag
                                            CreatingGUI := false

                                            ; Start update timer if not already running
                                            SetTimer, UpdateAllWaypoints, 250
                                        }

                                        UpdateAllTargetNodes:
                                            ; Skip if currently creating a GUI to prevent conflicts
                                            if (CreatingGUI)
                                                return

                                            if (TargetNodes.Length() = 0) {
                                                SetTimer, UpdateAllTargetNodes, Off
                                                return
                                            }

                                            ; Get current player coordinates
                                            GetCurrentCoordinates(playerX, playerY)
                                            if (playerX = "" || playerY = "") {
                                                return
                                            }

                                            ; Only update if player moved significantly (reduces flicker)
                                            deltaMove := Sqrt((playerX - LastPlayerX)**2 + (playerY - LastPlayerY)**2)
                                            if (deltaMove < 1) {
                                                return
                                            }
                                            LastPlayerX := playerX
                                            LastPlayerY := playerY

                                            ; Get game window position
                                            WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                            if (ErrorLevel) {
                                                return
                                            }

                                            ; First pass: calculate distances and sort nodes by proximity
                                            nodeDistances := []
                                            for index, node in TargetNodes {
                                                deltaX := node.worldX - playerX
                                                deltaY := node.worldY - playerY
                                                distance := Sqrt(deltaX**2 + deltaY**2)
                                                nodeDistances.Push({index: index, node: node, distance: distance})
                                            }

                                            ; Sort by distance (bubble sort for simplicity)
                                            Loop % nodeDistances.Length() - 1 {
                                                i := A_Index
                                                Loop % nodeDistances.Length() - i {
                                                    j := A_Index
                                                    if (nodeDistances[j].distance > nodeDistances[j+1].distance) {
                                                        temp := nodeDistances[j]
                                                        nodeDistances[j] := nodeDistances[j+1]
                                                        nodeDistances[j+1] := temp
                                                    }
                                                }
                                            }

                                            ; Second pass: show only closest nodes within range
                                            maxVisibleNodes := 12
                                            maxDistance := 500
                                            visibleCount := 0

                                            for index, nodeData in nodeDistances {
                                                node := nodeData.node
                                                distance := nodeData.distance
                                                guiName := NodeGUIs[node.id]

                                                ; Check if this node should be visible
                                                shouldShow := (ShowTargetNodes && distance <= maxDistance && visibleCount < maxVisibleNodes)

                                                if (shouldShow) {
                                                    visibleCount++

                                                    ; Create GUI if it doesn't exist yet
                                                    if (!guiName) {
                                                        CreateVisualTargetNode(node)
                                                        guiName := NodeGUIs[node.id]
                                                    }

                                                    if (!guiName)
                                                        continue

                                                    ; Calculate delta in world coordinates
                                                    deltaX := node.worldX - playerX
                                                    deltaY := node.worldY - playerY

                                                    ; Use EXACT same calculation as NavigateToCoordinatesClick
                                                    ; Calculate Y scaling based on camera radius
                                                    if (CameraRadius <= 900) {
                                                        pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                    } else if (CameraRadius <= 1000) {
                                                        t := (CameraRadius - 900) / 100
                                                        pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                    } else if (CameraRadius <= 1500) {
                                                        t := (CameraRadius - 1000) / 500
                                                        pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                    } else {
                                                        t := (CameraRadius - 1500) / 500
                                                        pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                                    }

                                                    ; Apply base scaling
                                                    scaledX := -deltaX * 1.21
                                                    scaledY := deltaY * pixelsPerGameUnitY ; POSITIVE - display is opposite of click conversion

                                                    ; Apply distance correction
                                                    scaledX := scaledX * 0.94
                                                    scaledY := scaledY * 1.19

                                                    ; Apply camera rotation (NO radian conversion - CameraAngle is already in the right units)
                                                    cos_angle := Cos(-CameraAngle)
                                                    sin_angle := Sin(-CameraAngle)
                                                    rotatedX := scaledX * cos_angle - scaledY * sin_angle
                                                    rotatedY := scaledX * sin_angle + scaledY * cos_angle

                                                    ; Convert to screen coordinates
                                                    screenX := winX + 516 + Round(rotatedX)
                                                    screenY := winY + 410 + Round(rotatedY)

                                                    ; Update node position
                                                    nodeX := screenX - (NodeSize // 2)
                                                    nodeY := screenY - (NodeSize // 2)

                                                    Gui, %guiName%:Show, x%nodeX% y%nodeY% NA
                                                    ; Reapply click-through after show
                                                    WinGet, nodeHwnd, ID, %guiName%
                                                    if (nodeHwnd) {
                                                        MakeWindowClickThroughByHandle(nodeHwnd)
                                                    }
                                                } else if (guiName) {
                                                    ; Hide nodes that are too far or beyond the limit (only if GUI exists)
                                                    Gui, %guiName%:Hide
                                                }
                                            }
                                        return

                                        UpdateAllWaypoints:
                                            ; Skip if currently creating a GUI to prevent conflicts
                                            if (CreatingGUI)
                                                return

                                            if (Waypoints.Length() = 0) {
                                                SetTimer, UpdateAllWaypoints, Off
                                                return
                                            }

                                            ; Get current player coordinates
                                            GetCurrentCoordinates(playerX, playerY)
                                            if (playerX = "" || playerY = "") {
                                                return
                                            }

                                            ; Get game window position
                                            WinGetPos, winX, winY,,, ahk_id %TargetGameWindow%
                                            if (ErrorLevel) {
                                                return
                                            }

                                            ; First pass: calculate distances and sort waypoints by proximity
                                            waypointDistances := []
                                            for waypointIndex, waypoint in Waypoints {
                                                deltaX := waypoint.x - playerX
                                                deltaY := waypoint.y - playerY
                                                distance := Sqrt(deltaX**2 + deltaY**2)
                                                waypointDistances.Push({index: waypointIndex, waypoint: waypoint, distance: distance})
                                            }

                                            ; Sort by distance (bubble sort for simplicity)
                                            Loop % waypointDistances.Length() - 1 {
                                                i := A_Index
                                                Loop % waypointDistances.Length() - i {
                                                    j := A_Index
                                                    if (waypointDistances[j].distance > waypointDistances[j+1].distance) {
                                                        temp := waypointDistances[j]
                                                        waypointDistances[j] := waypointDistances[j+1]
                                                        waypointDistances[j+1] := temp
                                                    }
                                                }
                                            }

                                            ; Second pass: show only closest waypoints within range
                                            maxVisibleWaypoints := 12
                                            maxDistance := 500
                                            visibleCount := 0

                                            for index, waypointData in waypointDistances {
                                                waypointIndex := waypointData.index
                                                waypoint := waypointData.waypoint
                                                distance := waypointData.distance
                                                guiName := WaypointGUIs[waypointIndex]

                                                ; Check if this waypoint should be visible
                                                shouldShow := (ShowWaypoints && distance <= maxDistance && visibleCount < maxVisibleWaypoints)

                                                if (shouldShow) {
                                                    visibleCount++

                                                    ; Create GUI if it doesn't exist yet
                                                    if (!guiName) {
                                                        CreateVisualWaypoint(waypointIndex, waypoint.x, waypoint.y)
                                                        guiName := WaypointGUIs[waypointIndex]
                                                    }

                                                    if (!guiName)
                                                        continue

                                                    ; Calculate delta in world coordinates
                                                    deltaX := waypoint.x - playerX
                                                    deltaY := waypoint.y - playerY

                                                    ; Use EXACT same calculation as nodes
                                                    ; Calculate Y scaling based on camera radius
                                                    if (CameraRadius <= 900) {
                                                        pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                                    } else if (CameraRadius <= 1000) {
                                                        t := (CameraRadius - 900) / 100
                                                        pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                                    } else if (CameraRadius <= 1500) {
                                                        t := (CameraRadius - 1000) / 500
                                                        pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                                    } else {
                                                        t := (CameraRadius - 1500) / 500
                                                        pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                                    }

                                                    ; Apply base scaling
                                                    scaledX := -deltaX * 1.21
                                                    scaledY := deltaY * pixelsPerGameUnitY ; POSITIVE - display is opposite of click conversion

                                                    ; Apply distance correction
                                                    scaledX := scaledX * 0.94
                                                    scaledY := scaledY * 1.19

                                                    ; Apply camera rotation (NO radian conversion)
                                                    cos_angle := Cos(-CameraAngle)
                                                    sin_angle := Sin(-CameraAngle)
                                                    rotatedX := scaledX * cos_angle - scaledY * sin_angle
                                                    rotatedY := scaledX * sin_angle + scaledY * cos_angle

                                                    ; Convert to screen coordinates
                                                    screenX := winX + 516 + Round(rotatedX)
                                                    screenY := winY + 410 + Round(rotatedY)

                                                    ; Update waypoint position
                                                    waypointX := screenX - (WaypointSize // 2)
                                                    waypointY := screenY - (WaypointSize // 2)

                                                    Gui, %guiName%:Show, x%waypointX% y%waypointY% NA
                                                    ; Reapply click-through after show
                                                    WinGet, waypointHwnd, ID, %guiName%
                                                    if (waypointHwnd) {
                                                        MakeWindowClickThroughByHandle(waypointHwnd)
                                                    }
                                                } else if (guiName) {
                                                    ; Hide waypoints that are too far or beyond the limit (only if GUI exists)
                                                    Gui, %guiName%:Hide
                                                }
                                            }
                                        return

                                        ; ========= HEAL/DPS PATTERN FUNCTIONS =========

                                        LoadPatternsFromINI() {
                                            global CapturedTextINI, patterns, patternKeys, patternNames
                                            global dpsPatterns, dpsPatternKeys, dpsPatternNames
                                            global healPriorities, dpsPriorities
                                            global SkillBarX1, SkillBarY1, SkillBarX2, SkillBarY2

                                            ; Load skill bar coordinates
                                            IniRead, loadedX1, %CapturedTextINI%, SkillbarArea, X1, %SkillBarX1%
                                            IniRead, loadedY1, %CapturedTextINI%, SkillbarArea, Y1, %SkillBarY1%
                                            IniRead, loadedX2, %CapturedTextINI%, SkillbarArea, X2, %SkillBarX2%
                                            IniRead, loadedY2, %CapturedTextINI%, SkillbarArea, Y2, %SkillBarY2%

                                            if (loadedX1 != "ERROR") SkillBarX1 := loadedX1
                                                if (loadedY1 != "ERROR") SkillBarY1 := loadedY1
                                                if (loadedX2 != "ERROR") SkillBarX2 := loadedX2
                                                if (loadedY2 != "ERROR") SkillBarY2 := loadedY2

                                            ; Load all patterns from [Patterns] section (heal patterns)
                                            IniRead, sectionList, %CapturedTextINI%, Patterns
                                            if (sectionList = "ERROR" || sectionList = "") {
                                                ;MsgBox, Error: Could not read Patterns section from INI!`n`nFile: %CapturedTextINI%
                                                return
                                            }

                                            Loop, Parse, sectionList, `n, `r
                                            {
                                                ; Each line is "key=value", extract both key name and value
                                                line := A_LoopField
                                                if (line = "")
                                                    continue

                                                ; Find the = sign and split into key and value
                                                equalPos := InStr(line, "=")
                                                if (equalPos = 0)
                                                    continue

                                                patternName := SubStr(line, 1, equalPos - 1)
                                                patternText := SubStr(line, equalPos + 1)

                                                if (patternName = "" || patternText = "")
                                                    continue

                                                ; Store the pattern text directly from the line
                                                patterns[patternName] := patternText

                                                ; Still need to read assigned key and custom name from other sections
                                                IniRead, assignedKey, %CapturedTextINI%, PatternKeys, %patternName%, ERROR
                                                IniRead, customName, %CapturedTextINI%, PatternNames, %patternName%, ERROR

                                                patternKeys[patternName] := (assignedKey != "ERROR") ? assignedKey : ""
                                                    patternNames[patternName] := (customName != "ERROR") ? customName : patternName
                                                }

                                                ; Load all patterns from [DPSPatterns] section (DPS patterns)
                                                IniRead, dpsSectionList, %CapturedTextINI%, DPSPatterns
                                                if (dpsSectionList != "ERROR" && dpsSectionList != "") {
                                                    Loop, Parse, dpsSectionList, `n, `r
                                                    {
                                                        ; Each line is "key=value", extract both key name and value
                                                        line := A_LoopField
                                                        if (line = "")
                                                            continue

                                                        ; Find the = sign and split into key and value
                                                        equalPos := InStr(line, "=")
                                                        if (equalPos = 0)
                                                            continue

                                                        patternName := SubStr(line, 1, equalPos - 1)
                                                        patternText := SubStr(line, equalPos + 1)

                                                        if (patternName = "" || patternText = "")
                                                            continue

                                                        ; Store the pattern text directly from the line
                                                        patterns[patternName] := patternText
                                                        dpsPatterns[patternName] := patternText ; Also store in DPS-specific container

                                                        ; Read assigned key and custom name from DPS sections
                                                        IniRead, assignedKey, %CapturedTextINI%, DPSPatternKeys, %patternName%, ERROR
                                                        IniRead, customName, %CapturedTextINI%, DPSPatternNames, %patternName%, ERROR

                                                        patternKeys[patternName] := (assignedKey != "ERROR") ? assignedKey : ""
                                                            patternNames[patternName] := (customName != "ERROR") ? customName : patternName
                                                        dpsPatternKeys[patternName] := (assignedKey != "ERROR") ? assignedKey : ""
                                                            dpsPatternNames[patternName] := (customName != "ERROR") ? customName : patternName
                                                        }
                                                    }

                                                    ; Load heal priorities
                                                    IniRead, healPriorityList, %CapturedTextINI%, HealPriorities, Order, ERROR
                                                    if (healPriorityList != "ERROR" && healPriorityList != "") {
                                                        healPriorities := []
                                                        Loop, Parse, healPriorityList, `,
                                                        {
                                                            if (A_LoopField != "")
                                                                healPriorities.Push(A_LoopField)
                                                        }
                                                    }

                                                    ; Load DPS priorities
                                                    IniRead, dpsPriorityList, %CapturedTextINI%, DPSPriorities, Order, ERROR
                                                    if (dpsPriorityList != "ERROR" && dpsPriorityList != "") {
                                                        dpsPriorities := []
                                                        Loop, Parse, dpsPriorityList, `,
                                                        {
                                                            if (A_LoopField != "")
                                                                dpsPriorities.Push(A_LoopField)
                                                        }
                                                    }

                                                    ; Display loading summary
                                                    patternCount := 0
                                                    for key, value in patterns {
                                                        patternCount++
                                                    }

                                                    healCount := healPriorities.Length()
                                                    dpsCount := dpsPriorities.Length()

                                                    ; Load resource patterns from resources.ini
                                                    LoadResourcePatterns()

                                                    ; Recount patterns after loading resources
                                                    patternCount := 0
                                                    for key, value in patterns {
                                                        patternCount++
                                                    }

                                                    if (patternCount > 0) {
                                                        ToolTip, Loaded %patternCount% total patterns`nHeals: %healCount% | DPS: %dpsCount%
                                                        SetTimer, ClearLoadTooltip, -2000
                                                    }
                                                }

                                                LoadResourcePatterns() {
                                                    global patterns, patternKeys, patternNames, ResourcesINI

                                                    ; Load patterns from resources.ini [Patterns] section
                                                    IniRead, resourceList, %ResourcesINI%, Patterns
                                                    if (resourceList = "ERROR" || resourceList = "") {
                                                        ; No resource patterns found, that's okay
                                                        return
                                                    }

                                                    resourceCount := 0
                                                    Loop, Parse, resourceList, `n, `r
                                                    {
                                                        line := A_LoopField
                                                        if (line = "")
                                                            continue

                                                        equalPos := InStr(line, "=")
                                                        if (equalPos = 0)
                                                            continue

                                                        patternName := SubStr(line, 1, equalPos - 1)
                                                        patternText := SubStr(line, equalPos + 1)

                                                        if (patternName = "" || patternText = "")
                                                            continue

                                                        ; Store the pattern text
                                                        patterns[patternName] := patternText
                                                        resourceCount++

                                                        ; Set defaults for keys and names if not already set
                                                        if (!patternKeys.HasKey(patternName))
                                                            patternKeys[patternName] := ""
                                                        if (!patternNames.HasKey(patternName))
                                                            patternNames[patternName] := patternName
                                                    }
                                                }

                                                EnsureDefaultPatterns() {
                                                    global ResourcesINI

                                                    ; Define resource patterns that should be in resources.ini
                                                    resourcePatterns := {}
                                                    resourcePatterns["bdnpc"] := "|<>*146$20.zzzzzzzzzzzzzzzzzzzU"
                                                    resourcePatterns["entrance5"] := "|<>BCB0A0-0.90$27.00S00M00k01k03U07007s0Ds1zs3zU7y0Tw1zk3y07s0D00S"
                                                    resourcePatterns["bd5quest"] := "|<>1D8AE7-0.90$65.Ud89000002H22EG000004a8YVpVlNUC9AV91AYHAUWGO2G2F8YF04Yu4Y4WT8W1t9W9894UF44GH2GEG94W89YW2YUoFl4EB9A"

                                                    ; Ensure resources.ini exists and contains the patterns
                                                    for patternName, patternText in resourcePatterns {
                                                        IniRead, existingPattern, %ResourcesINI%, Patterns, %patternName%, ERROR

                                                        if (existingPattern = "ERROR") {
                                                            ; Pattern doesn't exist, add it
                                                            IniWrite, %patternText%, %ResourcesINI%, Patterns, %patternName%
                                                        }
                                                    }
                                                }

                                                CapturePattern:
                                                    ; Instructions similar to adddpsskill
                                                    MsgBox, 64, Capture Pattern, INSTRUCTIONS:`n`n1. Click OK to start capture mode`n2. Wait 2 seconds for you to get ready`n3. Press '1' when the pattern you want to capture is visible on screen`n4. The pattern will be captured automatically`n5. You'll be prompted to name and save the pattern

                                                    ; Wait for user to be ready (like adddpsskill)
                                                    Sleep, 2000

                                                    ; Tell user to press 1 when ready
                                                    ToolTip, Press '1' when the pattern to capture is visible on screen
                                                    KeyWait, 1, D
                                                    ToolTip

                                                    ; Capture from screen using FindText (exactly like adddpsskill)
                                                    capturedText := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)
                                                    Clipboard := capturedText

                                                    ; Validate we got something
                                                    if (capturedText = "") {
                                                        MsgBox, 48, No Pattern Captured, No pattern was captured!`n`nTry again and make sure the pattern is visible when you press '1'.
                                                        return
                                                    }

                                                    ; Validate pattern format (should contain |<>)
                                                    if (!InStr(capturedText, "|<>")) {
                                                        MsgBox, 48, Invalid Pattern, The captured text doesn't appear to be a valid FindText pattern!`n`nCaptured text: %capturedText%
                                                        return
                                                    }

                                                    ; Ask user for pattern name
                                                    InputBox, patternName, Save Pattern, Enter a name for this pattern (e.g., "door" or "npc"):, , 400, 150
                                                    if (ErrorLevel) {
                                                        MsgBox, 48, Cancelled, Pattern capture cancelled.
                                                        return
                                                    }

                                                    ; Validate pattern name
                                                    if (patternName = "") {
                                                        MsgBox, 16, Error, Pattern name cannot be empty!
                                                        return
                                                    }

                                                    ; Remove spaces and special characters from pattern name
                                                    StringReplace, patternName, patternName, %A_Space%,, All
                                                    Loop {
                                                        if RegExMatch(patternName, "[^a-zA-Z0-9_]") {
                                                            StringReplace, patternName, patternName, %A_LoopField%,, All
                                                        } else {
                                                            break
                                                        }
                                                    }

                                                    if (patternName = "") {
                                                        MsgBox, 16, Error, Invalid pattern name! Use only letters, numbers, and underscores.
                                                        return
                                                    }

                                                    ; Save to resources.ini
                                                    global ResourcesINI
                                                    FileEncoding, UTF-8
                                                    IniWrite, %capturedText%, %ResourcesINI%, Patterns, %patternName%
                                                    FileEncoding

                                                    ; Reload patterns into memory
                                                    LoadResourcePatterns()

                                                    MsgBox, 64, Success!, Pattern saved to resources.ini as: %patternName%`n`nPattern: %capturedText%`n`nYou can now use this in commands like:`nloopclickuntilpatternfound,31,31,maxclickcount,%patternName%, 
                                                return

                                                ClearLoadTooltip:
                                                    ToolTip
                                                return

                                                LoopCastUntilMobDead() {
                                                    global TargetGameWindow, win1

                                                    ; Mob health pattern
                                                    mobHealth := "|<>##0.90$0/0/9D7B3E,1/0/111111,2/0/010101,3/0/760E33,4/0/C6053F,5/0/D75079,5/1/C6053F,5/2/AE0538,5/3/FF1268,5/4/010101"

                                                    if (!TargetGameWindow) {
                                                        return
                                                    }

                                                    ; Get window position for searching
                                                    WinGetPos, winX, winY,,, ahk_id %win1%
                                                    if (winX = "" || winY = "") {
                                                        return
                                                    }

                                                    ; Record start time for timeout
                                                    loopStartTime := A_TickCount
                                                    maxLoopTimeMs := 45000 ; 45 seconds max loop time
                                                    timeoutMs := 4000 ; 4 seconds for mob death confirmation
                                                    notFoundStartTime := "" ; Initialize the timer variable

                                                    ; Loop until mob health bar is NOT found for 4 seconds OR 45 seconds elapsed
                                                    Loop {
                                                        ; Check if we've been looping too long (45 seconds)
                                                        elapsedLoopTime := A_TickCount - loopStartTime
                                                        if (elapsedLoopTime >= maxLoopTimeMs) {
                                                            ; 45 seconds elapsed, exit loop even if mob still alive
                                                            ToolTip, Mob still alive after 45 seconds - exiting combat loop, 0, 0
                                                                SetTimer, ClearTooltip, -3000
                                                            break
                                                        }

                                                        ; Check if mob health bar still exists
                                                        mobHealthFound := FindText(X, Y, winX, winY, winX + 1920, winY + 1080, 0, 0, mobHealth)

                                                        if (!mobHealthFound) {
                                                            ; Mob health not found - check if it's been gone for 4 seconds
                                                            if (notFoundStartTime = "") {
                                                                notFoundStartTime := A_TickCount
                                                            }

                                                            elapsedNotFound := A_TickCount - notFoundStartTime
                                                            if (elapsedNotFound >= timeoutMs) {
                                                                ; Mob has been dead for 4 seconds, exit loop
                                                                break
                                                            }
                                                        } else {
                                                            ; Mob health found - reset the "not found" timer
                                                            notFoundStartTime := ""
                                                        }

                                                        ; Try to cast heal first (to keep player alive)
                                                        TryCastHealingSkill()
                                                        Sleep, 100

                                                        ; Try to cast DPS
                                                        TryCastDPSSkills()
                                                        Sleep, 100
                                                        TryCastCC()

                                                        ; Small delay before next iteration
                                                        Sleep, 200
                                                    }
                                                }

                                                CheckMobHealth() {
                                                    global win1

                                                    ; Mob health pattern (same as LoopCastUntilMobDead)
                                                    mobHealth := "|<>##0.90$0/0/9D7B3E,1/0/111111,2/0/010101,3/0/760E33,4/0/C6053F,5/0/D75079,5/1/C6053F,5/2/AE0538,5/3/FF1268,5/4/010101"

                                                    ; Get window position for searching
                                                    WinGetPos, winX, winY,,, ahk_id %win1%
                                                    if (winX = "" || winY = "") {
                                                        return false
                                                    }

                                                    ; Check if mob health bar exists
                                                    mobHealthFound := FindText(X, Y, winX, winY, winX + 1920, winY + 1080, 0, 0, mobHealth)

                                                return mobHealthFound ? true : false
                                            }

                                            FarmUntilPattern(stopPattern) {
                                                global win1, patterns

                                                ; Check if pattern exists
                                                if (patterns[stopPattern] = "") {
                                                    MsgBox, 0, Error, Pattern '%stopPattern%' not found in resources.ini!, 3
                                                return
                                            }

                                            ToolTip, Starting farm mode. Press ESC to stop., 0, 0
                                            SetTimer, ClearTooltip, -2000

                                            ; Main farming loop
                                            Loop {
                                                ; Check if stop pattern is found
                                                WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                                                if (winX != "" and winY != "") {
                                                    searchX2 := winX + winW
                                                    searchY2 := winY + winH
                                                    patternFound := FindText(px, py, winX, winY, searchX2, searchY2, 0, 0, patterns[stopPattern])

                                                    if (patternFound) {
                                                        ToolTip, Pattern '%stopPattern%' found! Stopping farm., 0, 0
                                                        SetTimer, ClearTooltip, -3000
                                                        return
                                                    }
                                                }

                                                ; Check if ESC was pressed
                                                GetKeyState, escState, Escape, P
                                                if (escState = "D") {
                                                    ToolTip, ESC pressed - stopping farm., 0, 0
                                                    SetTimer, ClearTooltip, -3000
                                                return
                                            }

                                            ; Press Tab to target
                                            ToolTip, Tab targeting..., 0, 0
                                            ;WinActivate, ahk_id %win1%
                                            Sleep, 100
                                            ControlSend,, {Tab}, ahk_id %win1%
                                            Sleep, 500

                                            ; Check if mob health is found
                                            if (CheckMobHealth()) {
                                                ToolTip, Mob found - attacking..., 0, 0

                                                ; Call LoopCastUntilMobDead to kill the mob
                                                LoopCastUntilMobDead()

                                                ToolTip, Mob defeated. Looking for next target..., 0, 0
                                                    Sleep, 500
                                            } else {
                                                ; No mob found
                                                ToolTip, No mob targeted. Retrying..., 0, 0
                                                Sleep, 1000
                                            }

                                            ; Small delay before next iteration
                                            Sleep, 200
                                        }
                                    }

                                    ReEnterBD5() {
                                        global win1

                                        ; BD NPC pattern
                                        bdnpc := "|<>FF8400-0.90$71.w000U00E02004001000004004002000008000wD4S7GL0FsE24V92FYl0Y97Y92G4V921821Dm4Y92G42A22E498G4Y84604U8GEY98E820F2EYV8mEUG4j1sS8wCYV0XkU00000100000000001200000000001s00002"

                                        ; Entrance pattern
                                        entrance5 := "|<>BCB0A0-0.90$27.0007s000UUkk42NN0k+247lEFU3+2009EE01+200FDD0w000000000000000000000000000000000000000000000000040000U"

                                        ; Get window position for searching
                                        WinGetPos, winX, winY,,, ahk_id %win1%
                                        if (winX = "" || winY = "") {
                                            MsgBox, 0, Error, Could not get window position for BD5 re-entry!, 2
                                                return
                                        }

                                        ; Main loop: keep trying NPC -> Entrance sequence
                                        maxMainAttempts := 10 ; Try the whole sequence up to 10 times

                                        Loop, %maxMainAttempts% {
                                            mainAttempt := A_Index

                                            ; Step 1: Loop search for BD NPC
                                            npcFound := false
                                            Loop, 100 {
                                                npcResult := FindText(npcX, npcY, winX, winY, winX + 1920, winY + 1080, 0, 0, bdnpc)

                                                if (npcResult) {
                                                    npcFound := true
                                                    ; Double-click 5 pixels below the found location
                                                    clickX := npcX - winX
                                                    clickY := npcY - winY + 13

                                                    ; Use SendMessage for double click
                                                    lParam := (clickY << 16) | (clickX & 0xFFFF)

                                                    ; First click
                                                    SendMessage, 0x0200, 0, %lParam%, , ahk_id %win1% ; WM_MOUSEMOVE
                                                    Sleep, 20
                                                    SendMessage, 0x0201, 1, %lParam%, , ahk_id %win1% ; WM_LBUTTONDOWN
                                                    Sleep, 20
                                                    SendMessage, 0x0202, 0, %lParam%, , ahk_id %win1% ; WM_LBUTTONUP
                                                    Sleep, 50

                                                    ; Second click
                                                    SendMessage, 0x0201, 1, %lParam%, , ahk_id %win1% ; WM_LBUTTONDOWN
                                                    Sleep, 20
                                                    SendMessage, 0x0202, 0, %lParam%, , ahk_id %win1% ; WM_LBUTTONUP
                                                    Sleep, 500
                                                    break
                                                }

                                                Sleep, 100
                                            }

                                            if (!npcFound) {
                                                MsgBox, 0, Error, BD NPC not found after 100 attempts!, 2
                                                return
                                            }

                                            ; Step 2: Loop search for entrance
                                            entranceFound := false
                                            Loop, 100 {
                                                entranceResult := FindText(entranceX, entranceY, winX, winY, winX + 1920, winY + 1080, 0, 0, entrance5)

                                                if (entranceResult) {
                                                    entranceFound := true
                                                    ; Click at the entrance location
                                                    relEntranceX := entranceX - winX
                                                    relEntranceY := entranceY - winY
                                                    lParam := (relEntranceY << 16) | (relEntranceX & 0xFFFF)

                                                    SendMessage, 0x0200, 0, %lParam%, , ahk_id %win1% ; WM_MOUSEMOVE
                                                    Sleep, 20
                                                    SendMessage, 0x0201, 1, %lParam%, , ahk_id %win1% ; WM_LBUTTONDOWN
                                                    Sleep, 20
                                                    SendMessage, 0x0202, 0, %lParam%, , ahk_id %win1% ; WM_LBUTTONUP
                                                    Sleep, 100
                                                    ; Success! Exit the main loop
                                                return
                                            }

                                            Sleep, 100
                                        }

                                        ; If entrance not found, loop back to search for NPC again
                                        if (!entranceFound) {
                                            tooltipMsg := "Entrance not found (attempt " . mainAttempt . "/" . maxMainAttempts . "), retrying from NPC..."
                                            ToolTip, %tooltipMsg%, 0, 0
                                            SetTimer, ClearTooltip, -2000
                                            Sleep, 1000
                                            ; Continue to next iteration of main loop
                                        }
                                    }

                                    ; If we get here, all attempts failed
                                    failMsg := "BD5 entrance not found after " . maxMainAttempts . " complete attempts!"
                                    MsgBox, 0, Error, %failMsg%, 2
                                }

                                LoopClickUntilPatternMissing(nodeNum, patternNameOrText, maxClicks, backSteps) {
                                    global win1, patterns, Waypoints, CurrentWaypoint

                                    ; Check if patternNameOrText is an inline pattern (starts with |<) or a pattern name
                                    if (InStr(patternNameOrText, "|<") = 1) {
                                        ; It's an inline pattern text
                                        pattern := patternNameOrText
                                        patternDisplayName := "inline pattern"
                                    } else {
                                        ; It's a pattern name, load from patterns array
                                        pattern := patterns[patternNameOrText]
                                        patternDisplayName := patternNameOrText

                                        if (pattern = "") {
                                            MsgBox, 0, Error, Pattern '%patternNameOrText%' not found in patterns (check CapturedText.ini or resources.ini)!, 3
                                            return
                                        }
                                    }

                                    ; Get window position for searching
                                    WinGetPos, winX, winY,,, ahk_id %win1%
                                    if (winX = "" || winY = "") {
                                        MsgBox, 0, Error, Could not get window position!, 2
                                        return
                                    }

                                    ; Save the original waypoint to return to
                                    originalWaypoint := CurrentWaypoint

                                    ; First, verify the pattern actually exists before we start
                                    patternResult := FindText(px, py, winX, winY, winX + 1920, winY + 1080, 0, 0, pattern)
                                    if (!patternResult) {
                                        MsgBox, 0, Error, Pattern '%patternDisplayName%' not found at start! Cannot proceed., 3
                                        return
                                    }

                                    ToolTip, Pattern found! Starting click loop..., 0, 0
                                        Sleep, 1000

                                    ; Main retry loop (in case we need to move back and retry)
                                    maxRetries := 5 ; Maximum number of back-and-retry attempts

                                    Loop, %maxRetries% {
                                        retryAttempt := A_Index

                                        tooltipMsg := "Retry attempt " . retryAttempt . "/" . maxRetries
                                        ToolTip, %tooltipMsg%, 0, 0
                                        SetTimer, ClearTooltip, -2000

                                        ; Click the node up to maxClicks times
                                        clickCount := 0
                                        Loop, %maxClicks% {
                                            clickCount++

                                            tooltipMsg := "Clicking node " . nodeNum . " (click " . clickCount . "/" . maxClicks . ")"
                                            ToolTip, %tooltipMsg%, 0, 0

                                            ; Click the node (using worldclick logic)
                                            ClickAtNode(nodeNum)
                                            Sleep, 500

                                            ; Small delay to let the UI update before checking pattern
                                            Sleep, 200

                                            ; Check if pattern still exists AFTER the click
                                            patternResult := FindText(px, py, winX, winY, winX + 1920, winY + 1080, 0, 0, pattern)

                                            if (!patternResult) {
                                                ; Pattern is gone! Success
                                                successMsg := "Pattern '" . patternDisplayName . "' cleared after " . clickCount . " click(s)!"
                                                ToolTip, %successMsg%, 0, 0
                                                SetTimer, ClearTooltip, -2000
                                                return
                                            } else {
                                                tooltipMsg := "Pattern still found after click " . clickCount
                                                ToolTip, %tooltipMsg%, 0, 0
                                                Sleep, 500
                                            }
                                        }

                                        ; Pattern still found after maxClicks
                                        ; Check one more time after a short delay in case UI is updating
                                        Sleep, 1000
                                        patternResult := FindText(px, py, winX, winY, winX + 1920, winY + 1080, 0, 0, pattern)

                                        if (!patternResult) {
                                            ; Pattern is gone now! Success
                                            successMsg := "Pattern '" . patternDisplayName . "' cleared after delay!"
                                            ToolTip, %successMsg%, 0, 0
                                            SetTimer, ClearTooltip, -2000
                                            return
                                        }

                                        ; Pattern still found after maxClicks and delay
                                        ; Move back by backSteps waypoints and try again
                                        if (retryAttempt < maxRetries) {
                                            tooltipMsg := "Pattern still found after " . maxClicks . " clicks (retry " . retryAttempt . "/" . maxRetries . "), moving back " . backSteps . " waypoint(s)..."
                                            ToolTip, %tooltipMsg%, 0, 0
                                            SetTimer, ClearTooltip, -3000

                                            ; Calculate target waypoint to move back to
                                            backWaypoint := originalWaypoint - backSteps
                                            if (backWaypoint < 1) {
                                                backWaypoint := 1
                                            }

                                            ; Get the coordinates of the back waypoint
                                            if (backWaypoint <= Waypoints.Length()) {
                                                backWaypointObj := Waypoints[backWaypoint]
                                                backX := backWaypointObj.x
                                                backY := backWaypointObj.y

                                                ; Stop any current travel
                                                IsTraveling := false
                                                SetTimer, TravelLoop, Off
                                                Sleep, 200

                                                ; Navigate back using GoToWaypoint
                                                tooltipMsg := "Moving to waypoint " . backWaypoint . "..."
                                                ToolTip, %tooltipMsg%, 0, 0
                                                GoToWaypoint(backWaypoint)

                                                ; Wait for arrival by checking coordinates
                                                Loop, 50 { ; 5 second timeout (50 * 100ms)
                                                    GetCurrentCoordinates(currentX, currentY)
                                                    if (Abs(currentX - backX) <= DistanceToleranceX && Abs(currentY - backY) <= DistanceToleranceY) {
                                                        tooltipMsg := "Arrived at waypoint " . backWaypoint
                                                        ToolTip, %tooltipMsg%, 0, 0
                                                        break
                                                    }
                                                    Sleep, 100
                                                }

                                                Sleep, 1000
                                            }

                                            ; Get the coordinates of the original waypoint
                                            if (originalWaypoint <= Waypoints.Length()) {
                                                originalWaypointObj := Waypoints[originalWaypoint]
                                                origX := originalWaypointObj.x
                                                origY := originalWaypointObj.y

                                                ; Stop travel again to be safe
                                                IsTraveling := false
                                                SetTimer, TravelLoop, Off
                                                Sleep, 200

                                                ; Now move forward to the original waypoint
                                                tooltipMsg := "Returning to waypoint " . originalWaypoint . "..."
                                                ToolTip, %tooltipMsg%, 0, 0
                                                GoToWaypoint(originalWaypoint)

                                                ; Wait for arrival by checking coordinates
                                                Loop, 50 { ; 5 second timeout
                                                    GetCurrentCoordinates(currentX, currentY)
                                                    if (Abs(currentX - origX) <= DistanceToleranceX && Abs(currentY - origY) <= DistanceToleranceY) {
                                                        tooltipMsg := "Arrived back at waypoint " . originalWaypoint
                                                        ToolTip, %tooltipMsg%, 0, 0
                                                        break
                                                    }
                                                    Sleep, 100
                                                }

                                                Sleep, 1000
                                            }
                                            ; Continue to next retry iteration
                                        }
                                    }

                                    ; If we get here, all retries failed
                                    failMsg := "Pattern '" . patternDisplayName . "' still found after " . maxRetries . " retry attempts!"
                                    MsgBox, 0, Error, %failMsg%, 3
                                }

                                ; Function to find and click a pattern directly (without nodes)
                                ClickPattern(patternNameOrText, useControlClick := false) {
                                    global win1, patterns

                                    ; Check if patternNameOrText is an inline pattern (starts with |<) or a pattern name
                                    if (InStr(patternNameOrText, "|<") = 1) {
                                        ; It's an inline pattern text
                                        patternsToSearch := []
                                        patternsToSearch.Push(patternNameOrText)
                                        patternCount := 1
                                        patternDisplayName := "inline pattern"
                                    } else {
                                        ; It's a pattern name, collect all variations
                                        patternsToSearch := []
                                        patternCount := 0
                                        patternDisplayName := patternNameOrText

                                        ; First, check for exact match
                                        if (patterns[patternNameOrText] != "") {
                                            patternsToSearch.Push(patterns[patternNameOrText])
                                            patternCount++
                                        }

                                        ; Then check for numbered variations (pattern_1, pattern_2, etc.)
                                        variationNum := 1
                                        Loop {
                                            variationName := patternNameOrText . "_" . variationNum
                                            if (patterns[variationName] != "") {
                                                patternsToSearch.Push(patterns[variationName])
                                                patternCount++
                                                variationNum++
                                            } else {
                                                break
                                            }
                                        }

                                        ; If no patterns found at all, show error
                                        if (patternCount = 0) {
                                            ; Show what patterns ARE available
                                            availList := ""
                                            count := 0
                                            for pName in patterns {
                                                availList .= pName . ", "
                                                count++
                                                if (count >= 10)
                                                    break
                                            }
                                            MsgBox, 0, Error, Pattern '%patternNameOrText%' not found!`n`nAvailable patterns: %availList%`n`nCheck CapturedText.ini or resources.ini under [Patterns] section., 5
                                            return false
                                        }
                                    }

                                    ; Get window position for searching
                                    WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                                    if (winX = "" || winY = "") {
                                        MsgBox, 0, Error, Could not get window position!, 2
                                        return false
                                    }

                                    ; Calculate search area
                                    searchX2 := winX + winW
                                    searchY2 := winY + winH

                                    ; Search for pattern
                                    ToolTip, Searching for pattern '%patternDisplayName%'..., 0, 0
                                        patternFound := false

                                    for index, pattern in patternsToSearch {
                                        patternResult := FindText(px, py, winX, winY, searchX2, searchY2, 0, 0, pattern)

                                        if (patternResult) {
                                            patternFound := true
                                            break
                                        }
                                    }

                                    if (patternFound) {
                                        ; Pattern found! Click at the location
                                        if (useControlClick) {
                                            ToolTip, Pattern '%patternDisplayName%' found at screen (%px%`,%py%)! Control-clicking..., 0, 0
                                        } else {
                                            ToolTip, Pattern '%patternDisplayName%' found at screen (%px%`,%py%)! Clicking..., 0, 0
                                        }

                                        ; Activate the window first
                                        ;WinActivate, ahk_id %win1%
                                        Sleep, 50

                                        ; FindText returns SCREEN coordinates (px, py) - the CENTER of the found pattern
                                        ; Convert to window-relative coordinates and offset by -24 pixels on Y axis
                                        relativeX := px - winX
                                        relativeY := (py - winY) - 24

                                        ; Use SendMessage to move mouse and click
                                        lParam := (relativeY << 16) | (relativeX & 0xFFFF)

                                        ; Send mouse move
                                        SendMessage, 0x0200, 0, %lParam%, , ahk_id %win1% ; WM_MOUSEMOVE
                                        Sleep, 20

                                        ; Click at that location
                                        if (useControlClick) {
                                            ; Control+Click: include MK_CONTROL (0x0008) flag
                                            wParam := 0x0001 | 0x0008 ; MK_LBUTTON | MK_CONTROL
                                            SendMessage, 0x0201, %wParam%, %lParam%, , ahk_id %win1% ; WM_LBUTTONDOWN with Control
                                            Sleep, 20
                                            SendMessage, 0x0202, 0, %lParam%, , ahk_id %win1% ; WM_LBUTTONUP
                                        } else {
                                            ; Regular click
                                            SendMessage, 0x0201, 1, %lParam%, , ahk_id %win1% ; WM_LBUTTONDOWN
                                            Sleep, 20
                                            SendMessage, 0x0202, 0, %lParam%, , ahk_id %win1% ; WM_LBUTTONUP
                                        }
                                        Sleep, 100

                                        ToolTip, Pattern found and clicked!, 0, 0
                                        SetTimer, ClearTooltip, -2000
                                        return true
                                    } else {
                                        ToolTip, Pattern '%patternDisplayName%' not found on screen!, 0, 0
                                        SetTimer, ClearTooltip, -2000
                                        return false
                                    }
                                }

                                CheckPatternExists(patternNameOrText) {
                                    global win1, patterns

                                    ; Check if patternNameOrText is an inline pattern (starts with |<) or a pattern name
                                    if (InStr(patternNameOrText, "|<") = 1) {
                                        ; It's an inline pattern text
                                        patternsToSearch := []
                                        patternsToSearch.Push(patternNameOrText)
                                        patternCount := 1
                                    } else {
                                        ; It's a pattern name, collect all variations
                                        patternsToSearch := []
                                        patternCount := 0

                                        ; First, check for exact match
                                        if (patterns[patternNameOrText] != "") {
                                            patternsToSearch.Push(patterns[patternNameOrText])
                                            patternCount++
                                        }

                                        ; Then check for numbered variations (pattern_1, pattern_2, etc.)
                                        variationNum := 1
                                        Loop {
                                            variationName := patternNameOrText . "_" . variationNum
                                            if (patterns[variationName] != "") {
                                                patternsToSearch.Push(patterns[variationName])
                                                patternCount++
                                                variationNum++
                                            } else {
                                                break
                                            }
                                        }

                                        ; If no patterns found at all, return false
                                        if (patternCount = 0) {
                                            return false
                                        }
                                    }

                                    ; Get window position for searching
                                    WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                                    if (winX = "" || winY = "") {
                                        return false
                                    }

                                    ; Calculate search area
                                    searchX2 := winX + winW
                                    searchY2 := winY + winH

                                    ; Search for pattern
                                    for index, pattern in patternsToSearch {
                                        patternResult := FindText(px, py, winX, winY, searchX2, searchY2, 0, 0, pattern)

                                        if (patternResult) {
                                            return true
                                        }
                                    }

                                    return false
                                }

                                LoopClickUntilPatternFound(nodeNum1, nodeNum2, maxclicks, patternNameOrText) {
                                    global win1, patterns

                                    ; Check if patternNameOrText is an inline pattern (starts with |<) or a pattern name
                                    if (InStr(patternNameOrText, "|<") = 1) {
                                        ; It's an inline pattern text
                                        patternsToSearch := []
                                        patternsToSearch.Push(patternNameOrText)
                                        patternCount := 1
                                        patternDisplayName := "inline pattern"
                                    } else {
                                        ; It's a pattern name, collect all variations
                                        patternsToSearch := []
                                        patternCount := 0
                                        patternDisplayName := patternNameOrText

                                        ; First, check for exact match
                                        if (patterns[patternNameOrText] != "") {
                                            patternsToSearch.Push(patterns[patternNameOrText])
                                            patternCount++
                                        }

                                        ; Then check for numbered variations (pattern_1, pattern_2, etc.)
                                        variationNum := 1
                                        Loop {
                                            variationName := patternNameOrText . "_" . variationNum
                                            if (patterns[variationName] != "") {
                                                patternsToSearch.Push(patterns[variationName])
                                                patternCount++
                                                variationNum++
                                            } else {
                                                break
                                            }
                                        }

                                        ; If no patterns found at all, show error
                                        if (patternCount = 0) {
                                            ; Show what patterns ARE available
                                            availList := ""
                                            count := 0
                                            for pName in patterns {
                                                availList .= pName . ", "
                                                count++
                                                if (count >= 10)
                                                    break
                                            }
                                            MsgBox, 0, Error, Pattern '%patternNameOrText%' not found!`n`nAvailable patterns: %availList%`n`nCheck CapturedText.ini or resources.ini under [Patterns] section.`n`nOr use inline pattern starting with |<, 5
                                            return
                                        }
                                    }
                                    ; Get window position for searching
                                    WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                                    if (winX = "" || winY = "") {
                                        MsgBox, 0, Error, Could not get window position!, 2
                                        return
                                    }

                                    ; Calculate search area
                                    searchX2 := winX + winW
                                    searchY2 := winY + winH

                                    clickCount := 0
                                    Loop {
                                        clickCount++
                                        if (clickCount > maxclicks) {
                                            ToolTip, Max click count (%maxclicks%) reached. Pattern not found., 0, 0
                                            SetTimer, ClearTooltip, -2000
                                            return
                                        }

                                        ; Click node 1
                                        ToolTip, Clicking node %nodeNum1%..., 0, 0
                                        ClickAtNode(nodeNum1)
                                        Sleep, 500

                                        ; Check if any pattern variation appeared
                                        ToolTip, Searching for pattern '%patternDisplayName%'..., 0, 0
                                            patternFound := false

                                        for index, pattern in patternsToSearch {
                                            patternResult := FindText(px, py, winX, winY, searchX2, searchY2, 0, 0, pattern)
                                            if (patternResult) {
                                                patternFound := true
                                                break
                                            }
                                            else {
                                                ToolTip, failed to find pattern variation %index%..., 0, 0
                                            }
                                        }

                                        if (patternFound) {
                                            ToolTip, Pattern '%patternDisplayName%' found!, 0, 0
                                            SetTimer, ClearTooltip, -2000
                                            return
                                        }

                                        ; Pattern not found yet, click node 2 (if different from node 1)
                                        if (nodeNum2 != nodeNum1) {
                                            ToolTip, Clicking node %nodeNum2%..., 0, 0
                                            ClickAtNode(nodeNum2)
                                            Sleep, 500

                                            ; Check if any pattern variation appeared after node 2 click
                                            patternFound := false
                                            for index, pattern in patternsToSearch {
                                                patternResult := FindText(px, py, winX, winY, searchX2, searchY2, 0, 0, pattern)
                                                if (patternResult) {
                                                    patternFound := true
                                                    break
                                                }
                                            }
                                            if (patternFound) {
                                                ToolTip, Pattern '%patternDisplayName%' found!, 0, 0
                                                SetTimer, ClearTooltip, -2000
                                                return
                                            }
                                        }

                                        Sleep, 300
                                    }
                                }

                                LoopSearchUntilPatternFound(tries, patternNameOrText) {
                                    global win1, patterns

                                    ; Check if inline pattern or pattern name
                                    if (InStr(patternNameOrText, "|<") = 1) {
                                        patternsToSearch := [patternNameOrText]
                                        patternDisplayName := "inline pattern"
                                    } else {
                                        patternsToSearch := []
                                        patternDisplayName := patternNameOrText

                                        if (patterns[patternNameOrText] != "")
                                            patternsToSearch.Push(patterns[patternNameOrText])

                                        variationNum := 1
                                        Loop {
                                            variationName := patternNameOrText . "_" . variationNum
                                            if (patterns[variationName] != "") {
                                                patternsToSearch.Push(patterns[variationName])
                                                variationNum++
                                            } else {
                                                break
                                            }
                                        }

                                        if (patternsToSearch.Length() = 0) {
                                            ToolTip, Pattern '%patternNameOrText%' not found!, 0, 0
                                            SetTimer, ClearTooltip, -2000
                                            return false
                                        }
                                    }

                                    WinGetPos, winX, winY, winW, winH, ahk_id %win1%
                                    if (winX = "" || winY = "")
                                        return false

                                    searchX2 := winX + winW
                                    searchY2 := winY + winH

                                    Loop, %tries% {
                                        ToolTip, Searching for '%patternDisplayName%' (try %A_Index% of %tries%), 0, 0

                                        for index, pattern in patternsToSearch {
                                            if (FindText(px, py, winX, winY, searchX2, searchY2, 0, 0, pattern)) {
                                                ToolTip, Pattern '%patternDisplayName%' found!, 0, 0
                                                SetTimer, ClearTooltip, -2000
                                                return true
                                            }
                                        }
                                        Sleep, 100
                                    }

                                    ToolTip, Pattern '%patternDisplayName%' not found after %tries% tries, 0, 0
                                    SetTimer, ClearTooltip, -2000
                                    return false
                                }

                                ClickAtNode(nodeNum) {
                                    global TargetNodes

                                    ; Find the node with the matching ID
                                    targetNode := ""
                                    for index, node in TargetNodes {
                                        if (node.id = nodeNum) {
                                            targetNode := node
                                            break
                                        }
                                    }

                                    if (targetNode = "") {
                                        MsgBox, 0, Error, Node #%nodeNum% not found!, 2
                                        return
                                    }

                                    ; Use ClickAtWorldCoordinates for precise clicking with offset correction
                                    ClickAtWorldCoordinates(targetNode.worldX, targetNode.worldY)
                                }

                                holyground(delay, key, nodeNum1, nodeNum2="", nodeNum3="") {
                                    global TargetNodes
                                    sleep, %delay%
                                    ControlSend,, {%key%}, ahk_id %win1%

                                    ; Determine which node to use
                                    if (nodeNum2 = "" && nodeNum3 = "") {
                                        ; Only one node provided, use it directly
                                        nodeNum := nodeNum1
                                    } else {
                                        ; Multiple nodes provided, randomly select one
                                        Random, randomChoice, 1, 3
                                        if (randomChoice = 1)
                                            nodeNum := nodeNum1
                                        else if (randomChoice = 2)
                                            nodeNum := nodeNum2
                                        else
                                            nodeNum := nodeNum3
                                    }

                                    ; Find the node with the matching ID
                                    targetNode := ""
                                    for index, node in TargetNodes {
                                        if (node.id = nodeNum) {
                                            targetNode := node
                                            break
                                        }
                                    }

                                    if (targetNode = "") {
                                        MsgBox, 0, Error, Node #%nodeNum% not found!, 2
                                        return
                                    }

                                    ; Use ClickAtWorldCoordinates for precise clicking with offset correction
                                    ClickAtWorldCoordinates(targetNode.worldX, targetNode.worldY)
                                }
                                ShiftClickAtNode(nodeNum) {
                                    global TargetNodes, TargetGameWindow, CameraAngle, CameraRadius

                                    ; Find the node with the matching ID
                                    targetNode := ""
                                    for index, node in TargetNodes {
                                        if (node.id = nodeNum) {
                                            targetNode := node
                                            break
                                        }
                                    }

                                    if (targetNode = "") {
                                        MsgBox, 0, Error, Node #%nodeNum% not found!, 2
                                        return
                                    }

                                    if (!TargetGameWindow) {
                                        return
                                    }

                                    ; Get current position
                                    GetCurrentCoordinates(currentX, currentY)
                                    if (currentX = "" || currentY = "") {
                                        return
                                    }

                                    ; Calculate delta from current position to target
                                    deltaX := targetNode.worldX - currentX
                                    deltaY := targetNode.worldY - currentY

                                    ; Use EXACT same pixel conversion as ClickAtWorldCoordinates
                                    pixelsPerGameUnitX := 1.21

                                    ; Y-axis: piecewise linear based on camera radius
                                    if (CameraRadius <= 900) {
                                        pixelsPerGameUnitY := 0.95 * (CameraRadius / 900)
                                    } else if (CameraRadius <= 1000) {
                                        t := (CameraRadius - 900) / 100
                                        pixelsPerGameUnitY := 0.95 + (t * 0.18)
                                    } else if (CameraRadius <= 1500) {
                                        t := (CameraRadius - 1000) / 500
                                        pixelsPerGameUnitY := 1.13 - (t * 0.38)
                                    } else {
                                        t := (CameraRadius - 1500) / 500
                                        pixelsPerGameUnitY := 0.75 - (t * 0.43)
                                    }

                                    ; Scale the deltas
                                    scaledX := -deltaX * pixelsPerGameUnitX
                                    scaledY := -deltaY * pixelsPerGameUnitY

                                    ; Apply distance correction
                                    scaledX := scaledX * 0.94
                                    scaledY := scaledY * 1.19

                                    ; Apply camera rotation
                                    cos_angle := Cos(-CameraAngle)
                                    sin_angle := Sin(-CameraAngle)

                                    rotatedX := scaledX * cos_angle - scaledY * sin_angle
                                    rotatedY := scaledX * sin_angle + scaledY * cos_angle

                                    ; Use the same base click position
                                    baseClickX := 516
                                    baseClickY := 410

                                    ; Calculate final screen coordinates with offset correction
                                    clickX := baseClickX + Round(rotatedX) - 7
                                    clickY := baseClickY - Round(rotatedY) - 29

                                    ; Activate window
                                    ;WinActivate, ahk_id %TargetGameWindow%
                                    Sleep, 50

                                    ; Send click messages with MK_SHIFT flag (0x0004) in wParam
                                    ; wParam includes both the button state (MK_LBUTTON = 0x0001) and modifier (MK_SHIFT = 0x0004)
                                    wParam := 0x0001 | 0x0004 ; MK_LBUTTON | MK_SHIFT
                                    lParam := (clickY << 16) | (clickX & 0xFFFF)

                                    SendMessage, 0x0201, %wParam%, %lParam%, , ahk_id %TargetGameWindow% ; WM_LBUTTONDOWN with Shift
                                    Sleep, 20
                                    SendMessage, 0x0202, 0, %lParam%, , ahk_id %TargetGameWindow% ; WM_LBUTTONUP
                                    Sleep, 30
                                }

                                MakeWindowClickThrough(guiName) {
                                    ; Make a GUI window click-through by setting WS_EX_TRANSPARENT
                                    WinGet, hwnd, ID, ahk_class AutoHotkeyGUI ahk_exe %A_ScriptName%
                                    WinGetTitle, winTitle, ahk_id %hwnd%

                                    ; Try to get the handle by the GUI name directly
                                    Gui, %guiName%:+HwndguiHwnd

                                    if (guiHwnd) {
                                        ; Get current extended style
                                        exStyle := DllCall("GetWindowLong", "Ptr", guiHwnd, "Int", -20, "UInt")
                                        ; Add WS_EX_TRANSPARENT (0x20) and WS_EX_LAYERED (0x80000)
                                        exStyle := exStyle | 0x20 | 0x80000
                                        ; Set the new extended style
                                        DllCall("SetWindowLong", "Ptr", guiHwnd, "Int", -20, "UInt", exStyle)
                                    } else {
                                        ; Fallback: try by window title
                                        WinGet, hwnd, ID, %guiName%
                                        if (hwnd) {
                                            exStyle := DllCall("GetWindowLong", "Ptr", hwnd, "Int", -20, "UInt")
                                            exStyle := exStyle | 0x20 | 0x80000
                                            DllCall("SetWindowLong", "Ptr", hwnd, "Int", -20, "UInt", exStyle)
                                        }
                                    }
                                }

                                MakeWindowClickThroughByHandle(hwnd) {
                                    ; Make a window click-through using its handle
                                    static callCount := 0

                                    if (hwnd) {
                                        callCount++

                                        ; Try using WinSet ExStyle instead of DllCall
                                        WinSet, ExStyle, +0x20, ahk_id %hwnd% ; WS_EX_TRANSPARENT
                                        WinSet, ExStyle, +0x80000, ahk_id %hwnd% ; WS_EX_LAYERED

                                        ; Force window update
                                        WinSet, Redraw,, ahk_id %hwnd%

                                        if (callCount = 1) {
                                            ToolTip, Click-through applied using WinSet, 0, 0
                                            SetTimer, ClearTooltip, -3000
                                        }
                                    }
                                }

                                ; Call this label from your GUI button
                                ; Make sure TargetGameWindow is set first from your SelectWindow routine
                                ShowThumbnailView:
                                    global hSource, hThumbnail, thumbnailWidth, thumbnailHeight, hGui, hThumb, windowVisible, thumbnailIsOpen

                                    ; Toggle: if thumbnail is already open, close it
                                    if (thumbnailIsOpen) {
                                        Gosub, ThumbnailGuiClose
                                        return
                                    }

                                    ; Check if window is selected
                                    if (!TargetGameWindow) {
                                        MsgBox, Please select a window first!
                                        return
                                    }

                                    ; Set source window
                                    hSource := TargetGameWindow

                                    ; Configuration
                                    thumbnailWidth := 400
                                    thumbnailHeight := 300

                                    ; Verify window exists
                                    if (!WinExist("ahk_id " hSource)) {
                                        MsgBox, Window not found!
                                        return
                                    }

                                    ; Keep the original window visible
                                    windowVisible := true
                                    thumbnailIsOpen := true

                                    ; Create GUI for thumbnail
                                    ; Create GUI for thumbnail
                                    ; Create GUI for thumbnail
                                    ; Create GUI for thumbnail
                                    Gui, Thumbnail:New, +AlwaysOnTop +Caption +Resize -MaximizeBox
                                    Gui, Thumbnail:Add, Text, vThumbControl w%thumbnailWidth% h%thumbnailHeight% 0x4E Background000000 gThumbnailClick
                                    Gui, Thumbnail:Show, w%thumbnailWidth% h%thumbnailHeight%, Game Thumbnail

                                    ; Get the GUI window handle and control handle
                                    Gui, Thumbnail:+LastFound
                                    hGui := WinExist()
                                    GuiControlGet, hThumb, Hwnd, ThumbControl
                                    ; Enable diagonal-only resize

                                    ; Update thumbnailWidth/Height to actual client area size
                                    VarSetCapacity(RECT, 16, 0)
                                    DllCall("GetClientRect", "Ptr", hGui, "Ptr", &RECT)
                                    thumbnailWidth := NumGet(RECT, 8, "Int")
                                    thumbnailHeight := NumGet(RECT, 12, "Int")

                                    ; Small delay to ensure GUI is ready
                                    Sleep, 100

                                    ; Register thumbnail
                                    result := DllCall("dwmapi\DwmRegisterThumbnail", "Ptr", hGui, "Ptr", hSource, "Ptr*", hThumbnail)

                                    if (result != 0 || !hThumbnail) {
                                        MsgBox, Failed to register thumbnail! Error: %result%
                                        WinShow, ahk_id %hSource% ; Restore window on error
                                        Gui, Thumbnail:Destroy
                                        return
                                    }

                                    ; Update thumbnail properties
                                    Gosub, UpdateThumbnailNow

                                    ; Set timer to keep updating
                                    SetTimer, UpdateThumbnailNow, 1000
                                return

                                UpdateThumbnailNow:
                                    global hThumbnail, thumbnailWidth, thumbnailHeight, hSource

                                    if (!hThumbnail)
                                        return

                                    ; Get source window full size
                                    VarSetCapacity(RECT, 16, 0)
                                    DllCall("GetWindowRect", "Ptr", hSource, "Ptr", &RECT)
                                    srcWidth := NumGet(RECT, 8, "Int") - NumGet(RECT, 0, "Int")
                                    srcHeight := NumGet(RECT, 12, "Int") - NumGet(RECT, 4, "Int")

                                    ; Fill entire thumbnail area
                                    newWidth := thumbnailWidth
                                    newHeight := thumbnailHeight

                                    ; Set thumbnail properties
                                    VarSetCapacity(DWM_THUMBNAIL_PROPERTIES, 40, 0)
                                    NumPut(0x1F, DWM_THUMBNAIL_PROPERTIES, 0, "UInt") ; dwFlags
                                    NumPut(0, DWM_THUMBNAIL_PROPERTIES, 4, "Int") ; rcDestination.left
                                    NumPut(0, DWM_THUMBNAIL_PROPERTIES, 8, "Int") ; rcDestination.top
                                    NumPut(newWidth, DWM_THUMBNAIL_PROPERTIES, 12, "Int") ; rcDestination.right
                                    NumPut(newHeight, DWM_THUMBNAIL_PROPERTIES, 16, "Int") ; rcDestination.bottom
                                    NumPut(0, DWM_THUMBNAIL_PROPERTIES, 20, "Int") ; rcSource.left
                                    NumPut(0, DWM_THUMBNAIL_PROPERTIES, 24, "Int") ; rcSource.top
                                    NumPut(srcWidth, DWM_THUMBNAIL_PROPERTIES, 28, "Int") ; rcSource.right
                                    NumPut(srcHeight, DWM_THUMBNAIL_PROPERTIES, 32, "Int") ; rcSource.bottom
                                    NumPut(255, DWM_THUMBNAIL_PROPERTIES, 36, "UChar") ; opacity
                                    NumPut(1, DWM_THUMBNAIL_PROPERTIES, 37, "UChar") ; fVisible
                                    NumPut(0, DWM_THUMBNAIL_PROPERTIES, 38, "UChar") ; fSourceClientAreaOnly

                                    DllCall("dwmapi\DwmUpdateThumbnailProperties", "Ptr", hThumbnail, "Ptr", &DWM_THUMBNAIL_PROPERTIES)
                                return

                                UpdateThumbnailView:
                                    ; Redirect to the actual update function
                                    Gosub, UpdateThumbnailNow
                                return

                                ThumbnailGuiSize:
                                    ; Get actual client area size (excluding title bar and borders)
                                    Gui, Thumbnail:+LastFound
                                    VarSetCapacity(RECT, 16, 0)
                                    DllCall("GetClientRect", "Ptr", WinExist(), "Ptr", &RECT)
                                    thumbnailWidth := NumGet(RECT, 8, "Int")
                                    thumbnailHeight := NumGet(RECT, 12, "Int")

                                    GuiControl, Move, ThumbControl, w%thumbnailWidth% h%thumbnailHeight%
                                    Gosub, UpdateThumbnailNow
                                return

                                ThumbnailGuiClose:
                                    SetTimer, UpdateThumbnailNow, Off
                                    if (hThumbnail) {
                                        DllCall("dwmapi\DwmUnregisterThumbnail", "Ptr", hThumbnail)
                                        hThumbnail := 0
                                    }
                                    thumbnailIsOpen := false
                                    Gui, Thumbnail:Destroy
                                return
                                ThumbnailClick:
                                    global hSource, hGui

                                    ; Get current GUI client area size
                                    VarSetCapacity(RECT, 16, 0)
                                    DllCall("GetClientRect", "Ptr", hGui, "Ptr", &RECT)
                                    currentWidth := NumGet(RECT, 8, "Int")
                                    currentHeight := NumGet(RECT, 12, "Int")

                                    ; Get click position relative to GUI client area
                                    MouseGetPos, mouseX, mouseY
                                    DllCall("GetClientRect", "Ptr", hGui, "Ptr", &RECT)
                                    DllCall("ClientToScreen", "Ptr", hGui, "Ptr", &RECT)
                                    clientX := NumGet(RECT, 0, "Int")
                                    clientY := NumGet(RECT, 4, "Int")

                                    clickX := mouseX - clientX
                                    clickY := mouseY - clientY

                                    ; Get source window dimensions and title bar height
                                    VarSetCapacity(RECT, 16, 0)
                                    DllCall("GetWindowRect", "Ptr", hSource, "Ptr", &RECT)
                                    winWidth := NumGet(RECT, 8, "Int") - NumGet(RECT, 0, "Int")
                                    winHeight := NumGet(RECT, 12, "Int") - NumGet(RECT, 4, "Int")

                                    DllCall("GetClientRect", "Ptr", hSource, "Ptr", &RECT)
                                    clientWidth := NumGet(RECT, 8, "Int")
                                    clientHeight := NumGet(RECT, 12, "Int")

                                    ; Calculate title bar and border offsets
                                    titleBarHeight := winHeight - clientHeight
                                    borderWidth := (winWidth - clientWidth) / 2

                                    ; Scale using current GUI size
                                    scaleX := clientWidth / currentWidth
                                    scaleY := clientHeight / currentHeight

                                    targetX := Round(clickX * scaleX)
                                    targetY := Round(clickY * scaleY)

                                    ; Activate and click (coordinates are relative to client area)
                                    WinActivate, ahk_id %hSource%
                                    lParam := (targetY << 16) | (targetX & 0xFFFF)
                                    SendMessage, 0x201, 1, %lParam%,, ahk_id %hSource%
                                    Sleep, 50
                                    SendMessage, 0x202, 0, %lParam%,, ahk_id %hSource%
                                return
                                ; Image Clicker Settings GUI
                                ImageClickerSettings:
                                    patternCount := imageClickerPatterns.Length()

                                    Gui, ImageClicker:New, +AlwaysOnTop
                                    Gui, ImageClicker:Add, GroupBox, x10 y10 w300 h180, Image Clicker
                                    Gui, ImageClicker:Add, Text, x20 y35 w280 h20, Capture images to click repeatedly. Patterns: %patternCount%
                                    Gui, ImageClicker:Add, Button, x20 y60 w120 h30 gCaptureClickImage, Capture Image
                                    Gui, ImageClicker:Add, Button, x150 y60 w120 h30 gTestClickImage, Test Images
                                    Gui, ImageClicker:Add, Button, x20 y100 w120 h30 gStartImageClicker, Start Clicker
                                    Gui, ImageClicker:Add, Button, x150 y100 w120 h30 gStopImageClicker, Stop Clicker
                                    Gui, ImageClicker:Add, Button, x20 y140 w120 h25 gClearClickImages, Clear All
                                    Gui, ImageClicker:Add, Button, x150 y140 w120 h25 gImageClickerClose, Close

                                statusText := imageClickerRunning ? "Status: RUNNING" : "Status: STOPPED"
                                    Gui, ImageClicker:Add, Text, x20 y200 w280 h20 vImageClickerStatus, %statusText%

                                    Gui, ImageClicker:Show, w320 h230, Image Clicker
                                return

                                CaptureClickImage:
                                    GuiControl, ImageClicker:, ImageClickerStatus, Press 1 to capture image...
                                    KeyWait, 1, D
                                    capturedPattern := FindText().GetTextFromScreen(x1:=0, y1:=0, x2:=0, y2:=0, Threshold="", ScreenShot:=1, outX, outY)

                                    if (capturedPattern != "") {
                                        imageClickerPatterns.Push(capturedPattern)
                                        SaveImageClickerPatterns()
                                        patternCount := imageClickerPatterns.Length()
                                        GuiControl, ImageClicker:, ImageClickerStatus, Image %patternCount% captured successfully!
                                    } else {
                                        GuiControl, ImageClicker:, ImageClickerStatus, Failed to capture image. Try again.
                                    }
                                return

                                TestClickImage:
                                    if (imageClickerPatterns.Length() = 0) {
                                        GuiControl, ImageClicker:, ImageClickerStatus, No images captured yet!
                                        return
                                    }

                                    GuiControl, ImageClicker:, ImageClickerStatus, Testing images on screen...

                                    foundCount := 0
                                    for index, pattern in imageClickerPatterns {
                                        if (ok := FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, pattern)) {
                                            foundCount++
                                            GuiControl, ImageClicker:, ImageClickerStatus, Found image %index% at (%X%, %Y%)!
                                            FindText().MouseTip(X, Y)
                                            Sleep, 1000
                                        }
                                    }

                                    if (foundCount = 0) {
                                        GuiControl, ImageClicker:, ImageClickerStatus, No images found on screen.
                                    }
                                return

                                StartImageClicker:
                                    if (win1 = "" || !WinExist("ahk_id " . win1)) {
                                        GuiControl, ImageClicker:, ImageClickerStatus, Please select a game window first!
                                        return
                                    }

                                    if (imageClickerPatterns.Length() = 0) {
                                        GuiControl, ImageClicker:, ImageClickerStatus, Please capture images first!
                                        return
                                    }

                                    imageClickerRunning := true
                                    SetTimer, ImageClickerLoop, 100
                                    GuiControl, ImageClicker:, ImageClickerStatus, Status: RUNNING
                                return

                                StopImageClicker:
                                    imageClickerRunning := false
                                    SetTimer, ImageClickerLoop, Off
                                    GuiControl, ImageClicker:, ImageClickerStatus, Status: STOPPED
                                return

                                ImageClickerLoop:
                                    if (!imageClickerRunning) {
                                        SetTimer, ImageClickerLoop, Off
                                        return
                                    }

                                    ; Search for any of the captured images
                                    imageFound := false
                                    for index, pattern in imageClickerPatterns {
                                        if (ok := FindText(X, Y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, pattern)) {
                                            SendMessageClick(X, Y, win1)
                                            imageFound := true
                                            Sleep, 100
                                            break
                                        }
                                    }

                                    if (!imageFound) {
                                        ; No images found, sleep for 30 seconds
                                        Sleep, 22000
                                    }
                                return

                                ClearClickImages:
                                    MsgBox, 4, Clear Images, Clear all captured images?
                                    IfMsgBox Yes
                                    {
                                        imageClickerPatterns := []
                                        IniDelete, %SettingsFile%, ImageClickerPatterns
                                        GuiControl, ImageClicker:, ImageClickerStatus, All images cleared.
                                    }
                                return

                                ImageClickerClose:
                                    Gui, ImageClicker:Destroy
                                return

                                ; Save image clicker patterns to INI
                                SaveImageClickerPatterns() {
                                    global SettingsFile, imageClickerPatterns

                                    FileEncoding, UTF-8
                                    IniDelete, %SettingsFile%, ImageClickerPatterns

                                    for index, pattern in imageClickerPatterns {
                                        keyName := "Pattern" . index
                                        IniWrite, %pattern%, %SettingsFile%, ImageClickerPatterns, %keyName%
                                    }
                                    FileEncoding
                                }

                                ; Load image clicker patterns from INI
                                LoadImageClickerSettings() {
                                    global SettingsFile, imageClickerPatterns

                                    imageClickerPatterns := []

                                    IniRead, patternSection, %SettingsFile%, ImageClickerPatterns
                                    if (patternSection != "ERROR" && patternSection != "") {
                                        Loop, Parse, patternSection, `n
                                        {
                                            if (A_LoopField != "") {
                                                equalsPos := InStr(A_LoopField, "=")
                                                if (equalsPos > 0) {
                                                    patternText := SubStr(A_LoopField, equalsPos + 1)
                                                    imageClickerPatterns.Push(patternText)
                                                }
                                            }
                                        }
                                    }
                                }
